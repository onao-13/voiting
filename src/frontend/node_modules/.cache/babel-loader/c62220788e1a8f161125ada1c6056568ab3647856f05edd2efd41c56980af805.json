{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { Group } from './scene/group';\nimport { Selection } from './scene/selection';\nimport { Line } from './scene/shape/line';\nimport { Text } from './scene/shape/text';\nimport { Arc } from './scene/shape/arc';\nimport { BBox } from './scene/bbox';\nimport { Caption } from './caption';\nimport { createId } from './util/id';\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from './util/angle';\nimport { doOnce } from './util/function';\nimport { TimeInterval } from './util/time/interval';\nimport { Validate, BOOLEAN, OPT_BOOLEAN, NUMBER, OPT_NUMBER, OPT_FONT_STYLE, OPT_FONT_WEIGHT, STRING, OPT_COLOR_STRING, OPTIONAL, ARRAY, predicateWithMessage, OPT_STRING } from './util/validation';\nimport { ChartAxisDirection } from './chart/chartAxis';\nimport { Layers } from './chart/layers';\nimport { axisLabelsOverlap } from './util/labelPlacement';\nimport { ContinuousScale } from './scale/continuousScale';\nimport { Matrix } from './scene/matrix';\nvar TICK_COUNT = predicateWithMessage(function (v, ctx) {\n  return NUMBER(0)(v, ctx) || v instanceof TimeInterval;\n}, \"expecting a tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'\");\nvar OPT_TICK_COUNT = predicateWithMessage(function (v, ctx) {\n  return OPTIONAL(v, ctx, TICK_COUNT);\n}, \"expecting an optional tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'\");\nvar GRID_STYLE_KEYS = ['stroke', 'lineDash'];\nvar GRID_STYLE = predicateWithMessage(ARRAY(undefined, function (o) {\n  for (var key in o) {\n    if (!GRID_STYLE_KEYS.includes(key)) {\n      return false;\n    }\n  }\n  return true;\n}), \"expecting an Array of objects with gridline style properties such as 'stroke' and 'lineDash'\");\nvar Tags;\n(function (Tags) {\n  Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n  Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\nvar AxisLine = /** @class */function () {\n  function AxisLine() {\n    this.width = 1;\n    this.color = 'rgba(195, 195, 195, 1)';\n  }\n  __decorate([Validate(NUMBER(0))], AxisLine.prototype, \"width\", void 0);\n  __decorate([Validate(OPT_COLOR_STRING)], AxisLine.prototype, \"color\", void 0);\n  return AxisLine;\n}();\nexport { AxisLine };\nvar AxisTick = /** @class */function () {\n  function AxisTick() {\n    /**\n     * The line width to be used by axis ticks.\n     */\n    this.width = 1;\n    /**\n     * The line length to be used by axis ticks.\n     */\n    this.size = 6;\n    /**\n     * The color of the axis ticks.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n     */\n    this.color = 'rgba(195, 195, 195, 1)';\n    /**\n     * A hint of how many ticks to use (the exact number of ticks might differ),\n     * a `TimeInterval` or a `CountableTimeInterval`.\n     * For example:\n     *\n     *     axis.tick.count = 5;\n     *     axis.tick.count = year;\n     *     axis.tick.count = month.every(6);\n     */\n    this.count = undefined;\n  }\n  __decorate([Validate(NUMBER(0))], AxisTick.prototype, \"width\", void 0);\n  __decorate([Validate(NUMBER(0))], AxisTick.prototype, \"size\", void 0);\n  __decorate([Validate(OPT_COLOR_STRING)], AxisTick.prototype, \"color\", void 0);\n  __decorate([Validate(OPT_TICK_COUNT)], AxisTick.prototype, \"count\", void 0);\n  return AxisTick;\n}();\nexport { AxisTick };\nvar AxisLabel = /** @class */function () {\n  function AxisLabel() {\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n    /**\n     * The padding between the labels and the ticks.\n     */\n    this.padding = 5;\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n    this.color = 'rgba(87, 87, 87, 1)';\n    /**\n     * Custom label rotation in degrees.\n     * Labels are rendered perpendicular to the axis line by default.\n     * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n     * The value of this config is used as the angular offset/deflection\n     * from the default rotation.\n     */\n    this.rotation = undefined;\n    /**\n     * If specified and axis labels may collide, they are rotated to reduce collisions. If the\n     * `rotation` property is specified, it takes precedence.\n     */\n    this.autoRotate = undefined;\n    /**\n     * Rotation angle to use when autoRotate is applied.\n     */\n    this.autoRotateAngle = 335;\n    /**\n     * By default labels and ticks are positioned to the left of the axis line.\n     * `true` positions the labels to the right of the axis line.\n     * However, if the axis is rotated, it's easier to think in terms\n     * of this side or the opposite side, rather than left and right.\n     * We use the term `mirror` for conciseness, although it's not\n     * true mirroring - for example, when a label is rotated, so that\n     * it is inclined at the 45 degree angle, text flowing from north-west\n     * to south-east, ending at the tick to the left of the axis line,\n     * and then we set this config to `true`, the text will still be flowing\n     * from north-west to south-east, _starting_ at the tick to the right\n     * of the axis line.\n     */\n    this.mirrored = false;\n    /**\n     * Labels are rendered perpendicular to the axis line by default.\n     * Setting this config to `true` makes labels render parallel to the axis line\n     * and center aligns labels' text at the ticks.\n     */\n    this.parallel = false;\n    /**\n     * In case {@param value} is a number, the {@param fractionDigits} parameter will\n     * be provided as well. The `fractionDigits` corresponds to the number of fraction\n     * digits used by the tick step. For example, if the tick step is `0.0005`,\n     * the `fractionDigits` is 4.\n     */\n    this.formatter = undefined;\n    this.format = undefined;\n  }\n  __decorate([Validate(OPT_FONT_STYLE)], AxisLabel.prototype, \"fontStyle\", void 0);\n  __decorate([Validate(OPT_FONT_WEIGHT)], AxisLabel.prototype, \"fontWeight\", void 0);\n  __decorate([Validate(NUMBER(1))], AxisLabel.prototype, \"fontSize\", void 0);\n  __decorate([Validate(STRING)], AxisLabel.prototype, \"fontFamily\", void 0);\n  __decorate([Validate(NUMBER(0))], AxisLabel.prototype, \"padding\", void 0);\n  __decorate([Validate(OPT_COLOR_STRING)], AxisLabel.prototype, \"color\", void 0);\n  __decorate([Validate(OPT_NUMBER(-360, 360))], AxisLabel.prototype, \"rotation\", void 0);\n  __decorate([Validate(OPT_BOOLEAN)], AxisLabel.prototype, \"autoRotate\", void 0);\n  __decorate([Validate(NUMBER(-360, 360))], AxisLabel.prototype, \"autoRotateAngle\", void 0);\n  __decorate([Validate(BOOLEAN)], AxisLabel.prototype, \"mirrored\", void 0);\n  __decorate([Validate(BOOLEAN)], AxisLabel.prototype, \"parallel\", void 0);\n  __decorate([Validate(OPT_STRING)], AxisLabel.prototype, \"format\", void 0);\n  return AxisLabel;\n}();\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar Axis = /** @class */function () {\n  function Axis(scale) {\n    this.id = createId(this);\n    this.nice = true;\n    this.dataDomain = [];\n    this.axisGroup = new Group({\n      name: this.id + \"-axis\",\n      layer: true,\n      zIndex: Layers.AXIS_ZINDEX\n    });\n    this.crossLineGroup = new Group({\n      name: this.id + \"-CrossLines\"\n    });\n    this.lineGroup = this.axisGroup.appendChild(new Group({\n      name: this.id + \"-Line\"\n    }));\n    this.tickGroup = this.axisGroup.appendChild(new Group({\n      name: this.id + \"-Tick\"\n    }));\n    this.titleGroup = this.axisGroup.appendChild(new Group({\n      name: this.id + \"-Title\"\n    }));\n    this.tickGroupSelection = Selection.select(this.tickGroup).selectAll();\n    this.lineNode = this.lineGroup.appendChild(new Line());\n    this.gridlineGroup = new Group({\n      name: this.id + \"-gridline\",\n      layer: true,\n      zIndex: Layers.AXIS_GRIDLINES_ZINDEX\n    });\n    this.gridlineGroupSelection = Selection.select(this.gridlineGroup).selectAll();\n    this._crossLines = [];\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.label = new AxisLabel();\n    this.translation = {\n      x: 0,\n      y: 0\n    };\n    this.rotation = 0; // axis rotation angle in degrees\n    this.requestedRange = [0, 1];\n    this._visibleRange = [0, 1];\n    this._title = undefined;\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n     * (in degrees).\n     */\n    this._gridLength = 0;\n    /**\n     * The array of styles to cycle through when rendering grid lines.\n     * For example, use two {@link GridStyle} objects for alternating styles.\n     * Contains only one {@link GridStyle} object by default, meaning all grid lines\n     * have the same style.\n     */\n    this.gridStyle = [{\n      stroke: 'rgba(219, 219, 219, 1)',\n      lineDash: [4, 2]\n    }];\n    /**\n     * `false` - render grid as lines of {@link gridLength} that extend the ticks\n     *           on the opposite side of the axis\n     * `true` - render grid as concentric circles that go through the ticks\n     */\n    this._radialGrid = false;\n    this.fractionDigits = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    this.thickness = 0;\n    this._scale = scale;\n    this.refreshScale();\n  }\n  Object.defineProperty(Axis.prototype, \"scale\", {\n    get: function () {\n      return this._scale;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"crossLines\", {\n    get: function () {\n      return this._crossLines;\n    },\n    set: function (value) {\n      var _this = this;\n      var _a, _b;\n      (_a = this._crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) {\n        return _this.detachCrossLine(crossLine);\n      });\n      this._crossLines = value;\n      (_b = this._crossLines) === null || _b === void 0 ? void 0 : _b.forEach(function (crossLine) {\n        _this.attachCrossLine(crossLine);\n        _this.initCrossLine(crossLine);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Axis.prototype.attachCrossLine = function (crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n  };\n  Axis.prototype.detachCrossLine = function (crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n  };\n  /**\n   * Meant to be overridden in subclasses to provide extra context the the label formatter.\n   * The return value of this function will be passed to the laber.formatter as the `axis` parameter.\n   */\n  Axis.prototype.getMeta = function () {\n    // Override point for subclasses.\n  };\n  Axis.prototype.refreshScale = function () {\n    var _this = this;\n    var _a;\n    this.requestedRange = this.scale.range.slice();\n    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) {\n      _this.initCrossLine(crossLine);\n    });\n  };\n  Axis.prototype.updateRange = function () {\n    var _a;\n    var _b = this,\n      rr = _b.requestedRange,\n      vr = _b.visibleRange,\n      scale = _b.scale;\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    scale.range = [start, start + span];\n    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  };\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param width Object's width.\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  Axis.prototype.inRange = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n    return this.inRangeEx(x, width, tolerance) === 0;\n  };\n  Axis.prototype.inRangeEx = function (x, width, tolerance) {\n    if (width === void 0) {\n      width = 0;\n    }\n    if (tolerance === void 0) {\n      tolerance = 0;\n    }\n    var range = this.range;\n    // Account for inverted ranges, for example [500, 100] as well as [100, 500]\n    var min = Math.min(range[0], range[1]);\n    var max = Math.max(range[0], range[1]);\n    if (x + width < min - tolerance) {\n      return -1; // left of range\n    }\n\n    if (x > max + tolerance) {\n      return 1; // right of range\n    }\n\n    return 0; // in range\n  };\n\n  Object.defineProperty(Axis.prototype, \"range\", {\n    get: function () {\n      return this.requestedRange;\n    },\n    set: function (value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"visibleRange\", {\n    get: function () {\n      return this._visibleRange.slice();\n    },\n    set: function (value) {\n      if (value && value.length === 2) {\n        var _a = __read(value, 2),\n          min = _a[0],\n          max = _a[1];\n        min = Math.max(0, min);\n        max = Math.min(1, max);\n        min = Math.min(min, max);\n        max = Math.max(min, max);\n        this._visibleRange = [min, max];\n        this.updateRange();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Axis.prototype.onLabelFormatChange = function (ticks, format) {\n    var scale = this.scale;\n    if (format && scale && scale.tickFormat) {\n      try {\n        this.labelFormatter = scale.tickFormat({\n          ticks: ticks,\n          count: ticks.length,\n          specifier: format\n        });\n      } catch (e) {\n        this.labelFormatter = undefined;\n        doOnce(function () {\n          return console.warn(\"AG Charts - the axis label format string \" + format + \" is invalid. No formatting will be applied\");\n        }, \"invalid axis label format string \" + format);\n      }\n    } else {\n      this.labelFormatter = undefined;\n    }\n  };\n  Object.defineProperty(Axis.prototype, \"title\", {\n    get: function () {\n      return this._title;\n    },\n    set: function (value) {\n      var oldTitle = this._title;\n      if (oldTitle !== value) {\n        if (oldTitle) {\n          this.titleGroup.removeChild(oldTitle.node);\n        }\n        if (value) {\n          value.node.rotation = -Math.PI / 2;\n          this.titleGroup.appendChild(value.node);\n        }\n        this._title = value;\n        // position title so that it doesn't briefly get rendered in the top left hand corner of the canvas before update is called.\n        this.updateTitle({\n          ticks: this.scale.ticks(this.tick.count)\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"gridLength\", {\n    get: function () {\n      return this._gridLength;\n    },\n    set: function (value) {\n      var _this = this;\n      var _a;\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.gridlineGroupSelection = this.gridlineGroupSelection.remove().setData([]);\n      }\n      this._gridLength = value;\n      (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) {\n        _this.initCrossLine(crossLine);\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"radialGrid\", {\n    get: function () {\n      return this._radialGrid;\n    },\n    set: function (value) {\n      if (this._radialGrid !== value) {\n        this._radialGrid = value;\n        this.gridlineGroupSelection = this.gridlineGroupSelection.remove().setData([]);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  Axis.prototype.update = function (primaryTickCount) {\n    var _a, _b;\n    this.calculateDomain();\n    var _c = this,\n      scale = _c.scale,\n      gridLength = _c.gridLength,\n      tick = _c.tick,\n      label = _c.label,\n      requestedRange = _c.requestedRange;\n    var requestedRangeMin = Math.min.apply(Math, __spread(requestedRange));\n    var requestedRangeMax = Math.max.apply(Math, __spread(requestedRange));\n    var rotation = toRadians(this.rotation);\n    var parallelLabels = label.parallel;\n    var anySeriesActive = this.isAnySeriesActive();\n    // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n    var sideFlag = label.mirrored ? 1 : -1;\n    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    var halfBandwidth = (scale.bandwidth || 0) / 2;\n    this.updatePosition();\n    this.updateLine();\n    var i = 0;\n    var labelOverlap = true;\n    var ticks = [];\n    var defaultTickCount = 10;\n    var tickCount = this.tick.count !== undefined;\n    var nice = this.nice && scale.nice;\n    var continuous = scale instanceof ContinuousScale;\n    var secondaryAxis = primaryTickCount !== undefined;\n    var calculatePrimaryDomain = !secondaryAxis && !tickCount && nice;\n    scale.domain = this.dataDomain;\n    if (nice) {\n      scale.nice(this.tick.count);\n    }\n    while (labelOverlap) {\n      var unchanged = true;\n      var _loop_1 = function () {\n        if (i >= defaultTickCount) {\n          return \"break\";\n        }\n        if (calculatePrimaryDomain) {\n          // `scale.nice` mutates `scale.domain` based on new tick count\n          scale.domain = this_1.dataDomain;\n          scale.nice(defaultTickCount - i);\n        }\n        var prevTicks = ticks;\n        // filter generated ticks if this is a category axis or this.tick.count is specified\n        var filteredTicks = continuous && !tickCount || i === 0 ? undefined : ticks.filter(function (_, i) {\n          return i % 2 === 0;\n        });\n        var secondaryAxisTicks = void 0;\n        if (secondaryAxis) {\n          // `updateSecondaryAxisTicks` mutates `scale.domain` based on `primaryTickCount`\n          secondaryAxisTicks = this_1.updateSecondaryAxisTicks(primaryTickCount);\n        }\n        ticks = (_a = filteredTicks !== null && filteredTicks !== void 0 ? filteredTicks : secondaryAxisTicks, _a !== null && _a !== void 0 ? _a : this_1.scale.ticks(this_1.tick.count, i));\n        this_1.updateSelections({\n          halfBandwidth: halfBandwidth,\n          gridLength: gridLength,\n          ticks: ticks\n        });\n        if (!secondaryAxis && ticks.length > 0) {\n          primaryTickCount = ticks.length;\n        }\n        unchanged = ticks.every(function (t, i) {\n          return t === prevTicks[i];\n        });\n        i++;\n      };\n      var this_1 = this;\n      while (unchanged) {\n        var state_1 = _loop_1();\n        if (state_1 === \"break\") break;\n      }\n      if (unchanged) {\n        break;\n      }\n      // When the scale domain or the ticks change, the label format may change\n      this.onLabelFormatChange(ticks, this.label.format);\n      var _d = this.updateLabels({\n          parallelFlipRotation: parallelFlipRotation,\n          regularFlipRotation: regularFlipRotation,\n          sideFlag: sideFlag,\n          tickLineGroupSelection: this.tickGroupSelection,\n          ticks: ticks\n        }),\n        labelData = _d.labelData,\n        rotated = _d.rotated;\n      var labelPadding = rotated ? 0 : 10;\n      labelOverlap = axisLabelsOverlap(labelData, labelPadding);\n    }\n    this.updateGridLines({\n      gridLength: gridLength,\n      halfBandwidth: halfBandwidth,\n      sideFlag: sideFlag\n    });\n    var anyTickVisible = false;\n    var visibleFn = function (node) {\n      var min = Math.floor(requestedRangeMin);\n      var max = Math.ceil(requestedRangeMax);\n      var visible = min !== max && node.translationY >= min && node.translationY <= max;\n      anyTickVisible = visible || anyTickVisible;\n      return visible;\n    };\n    var _e = this,\n      gridlineGroupSelection = _e.gridlineGroupSelection,\n      tickGroupSelection = _e.tickGroupSelection;\n    gridlineGroupSelection.attrFn('visible', visibleFn);\n    tickGroupSelection.attrFn('visible', visibleFn);\n    this.tickGroup.visible = anyTickVisible;\n    this.gridlineGroup.visible = anyTickVisible;\n    (_b = this.crossLines) === null || _b === void 0 ? void 0 : _b.forEach(function (crossLine) {\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\n      crossLine.label.parallel = crossLine.label.parallel !== undefined ? crossLine.label.parallel : parallelLabels;\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n    this.updateTitle({\n      ticks: ticks\n    });\n    tickGroupSelection.selectByTag(Tags.Tick).each(function (line) {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.color;\n      line.visible = anyTickVisible;\n    }).attr('x1', sideFlag * tick.size).attr('x2', 0).attr('y1', 0).attr('y2', 0);\n    return primaryTickCount;\n  };\n  Axis.prototype.calculateDomain = function () {\n    // Placeholder for subclasses to override.\n  };\n  Axis.prototype.updatePosition = function () {\n    var _a = this,\n      label = _a.label,\n      axisGroup = _a.axisGroup,\n      gridlineGroup = _a.gridlineGroup,\n      crossLineGroup = _a.crossLineGroup,\n      translation = _a.translation,\n      gridlineGroupSelection = _a.gridlineGroupSelection,\n      gridPadding = _a.gridPadding,\n      gridLength = _a.gridLength;\n    var rotation = toRadians(this.rotation);\n    var sideFlag = label.mirrored ? 1 : -1;\n    var translationX = Math.floor(translation.x);\n    var translationY = Math.floor(translation.y);\n    crossLineGroup.translationX = translationX;\n    crossLineGroup.translationY = translationY;\n    crossLineGroup.rotation = rotation;\n    axisGroup.translationX = translationX;\n    axisGroup.translationY = translationY;\n    axisGroup.rotation = rotation;\n    gridlineGroup.translationX = translationX;\n    gridlineGroup.translationY = translationY;\n    gridlineGroup.rotation = rotation;\n    gridlineGroupSelection.selectByTag(Tags.GridLine).each(function (line) {\n      line.x1 = gridPadding;\n      line.x2 = -sideFlag * gridLength + gridPadding;\n      line.y1 = 0;\n      line.y2 = 0;\n    });\n  };\n  Axis.prototype.updateSecondaryAxisTicks = function (_primaryTickCount) {\n    throw new Error('AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.');\n  };\n  Axis.prototype.updateTickGroupSelection = function (_a) {\n    var data = _a.data;\n    var updateAxis = this.tickGroupSelection.setData(data);\n    updateAxis.exit.remove();\n    var enterAxis = updateAxis.enter.append(Group);\n    // Line auto-snaps to pixel grid if vertical or horizontal.\n    enterAxis.append(Line).each(function (node) {\n      return node.tag = Tags.Tick;\n    });\n    enterAxis.append(Text);\n    return updateAxis.merge(enterAxis);\n  };\n  Axis.prototype.updateGridLineGroupSelection = function (_a) {\n    var gridLength = _a.gridLength,\n      data = _a.data;\n    var updateGridlines = this.gridlineGroupSelection.setData(gridLength ? data : []);\n    updateGridlines.exit.remove();\n    var gridlineGroupSelection = updateGridlines;\n    if (gridLength) {\n      var tagFn = function (node) {\n        return node.tag = Tags.GridLine;\n      };\n      var enterGridline = updateGridlines.enter.append(Group);\n      if (this.radialGrid) {\n        enterGridline.append(Arc).each(tagFn);\n      } else {\n        enterGridline.append(Line).each(tagFn);\n      }\n      gridlineGroupSelection = updateGridlines.merge(enterGridline);\n    }\n    return gridlineGroupSelection;\n  };\n  Axis.prototype.updateSelections = function (_a) {\n    var ticks = _a.ticks,\n      halfBandwidth = _a.halfBandwidth,\n      gridLength = _a.gridLength;\n    var scale = this.scale;\n    var data = ticks.map(function (t) {\n      return {\n        tick: t,\n        translationY: scale.convert(t) + halfBandwidth\n      };\n    });\n    var gridlineGroupSelection = this.updateGridLineGroupSelection({\n      gridLength: gridLength,\n      data: data\n    });\n    var tickGroupSelection = this.updateTickGroupSelection({\n      data: data\n    });\n    // We need raw `translationY` values on `datum` for accurate label collision detection in axes.update()\n    // But node `translationY` values must be rounded to get pixel grid alignment\n    gridlineGroupSelection.attrFn('translationY', function (_, datum) {\n      return Math.round(datum.translationY);\n    });\n    tickGroupSelection.attrFn('translationY', function (_, datum) {\n      return Math.round(datum.translationY);\n    });\n    this.tickGroupSelection = tickGroupSelection;\n    this.gridlineGroupSelection = gridlineGroupSelection;\n  };\n  Axis.prototype.updateGridLines = function (_a) {\n    var gridLength = _a.gridLength,\n      halfBandwidth = _a.halfBandwidth,\n      sideFlag = _a.sideFlag;\n    var _b = this,\n      gridStyle = _b.gridStyle,\n      scale = _b.scale,\n      tick = _b.tick,\n      gridPadding = _b.gridPadding;\n    if (gridLength && gridStyle.length) {\n      var styleCount_1 = gridStyle.length;\n      var gridLines = void 0;\n      if (this.radialGrid) {\n        var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(gridLength));\n        gridLines = this.gridlineGroupSelection.selectByTag(Tags.GridLine).each(function (arc, datum) {\n          var radius = Math.round(scale.convert(datum) + halfBandwidth);\n          arc.centerX = 0;\n          arc.centerY = scale.range[0] - radius;\n          arc.endAngle = angularGridLength_1;\n          arc.radiusX = radius;\n          arc.radiusY = radius;\n        });\n      } else {\n        gridLines = this.gridlineGroupSelection.selectByTag(Tags.GridLine).each(function (line) {\n          line.x1 = gridPadding;\n          line.x2 = -sideFlag * gridLength + gridPadding;\n          line.y1 = 0;\n          line.y2 = 0;\n          line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n        });\n      }\n      gridLines.each(function (gridLine, _, index) {\n        var style = gridStyle[index % styleCount_1];\n        gridLine.stroke = style.stroke;\n        gridLine.strokeWidth = tick.width;\n        gridLine.lineDash = style.lineDash;\n        gridLine.fill = undefined;\n      });\n    }\n  };\n  Axis.prototype.updateLabels = function (_a) {\n    var _this = this;\n    var ticks = _a.ticks,\n      tickLineGroupSelection = _a.tickLineGroupSelection,\n      sideFlag = _a.sideFlag,\n      parallelFlipRotation = _a.parallelFlipRotation,\n      regularFlipRotation = _a.regularFlipRotation;\n    var _b = this,\n      label = _b.label,\n      parallelLabels = _b.label.parallel,\n      scale = _b.scale,\n      tick = _b.tick,\n      requestedRange = _b.requestedRange;\n    var requestedRangeMin = Math.min.apply(Math, __spread(requestedRange));\n    var requestedRangeMax = Math.max.apply(Math, __spread(requestedRange));\n    var labelAutoRotation = 0;\n    var labelRotation = label.rotation ? normalizeAngle360(toRadians(label.rotation)) : 0;\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    // Flip if the axis rotation angle is in the top hemisphere.\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n    this.fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n    // Update properties that affect the size of the axis labels and measure the labels\n    var labelBboxes = new Map();\n    var labelCount = 0;\n    var halfFirstLabelLength = false;\n    var halfLastLabelLength = false;\n    var availableRange = requestedRangeMax - requestedRangeMin;\n    var labelSelection = tickLineGroupSelection.selectByClass(Text).each(function (node, datum, index) {\n      var tick = datum.tick;\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.text = _this.formatTickDatum(tick, index);\n      var userHidden = node.text === '' || node.text == undefined;\n      labelBboxes.set(index, userHidden ? null : node.computeBBox());\n      if (userHidden) {\n        return;\n      }\n      labelCount++;\n      if (index === 0 && node.translationY === scale.range[0]) {\n        halfFirstLabelLength = true; // first label protrudes axis line\n      } else if (index === ticks.length - 1 && node.translationY === scale.range[1]) {\n        halfLastLabelLength = true; // last label protrudes axis line\n      }\n    });\n\n    var labelX = sideFlag * (tick.size + label.padding);\n    var step = availableRange / labelCount;\n    var rotateLabels = function (bboxes, parallelLabels) {\n      var e_1, _a;\n      var rotate = false;\n      var lastIdx = bboxes.size - 1;\n      var padding = 12;\n      try {\n        for (var _b = __values(bboxes.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = __read(_c.value, 2),\n            i = _d[0],\n            bbox = _d[1];\n          if (bbox == null) {\n            continue;\n          }\n          var divideBy = i === 0 && halfFirstLabelLength || i === lastIdx && halfLastLabelLength ? 2 : 1;\n          // When the labels are parallel to the axis line, use the width of the text to calculate the total length of all labels\n          var length_1 = parallelLabels ? bbox.width / divideBy : bbox.height / divideBy;\n          var lengthWithPadding = length_1 <= 0 ? 0 : length_1 + padding;\n          if (lengthWithPadding > step) {\n            rotate = true;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return rotate;\n    };\n    var rotate = rotateLabels(labelBboxes, parallelLabels);\n    if (label.rotation === undefined && label.autoRotate === true && rotate) {\n      // When no user label rotation angle has been specified and the width of any label exceeds the average tick gap (`rotate` is `true`),\n      // automatically rotate the labels\n      labelAutoRotation = normalizeAngle360(toRadians(label.autoRotateAngle));\n    }\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    var labelTextBaseline = parallelLabels && !labelRotation ? sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom' : 'middle';\n    var alignFlag = labelRotation > 0 && labelRotation <= Math.PI || labelAutoRotation > 0 && labelAutoRotation <= Math.PI ? -1 : 1;\n    var labelTextAlign = parallelLabels ? labelRotation || labelAutoRotation ? sideFlag * alignFlag === -1 ? 'end' : 'start' : 'center' : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n    var labelData = [];\n    var combinedRotation = autoRotation + labelRotation + labelAutoRotation;\n    var labelRotationMatrix = new Matrix();\n    if (combinedRotation) {\n      Matrix.updateTransformMatrix(labelRotationMatrix, 1, 1, combinedRotation, 0, 0);\n    }\n    labelSelection.each(function (label, datum) {\n      if (label.text === '' || label.text == undefined) {\n        label.visible = false; // hide empty labels\n        return;\n      }\n      label.textBaseline = labelTextBaseline;\n      label.textAlign = labelTextAlign;\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n      label.rotation = combinedRotation;\n      var userHidden = label.text === '' || label.text == undefined;\n      if (userHidden) {\n        return;\n      }\n      // Text.computeBBox() does not take into account any of the transformations that have been applied to the label nodes, only the width and height are useful.\n      // Rather than taking into account all transformations including those of parent nodes which would be the result of `computeTransformedBBox()`, giving the x and y in the entire axis coordinate space,\n      // take into account only the rotation and translation applied to individual label nodes to get the x y coordinates of the labels relative to each other\n      // this makes label collision detection a lot simpler\n      var bbox = label.computeBBox();\n      var _a = bbox.width,\n        width = _a === void 0 ? 0 : _a,\n        _b = bbox.height,\n        height = _b === void 0 ? 0 : _b;\n      var translationY = datum.translationY;\n      var translatedBBox = new BBox(labelX, translationY, 0, 0);\n      labelRotationMatrix.transformBBox(translatedBBox, 0, bbox);\n      var _c = bbox.x,\n        x = _c === void 0 ? 0 : _c,\n        _d = bbox.y,\n        y = _d === void 0 ? 0 : _d;\n      labelData.push({\n        point: {\n          x: x,\n          y: y,\n          size: 0\n        },\n        label: {\n          width: width,\n          height: height,\n          text: label.text\n        }\n      });\n    });\n    return {\n      labelData: labelData,\n      rotated: !!(labelRotation || labelAutoRotation)\n    };\n  };\n  Axis.prototype.updateLine = function () {\n    // Render axis line.\n    var _a = this,\n      lineNode = _a.lineNode,\n      requestedRange = _a.requestedRange;\n    lineNode.x1 = 0;\n    lineNode.x2 = 0;\n    lineNode.y1 = requestedRange[0];\n    lineNode.y2 = requestedRange[1];\n    lineNode.strokeWidth = this.line.width;\n    lineNode.stroke = this.line.color;\n    lineNode.visible = true;\n  };\n  Axis.prototype.updateTitle = function (_a) {\n    var ticks = _a.ticks;\n    var _b;\n    var _c = this,\n      label = _c.label,\n      rotation = _c.rotation,\n      title = _c.title,\n      lineNode = _c.lineNode,\n      requestedRange = _c.requestedRange,\n      tickGroup = _c.tickGroup,\n      lineGroup = _c.lineGroup;\n    if (!title) {\n      return;\n    }\n    var titleVisible = false;\n    if (title.enabled && lineNode.visible) {\n      titleVisible = true;\n      var sideFlag = label.mirrored ? 1 : -1;\n      var parallelFlipRotation = normalizeAngle360(rotation);\n      var padding = Caption.PADDING;\n      var titleNode = title.node;\n      var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n      titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n      titleNode.x = Math.floor(titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2);\n      var lineBBox = lineGroup.computeBBox();\n      var bboxYDimension = rotation === 0 ? lineBBox.width : lineBBox.height;\n      if (((_b = ticks) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n        var tickBBox = tickGroup.computeBBox();\n        var tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\n        if (Math.abs(tickWidth) < Infinity) {\n          bboxYDimension += tickWidth;\n        }\n      }\n      if (sideFlag === -1) {\n        titleNode.y = Math.floor(titleRotationFlag * (-padding - bboxYDimension));\n      } else {\n        titleNode.y = Math.floor(-padding - bboxYDimension);\n      }\n      titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n    }\n    title.node.visible = titleVisible;\n  };\n  // For formatting (nice rounded) tick values.\n  Axis.prototype.formatTickDatum = function (datum, index) {\n    var _a = this,\n      label = _a.label,\n      labelFormatter = _a.labelFormatter,\n      fractionDigits = _a.fractionDigits;\n    var meta = this.getMeta();\n    return label.formatter ? label.formatter({\n      value: fractionDigits >= 0 ? datum : String(datum),\n      index: index,\n      fractionDigits: fractionDigits,\n      formatter: labelFormatter,\n      axis: meta\n    }) : labelFormatter ? labelFormatter(datum) : typeof datum === 'number' && fractionDigits >= 0 ?\n    // the `datum` is a floating point number\n    datum.toFixed(fractionDigits) :\n    // the`datum` is an integer, a string or an object\n    String(datum);\n  };\n  // For formatting arbitrary values between the ticks.\n  Axis.prototype.formatDatum = function (datum) {\n    return String(datum);\n  };\n  Axis.prototype.computeBBox = function () {\n    return this.axisGroup.computeBBox();\n  };\n  Axis.prototype.initCrossLine = function (crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  };\n  Axis.prototype.isAnySeriesActive = function () {\n    return false;\n  };\n  __decorate([Validate(BOOLEAN)], Axis.prototype, \"nice\", void 0);\n  __decorate([Validate(GRID_STYLE)], Axis.prototype, \"gridStyle\", void 0);\n  __decorate([Validate(NUMBER(0))], Axis.prototype, \"thickness\", void 0);\n  return Axis;\n}();\nexport { Axis };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__read","o","n","m","Symbol","iterator","call","ar","e","next","done","push","value","error","__spread","concat","__values","s","TypeError","Group","Selection","Line","Text","Arc","BBox","Caption","createId","normalizeAngle360","normalizeAngle360Inclusive","toRadians","doOnce","TimeInterval","Validate","BOOLEAN","OPT_BOOLEAN","NUMBER","OPT_NUMBER","OPT_FONT_STYLE","OPT_FONT_WEIGHT","STRING","OPT_COLOR_STRING","OPTIONAL","ARRAY","predicateWithMessage","OPT_STRING","ChartAxisDirection","Layers","axisLabelsOverlap","ContinuousScale","Matrix","TICK_COUNT","v","ctx","OPT_TICK_COUNT","GRID_STYLE_KEYS","GRID_STYLE","undefined","includes","Tags","AxisLine","width","color","prototype","AxisTick","size","count","AxisLabel","fontStyle","fontWeight","fontSize","fontFamily","padding","rotation","autoRotate","autoRotateAngle","mirrored","parallel","formatter","format","Axis","scale","id","nice","dataDomain","axisGroup","name","layer","zIndex","AXIS_ZINDEX","crossLineGroup","lineGroup","appendChild","tickGroup","titleGroup","tickGroupSelection","select","selectAll","lineNode","gridlineGroup","AXIS_GRIDLINES_ZINDEX","gridlineGroupSelection","_crossLines","line","tick","label","translation","x","y","requestedRange","_visibleRange","_title","_gridLength","gridStyle","stroke","lineDash","_radialGrid","fractionDigits","gridPadding","thickness","_scale","refreshScale","get","enumerable","configurable","set","_this","_a","_b","forEach","crossLine","detachCrossLine","attachCrossLine","initCrossLine","group","removeChild","getMeta","range","slice","crossLines","updateRange","rr","vr","visibleRange","span","shift","start","clippedRange","inRange","tolerance","inRangeEx","min","Math","max","onLabelFormatChange","ticks","tickFormat","labelFormatter","specifier","console","warn","oldTitle","node","PI","updateTitle","remove","setData","update","primaryTickCount","calculateDomain","_c","gridLength","requestedRangeMin","apply","requestedRangeMax","parallelLabels","anySeriesActive","isAnySeriesActive","sideFlag","parallelFlipRotation","regularFlipRotation","halfBandwidth","bandwidth","updatePosition","updateLine","labelOverlap","defaultTickCount","tickCount","continuous","secondaryAxis","calculatePrimaryDomain","domain","unchanged","_loop_1","this_1","prevTicks","filteredTicks","filter","_","secondaryAxisTicks","updateSecondaryAxisTicks","updateSelections","every","t","state_1","_d","updateLabels","tickLineGroupSelection","labelData","rotated","labelPadding","updateGridLines","anyTickVisible","visibleFn","floor","ceil","visible","translationY","_e","attrFn","direction","X","Y","selectByTag","Tick","each","strokeWidth","attr","translationX","GridLine","x1","x2","y1","y2","_primaryTickCount","Error","updateTickGroupSelection","data","updateAxis","exit","enterAxis","enter","append","tag","merge","updateGridLineGroupSelection","updateGridlines","tagFn","enterGridline","radialGrid","map","convert","datum","round","styleCount_1","gridLines","angularGridLength_1","arc","radius","centerX","centerY","endAngle","radiusX","radiusY","abs","parent","gridLine","index","style","fill","labelAutoRotation","labelRotation","parallelFlipFlag","regularFlipFlag","labelBboxes","Map","labelCount","halfFirstLabelLength","halfLastLabelLength","availableRange","labelSelection","selectByClass","text","formatTickDatum","userHidden","computeBBox","labelX","step","rotateLabels","bboxes","e_1","rotate","lastIdx","entries","bbox","divideBy","length_1","height","lengthWithPadding","e_1_1","return","autoRotation","labelTextBaseline","alignFlag","labelTextAlign","combinedRotation","labelRotationMatrix","updateTransformMatrix","textBaseline","textAlign","rotationCenterX","translatedBBox","transformBBox","point","title","titleVisible","enabled","PADDING","titleNode","titleRotationFlag","lineBBox","bboxYDimension","tickBBox","tickWidth","Infinity","meta","String","axis","toFixed","formatDatum"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/axis.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { Group } from './scene/group';\nimport { Selection } from './scene/selection';\nimport { Line } from './scene/shape/line';\nimport { Text } from './scene/shape/text';\nimport { Arc } from './scene/shape/arc';\nimport { BBox } from './scene/bbox';\nimport { Caption } from './caption';\nimport { createId } from './util/id';\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from './util/angle';\nimport { doOnce } from './util/function';\nimport { TimeInterval } from './util/time/interval';\nimport { Validate, BOOLEAN, OPT_BOOLEAN, NUMBER, OPT_NUMBER, OPT_FONT_STYLE, OPT_FONT_WEIGHT, STRING, OPT_COLOR_STRING, OPTIONAL, ARRAY, predicateWithMessage, OPT_STRING, } from './util/validation';\nimport { ChartAxisDirection } from './chart/chartAxis';\nimport { Layers } from './chart/layers';\nimport { axisLabelsOverlap } from './util/labelPlacement';\nimport { ContinuousScale } from './scale/continuousScale';\nimport { Matrix } from './scene/matrix';\nvar TICK_COUNT = predicateWithMessage(function (v, ctx) { return NUMBER(0)(v, ctx) || v instanceof TimeInterval; }, \"expecting a tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'\");\nvar OPT_TICK_COUNT = predicateWithMessage(function (v, ctx) { return OPTIONAL(v, ctx, TICK_COUNT); }, \"expecting an optional tick count Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'\");\nvar GRID_STYLE_KEYS = ['stroke', 'lineDash'];\nvar GRID_STYLE = predicateWithMessage(ARRAY(undefined, function (o) {\n    for (var key in o) {\n        if (!GRID_STYLE_KEYS.includes(key)) {\n            return false;\n        }\n    }\n    return true;\n}), \"expecting an Array of objects with gridline style properties such as 'stroke' and 'lineDash'\");\nvar Tags;\n(function (Tags) {\n    Tags[Tags[\"Tick\"] = 0] = \"Tick\";\n    Tags[Tags[\"GridLine\"] = 1] = \"GridLine\";\n})(Tags || (Tags = {}));\nvar AxisLine = /** @class */ (function () {\n    function AxisLine() {\n        this.width = 1;\n        this.color = 'rgba(195, 195, 195, 1)';\n    }\n    __decorate([\n        Validate(NUMBER(0))\n    ], AxisLine.prototype, \"width\", void 0);\n    __decorate([\n        Validate(OPT_COLOR_STRING)\n    ], AxisLine.prototype, \"color\", void 0);\n    return AxisLine;\n}());\nexport { AxisLine };\nvar AxisTick = /** @class */ (function () {\n    function AxisTick() {\n        /**\n         * The line width to be used by axis ticks.\n         */\n        this.width = 1;\n        /**\n         * The line length to be used by axis ticks.\n         */\n        this.size = 6;\n        /**\n         * The color of the axis ticks.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n         */\n        this.color = 'rgba(195, 195, 195, 1)';\n        /**\n         * A hint of how many ticks to use (the exact number of ticks might differ),\n         * a `TimeInterval` or a `CountableTimeInterval`.\n         * For example:\n         *\n         *     axis.tick.count = 5;\n         *     axis.tick.count = year;\n         *     axis.tick.count = month.every(6);\n         */\n        this.count = undefined;\n    }\n    __decorate([\n        Validate(NUMBER(0))\n    ], AxisTick.prototype, \"width\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], AxisTick.prototype, \"size\", void 0);\n    __decorate([\n        Validate(OPT_COLOR_STRING)\n    ], AxisTick.prototype, \"color\", void 0);\n    __decorate([\n        Validate(OPT_TICK_COUNT)\n    ], AxisTick.prototype, \"count\", void 0);\n    return AxisTick;\n}());\nexport { AxisTick };\nvar AxisLabel = /** @class */ (function () {\n    function AxisLabel() {\n        this.fontStyle = undefined;\n        this.fontWeight = undefined;\n        this.fontSize = 12;\n        this.fontFamily = 'Verdana, sans-serif';\n        /**\n         * The padding between the labels and the ticks.\n         */\n        this.padding = 5;\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        this.color = 'rgba(87, 87, 87, 1)';\n        /**\n         * Custom label rotation in degrees.\n         * Labels are rendered perpendicular to the axis line by default.\n         * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n         * The value of this config is used as the angular offset/deflection\n         * from the default rotation.\n         */\n        this.rotation = undefined;\n        /**\n         * If specified and axis labels may collide, they are rotated to reduce collisions. If the\n         * `rotation` property is specified, it takes precedence.\n         */\n        this.autoRotate = undefined;\n        /**\n         * Rotation angle to use when autoRotate is applied.\n         */\n        this.autoRotateAngle = 335;\n        /**\n         * By default labels and ticks are positioned to the left of the axis line.\n         * `true` positions the labels to the right of the axis line.\n         * However, if the axis is rotated, it's easier to think in terms\n         * of this side or the opposite side, rather than left and right.\n         * We use the term `mirror` for conciseness, although it's not\n         * true mirroring - for example, when a label is rotated, so that\n         * it is inclined at the 45 degree angle, text flowing from north-west\n         * to south-east, ending at the tick to the left of the axis line,\n         * and then we set this config to `true`, the text will still be flowing\n         * from north-west to south-east, _starting_ at the tick to the right\n         * of the axis line.\n         */\n        this.mirrored = false;\n        /**\n         * Labels are rendered perpendicular to the axis line by default.\n         * Setting this config to `true` makes labels render parallel to the axis line\n         * and center aligns labels' text at the ticks.\n         */\n        this.parallel = false;\n        /**\n         * In case {@param value} is a number, the {@param fractionDigits} parameter will\n         * be provided as well. The `fractionDigits` corresponds to the number of fraction\n         * digits used by the tick step. For example, if the tick step is `0.0005`,\n         * the `fractionDigits` is 4.\n         */\n        this.formatter = undefined;\n        this.format = undefined;\n    }\n    __decorate([\n        Validate(OPT_FONT_STYLE)\n    ], AxisLabel.prototype, \"fontStyle\", void 0);\n    __decorate([\n        Validate(OPT_FONT_WEIGHT)\n    ], AxisLabel.prototype, \"fontWeight\", void 0);\n    __decorate([\n        Validate(NUMBER(1))\n    ], AxisLabel.prototype, \"fontSize\", void 0);\n    __decorate([\n        Validate(STRING)\n    ], AxisLabel.prototype, \"fontFamily\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], AxisLabel.prototype, \"padding\", void 0);\n    __decorate([\n        Validate(OPT_COLOR_STRING)\n    ], AxisLabel.prototype, \"color\", void 0);\n    __decorate([\n        Validate(OPT_NUMBER(-360, 360))\n    ], AxisLabel.prototype, \"rotation\", void 0);\n    __decorate([\n        Validate(OPT_BOOLEAN)\n    ], AxisLabel.prototype, \"autoRotate\", void 0);\n    __decorate([\n        Validate(NUMBER(-360, 360))\n    ], AxisLabel.prototype, \"autoRotateAngle\", void 0);\n    __decorate([\n        Validate(BOOLEAN)\n    ], AxisLabel.prototype, \"mirrored\", void 0);\n    __decorate([\n        Validate(BOOLEAN)\n    ], AxisLabel.prototype, \"parallel\", void 0);\n    __decorate([\n        Validate(OPT_STRING)\n    ], AxisLabel.prototype, \"format\", void 0);\n    return AxisLabel;\n}());\nexport { AxisLabel };\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nvar Axis = /** @class */ (function () {\n    function Axis(scale) {\n        this.id = createId(this);\n        this.nice = true;\n        this.dataDomain = [];\n        this.axisGroup = new Group({ name: this.id + \"-axis\", layer: true, zIndex: Layers.AXIS_ZINDEX });\n        this.crossLineGroup = new Group({ name: this.id + \"-CrossLines\" });\n        this.lineGroup = this.axisGroup.appendChild(new Group({ name: this.id + \"-Line\" }));\n        this.tickGroup = this.axisGroup.appendChild(new Group({ name: this.id + \"-Tick\" }));\n        this.titleGroup = this.axisGroup.appendChild(new Group({ name: this.id + \"-Title\" }));\n        this.tickGroupSelection = Selection.select(this.tickGroup).selectAll();\n        this.lineNode = this.lineGroup.appendChild(new Line());\n        this.gridlineGroup = new Group({\n            name: this.id + \"-gridline\",\n            layer: true,\n            zIndex: Layers.AXIS_GRIDLINES_ZINDEX,\n        });\n        this.gridlineGroupSelection = Selection.select(this.gridlineGroup).selectAll();\n        this._crossLines = [];\n        this.line = new AxisLine();\n        this.tick = new AxisTick();\n        this.label = new AxisLabel();\n        this.translation = { x: 0, y: 0 };\n        this.rotation = 0; // axis rotation angle in degrees\n        this.requestedRange = [0, 1];\n        this._visibleRange = [0, 1];\n        this._title = undefined;\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n         * (in degrees).\n         */\n        this._gridLength = 0;\n        /**\n         * The array of styles to cycle through when rendering grid lines.\n         * For example, use two {@link GridStyle} objects for alternating styles.\n         * Contains only one {@link GridStyle} object by default, meaning all grid lines\n         * have the same style.\n         */\n        this.gridStyle = [\n            {\n                stroke: 'rgba(219, 219, 219, 1)',\n                lineDash: [4, 2],\n            },\n        ];\n        /**\n         * `false` - render grid as lines of {@link gridLength} that extend the ticks\n         *           on the opposite side of the axis\n         * `true` - render grid as concentric circles that go through the ticks\n         */\n        this._radialGrid = false;\n        this.fractionDigits = 0;\n        /**\n         * The distance between the grid ticks and the axis ticks.\n         */\n        this.gridPadding = 0;\n        this.thickness = 0;\n        this._scale = scale;\n        this.refreshScale();\n    }\n    Object.defineProperty(Axis.prototype, \"scale\", {\n        get: function () {\n            return this._scale;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"crossLines\", {\n        get: function () {\n            return this._crossLines;\n        },\n        set: function (value) {\n            var _this = this;\n            var _a, _b;\n            (_a = this._crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) { return _this.detachCrossLine(crossLine); });\n            this._crossLines = value;\n            (_b = this._crossLines) === null || _b === void 0 ? void 0 : _b.forEach(function (crossLine) {\n                _this.attachCrossLine(crossLine);\n                _this.initCrossLine(crossLine);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Axis.prototype.attachCrossLine = function (crossLine) {\n        this.crossLineGroup.appendChild(crossLine.group);\n    };\n    Axis.prototype.detachCrossLine = function (crossLine) {\n        this.crossLineGroup.removeChild(crossLine.group);\n    };\n    /**\n     * Meant to be overridden in subclasses to provide extra context the the label formatter.\n     * The return value of this function will be passed to the laber.formatter as the `axis` parameter.\n     */\n    Axis.prototype.getMeta = function () {\n        // Override point for subclasses.\n    };\n    Axis.prototype.refreshScale = function () {\n        var _this = this;\n        var _a;\n        this.requestedRange = this.scale.range.slice();\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) {\n            _this.initCrossLine(crossLine);\n        });\n    };\n    Axis.prototype.updateRange = function () {\n        var _a;\n        var _b = this, rr = _b.requestedRange, vr = _b.visibleRange, scale = _b.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        scale.range = [start, start + span];\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) {\n            crossLine.clippedRange = [rr[0], rr[1]];\n        });\n    };\n    /**\n     * Checks if a point or an object is in range.\n     * @param x A point (or object's starting point).\n     * @param width Object's width.\n     * @param tolerance Expands the range on both ends by this amount.\n     */\n    Axis.prototype.inRange = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        return this.inRangeEx(x, width, tolerance) === 0;\n    };\n    Axis.prototype.inRangeEx = function (x, width, tolerance) {\n        if (width === void 0) { width = 0; }\n        if (tolerance === void 0) { tolerance = 0; }\n        var range = this.range;\n        // Account for inverted ranges, for example [500, 100] as well as [100, 500]\n        var min = Math.min(range[0], range[1]);\n        var max = Math.max(range[0], range[1]);\n        if (x + width < min - tolerance) {\n            return -1; // left of range\n        }\n        if (x > max + tolerance) {\n            return 1; // right of range\n        }\n        return 0; // in range\n    };\n    Object.defineProperty(Axis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange;\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"visibleRange\", {\n        get: function () {\n            return this._visibleRange.slice();\n        },\n        set: function (value) {\n            if (value && value.length === 2) {\n                var _a = __read(value, 2), min = _a[0], max = _a[1];\n                min = Math.max(0, min);\n                max = Math.min(1, max);\n                min = Math.min(min, max);\n                max = Math.max(min, max);\n                this._visibleRange = [min, max];\n                this.updateRange();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Axis.prototype.onLabelFormatChange = function (ticks, format) {\n        var scale = this.scale;\n        if (format && scale && scale.tickFormat) {\n            try {\n                this.labelFormatter = scale.tickFormat({\n                    ticks: ticks,\n                    count: ticks.length,\n                    specifier: format,\n                });\n            }\n            catch (e) {\n                this.labelFormatter = undefined;\n                doOnce(function () {\n                    return console.warn(\"AG Charts - the axis label format string \" + format + \" is invalid. No formatting will be applied\");\n                }, \"invalid axis label format string \" + format);\n            }\n        }\n        else {\n            this.labelFormatter = undefined;\n        }\n    };\n    Object.defineProperty(Axis.prototype, \"title\", {\n        get: function () {\n            return this._title;\n        },\n        set: function (value) {\n            var oldTitle = this._title;\n            if (oldTitle !== value) {\n                if (oldTitle) {\n                    this.titleGroup.removeChild(oldTitle.node);\n                }\n                if (value) {\n                    value.node.rotation = -Math.PI / 2;\n                    this.titleGroup.appendChild(value.node);\n                }\n                this._title = value;\n                // position title so that it doesn't briefly get rendered in the top left hand corner of the canvas before update is called.\n                this.updateTitle({ ticks: this.scale.ticks(this.tick.count) });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        set: function (value) {\n            var _this = this;\n            var _a;\n            // Was visible and now invisible, or was invisible and now visible.\n            if ((this._gridLength && !value) || (!this._gridLength && value)) {\n                this.gridlineGroupSelection = this.gridlineGroupSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n            (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(function (crossLine) {\n                _this.initCrossLine(crossLine);\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Axis.prototype, \"radialGrid\", {\n        get: function () {\n            return this._radialGrid;\n        },\n        set: function (value) {\n            if (this._radialGrid !== value) {\n                this._radialGrid = value;\n                this.gridlineGroupSelection = this.gridlineGroupSelection.remove().setData([]);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     */\n    Axis.prototype.update = function (primaryTickCount) {\n        var _a, _b;\n        this.calculateDomain();\n        var _c = this, scale = _c.scale, gridLength = _c.gridLength, tick = _c.tick, label = _c.label, requestedRange = _c.requestedRange;\n        var requestedRangeMin = Math.min.apply(Math, __spread(requestedRange));\n        var requestedRangeMax = Math.max.apply(Math, __spread(requestedRange));\n        var rotation = toRadians(this.rotation);\n        var parallelLabels = label.parallel;\n        var anySeriesActive = this.isAnySeriesActive();\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, π] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        var halfBandwidth = (scale.bandwidth || 0) / 2;\n        this.updatePosition();\n        this.updateLine();\n        var i = 0;\n        var labelOverlap = true;\n        var ticks = [];\n        var defaultTickCount = 10;\n        var tickCount = this.tick.count !== undefined;\n        var nice = this.nice && scale.nice;\n        var continuous = scale instanceof ContinuousScale;\n        var secondaryAxis = primaryTickCount !== undefined;\n        var calculatePrimaryDomain = !secondaryAxis && !tickCount && nice;\n        scale.domain = this.dataDomain;\n        if (nice) {\n            scale.nice(this.tick.count);\n        }\n        while (labelOverlap) {\n            var unchanged = true;\n            var _loop_1 = function () {\n                if (i >= defaultTickCount) {\n                    return \"break\";\n                }\n                if (calculatePrimaryDomain) {\n                    // `scale.nice` mutates `scale.domain` based on new tick count\n                    scale.domain = this_1.dataDomain;\n                    scale.nice(defaultTickCount - i);\n                }\n                var prevTicks = ticks;\n                // filter generated ticks if this is a category axis or this.tick.count is specified\n                var filteredTicks = (continuous && !tickCount) || i === 0 ? undefined : ticks.filter(function (_, i) { return i % 2 === 0; });\n                var secondaryAxisTicks = void 0;\n                if (secondaryAxis) {\n                    // `updateSecondaryAxisTicks` mutates `scale.domain` based on `primaryTickCount`\n                    secondaryAxisTicks = this_1.updateSecondaryAxisTicks(primaryTickCount);\n                }\n                ticks = (_a = (filteredTicks !== null && filteredTicks !== void 0 ? filteredTicks : secondaryAxisTicks), (_a !== null && _a !== void 0 ? _a : this_1.scale.ticks(this_1.tick.count, i)));\n                this_1.updateSelections({\n                    halfBandwidth: halfBandwidth,\n                    gridLength: gridLength,\n                    ticks: ticks,\n                });\n                if (!secondaryAxis && ticks.length > 0) {\n                    primaryTickCount = ticks.length;\n                }\n                unchanged = ticks.every(function (t, i) { return t === prevTicks[i]; });\n                i++;\n            };\n            var this_1 = this;\n            while (unchanged) {\n                var state_1 = _loop_1();\n                if (state_1 === \"break\")\n                    break;\n            }\n            if (unchanged) {\n                break;\n            }\n            // When the scale domain or the ticks change, the label format may change\n            this.onLabelFormatChange(ticks, this.label.format);\n            var _d = this.updateLabels({\n                parallelFlipRotation: parallelFlipRotation,\n                regularFlipRotation: regularFlipRotation,\n                sideFlag: sideFlag,\n                tickLineGroupSelection: this.tickGroupSelection,\n                ticks: ticks,\n            }), labelData = _d.labelData, rotated = _d.rotated;\n            var labelPadding = rotated ? 0 : 10;\n            labelOverlap = axisLabelsOverlap(labelData, labelPadding);\n        }\n        this.updateGridLines({\n            gridLength: gridLength,\n            halfBandwidth: halfBandwidth,\n            sideFlag: sideFlag,\n        });\n        var anyTickVisible = false;\n        var visibleFn = function (node) {\n            var min = Math.floor(requestedRangeMin);\n            var max = Math.ceil(requestedRangeMax);\n            var visible = min !== max && node.translationY >= min && node.translationY <= max;\n            anyTickVisible = visible || anyTickVisible;\n            return visible;\n        };\n        var _e = this, gridlineGroupSelection = _e.gridlineGroupSelection, tickGroupSelection = _e.tickGroupSelection;\n        gridlineGroupSelection.attrFn('visible', visibleFn);\n        tickGroupSelection.attrFn('visible', visibleFn);\n        this.tickGroup.visible = anyTickVisible;\n        this.gridlineGroup.visible = anyTickVisible;\n        (_b = this.crossLines) === null || _b === void 0 ? void 0 : _b.forEach(function (crossLine) {\n            crossLine.sideFlag = -sideFlag;\n            crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\n            crossLine.label.parallel =\n                crossLine.label.parallel !== undefined ? crossLine.label.parallel : parallelLabels;\n            crossLine.parallelFlipRotation = parallelFlipRotation;\n            crossLine.regularFlipRotation = regularFlipRotation;\n            crossLine.update(anySeriesActive);\n        });\n        this.updateTitle({ ticks: ticks });\n        tickGroupSelection\n            .selectByTag(Tags.Tick)\n            .each(function (line) {\n            line.strokeWidth = tick.width;\n            line.stroke = tick.color;\n            line.visible = anyTickVisible;\n        })\n            .attr('x1', sideFlag * tick.size)\n            .attr('x2', 0)\n            .attr('y1', 0)\n            .attr('y2', 0);\n        return primaryTickCount;\n    };\n    Axis.prototype.calculateDomain = function () {\n        // Placeholder for subclasses to override.\n    };\n    Axis.prototype.updatePosition = function () {\n        var _a = this, label = _a.label, axisGroup = _a.axisGroup, gridlineGroup = _a.gridlineGroup, crossLineGroup = _a.crossLineGroup, translation = _a.translation, gridlineGroupSelection = _a.gridlineGroupSelection, gridPadding = _a.gridPadding, gridLength = _a.gridLength;\n        var rotation = toRadians(this.rotation);\n        var sideFlag = label.mirrored ? 1 : -1;\n        var translationX = Math.floor(translation.x);\n        var translationY = Math.floor(translation.y);\n        crossLineGroup.translationX = translationX;\n        crossLineGroup.translationY = translationY;\n        crossLineGroup.rotation = rotation;\n        axisGroup.translationX = translationX;\n        axisGroup.translationY = translationY;\n        axisGroup.rotation = rotation;\n        gridlineGroup.translationX = translationX;\n        gridlineGroup.translationY = translationY;\n        gridlineGroup.rotation = rotation;\n        gridlineGroupSelection.selectByTag(Tags.GridLine).each(function (line) {\n            line.x1 = gridPadding;\n            line.x2 = -sideFlag * gridLength + gridPadding;\n            line.y1 = 0;\n            line.y2 = 0;\n        });\n    };\n    Axis.prototype.updateSecondaryAxisTicks = function (_primaryTickCount) {\n        throw new Error('AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.');\n    };\n    Axis.prototype.updateTickGroupSelection = function (_a) {\n        var data = _a.data;\n        var updateAxis = this.tickGroupSelection.setData(data);\n        updateAxis.exit.remove();\n        var enterAxis = updateAxis.enter.append(Group);\n        // Line auto-snaps to pixel grid if vertical or horizontal.\n        enterAxis.append(Line).each(function (node) { return (node.tag = Tags.Tick); });\n        enterAxis.append(Text);\n        return updateAxis.merge(enterAxis);\n    };\n    Axis.prototype.updateGridLineGroupSelection = function (_a) {\n        var gridLength = _a.gridLength, data = _a.data;\n        var updateGridlines = this.gridlineGroupSelection.setData(gridLength ? data : []);\n        updateGridlines.exit.remove();\n        var gridlineGroupSelection = updateGridlines;\n        if (gridLength) {\n            var tagFn = function (node) { return (node.tag = Tags.GridLine); };\n            var enterGridline = updateGridlines.enter.append(Group);\n            if (this.radialGrid) {\n                enterGridline.append(Arc).each(tagFn);\n            }\n            else {\n                enterGridline.append(Line).each(tagFn);\n            }\n            gridlineGroupSelection = updateGridlines.merge(enterGridline);\n        }\n        return gridlineGroupSelection;\n    };\n    Axis.prototype.updateSelections = function (_a) {\n        var ticks = _a.ticks, halfBandwidth = _a.halfBandwidth, gridLength = _a.gridLength;\n        var scale = this.scale;\n        var data = ticks.map(function (t) { return ({ tick: t, translationY: scale.convert(t) + halfBandwidth }); });\n        var gridlineGroupSelection = this.updateGridLineGroupSelection({ gridLength: gridLength, data: data });\n        var tickGroupSelection = this.updateTickGroupSelection({ data: data });\n        // We need raw `translationY` values on `datum` for accurate label collision detection in axes.update()\n        // But node `translationY` values must be rounded to get pixel grid alignment\n        gridlineGroupSelection.attrFn('translationY', function (_, datum) { return Math.round(datum.translationY); });\n        tickGroupSelection.attrFn('translationY', function (_, datum) { return Math.round(datum.translationY); });\n        this.tickGroupSelection = tickGroupSelection;\n        this.gridlineGroupSelection = gridlineGroupSelection;\n    };\n    Axis.prototype.updateGridLines = function (_a) {\n        var gridLength = _a.gridLength, halfBandwidth = _a.halfBandwidth, sideFlag = _a.sideFlag;\n        var _b = this, gridStyle = _b.gridStyle, scale = _b.scale, tick = _b.tick, gridPadding = _b.gridPadding;\n        if (gridLength && gridStyle.length) {\n            var styleCount_1 = gridStyle.length;\n            var gridLines = void 0;\n            if (this.radialGrid) {\n                var angularGridLength_1 = normalizeAngle360Inclusive(toRadians(gridLength));\n                gridLines = this.gridlineGroupSelection.selectByTag(Tags.GridLine).each(function (arc, datum) {\n                    var radius = Math.round(scale.convert(datum) + halfBandwidth);\n                    arc.centerX = 0;\n                    arc.centerY = scale.range[0] - radius;\n                    arc.endAngle = angularGridLength_1;\n                    arc.radiusX = radius;\n                    arc.radiusY = radius;\n                });\n            }\n            else {\n                gridLines = this.gridlineGroupSelection.selectByTag(Tags.GridLine).each(function (line) {\n                    line.x1 = gridPadding;\n                    line.x2 = -sideFlag * gridLength + gridPadding;\n                    line.y1 = 0;\n                    line.y2 = 0;\n                    line.visible = Math.abs(line.parent.translationY - scale.range[0]) > 1;\n                });\n            }\n            gridLines.each(function (gridLine, _, index) {\n                var style = gridStyle[index % styleCount_1];\n                gridLine.stroke = style.stroke;\n                gridLine.strokeWidth = tick.width;\n                gridLine.lineDash = style.lineDash;\n                gridLine.fill = undefined;\n            });\n        }\n    };\n    Axis.prototype.updateLabels = function (_a) {\n        var _this = this;\n        var ticks = _a.ticks, tickLineGroupSelection = _a.tickLineGroupSelection, sideFlag = _a.sideFlag, parallelFlipRotation = _a.parallelFlipRotation, regularFlipRotation = _a.regularFlipRotation;\n        var _b = this, label = _b.label, parallelLabels = _b.label.parallel, scale = _b.scale, tick = _b.tick, requestedRange = _b.requestedRange;\n        var requestedRangeMin = Math.min.apply(Math, __spread(requestedRange));\n        var requestedRangeMax = Math.max.apply(Math, __spread(requestedRange));\n        var labelAutoRotation = 0;\n        var labelRotation = label.rotation ? normalizeAngle360(toRadians(label.rotation)) : 0;\n        var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n        this.fractionDigits = ticks.fractionDigits >= 0 ? ticks.fractionDigits : 0;\n        // Update properties that affect the size of the axis labels and measure the labels\n        var labelBboxes = new Map();\n        var labelCount = 0;\n        var halfFirstLabelLength = false;\n        var halfLastLabelLength = false;\n        var availableRange = requestedRangeMax - requestedRangeMin;\n        var labelSelection = tickLineGroupSelection.selectByClass(Text).each(function (node, datum, index) {\n            var tick = datum.tick;\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.text = _this.formatTickDatum(tick, index);\n            var userHidden = node.text === '' || node.text == undefined;\n            labelBboxes.set(index, userHidden ? null : node.computeBBox());\n            if (userHidden) {\n                return;\n            }\n            labelCount++;\n            if (index === 0 && node.translationY === scale.range[0]) {\n                halfFirstLabelLength = true; // first label protrudes axis line\n            }\n            else if (index === ticks.length - 1 && node.translationY === scale.range[1]) {\n                halfLastLabelLength = true; // last label protrudes axis line\n            }\n        });\n        var labelX = sideFlag * (tick.size + label.padding);\n        var step = availableRange / labelCount;\n        var rotateLabels = function (bboxes, parallelLabels) {\n            var e_1, _a;\n            var rotate = false;\n            var lastIdx = bboxes.size - 1;\n            var padding = 12;\n            try {\n                for (var _b = __values(bboxes.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var _d = __read(_c.value, 2), i = _d[0], bbox = _d[1];\n                    if (bbox == null) {\n                        continue;\n                    }\n                    var divideBy = (i === 0 && halfFirstLabelLength) || (i === lastIdx && halfLastLabelLength) ? 2 : 1;\n                    // When the labels are parallel to the axis line, use the width of the text to calculate the total length of all labels\n                    var length_1 = parallelLabels ? bbox.width / divideBy : bbox.height / divideBy;\n                    var lengthWithPadding = length_1 <= 0 ? 0 : length_1 + padding;\n                    if (lengthWithPadding > step) {\n                        rotate = true;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return rotate;\n        };\n        var rotate = rotateLabels(labelBboxes, parallelLabels);\n        if (label.rotation === undefined && label.autoRotate === true && rotate) {\n            // When no user label rotation angle has been specified and the width of any label exceeds the average tick gap (`rotate` is `true`),\n            // automatically rotate the labels\n            labelAutoRotation = normalizeAngle360(toRadians(label.autoRotateAngle));\n        }\n        var autoRotation = parallelLabels ? (parallelFlipFlag * Math.PI) / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n        var labelTextBaseline = parallelLabels && !labelRotation ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom') : 'middle';\n        var alignFlag = (labelRotation > 0 && labelRotation <= Math.PI) || (labelAutoRotation > 0 && labelAutoRotation <= Math.PI)\n            ? -1\n            : 1;\n        var labelTextAlign = parallelLabels\n            ? labelRotation || labelAutoRotation\n                ? sideFlag * alignFlag === -1\n                    ? 'end'\n                    : 'start'\n                : 'center'\n            : sideFlag * regularFlipFlag === -1\n                ? 'end'\n                : 'start';\n        var labelData = [];\n        var combinedRotation = autoRotation + labelRotation + labelAutoRotation;\n        var labelRotationMatrix = new Matrix();\n        if (combinedRotation) {\n            Matrix.updateTransformMatrix(labelRotationMatrix, 1, 1, combinedRotation, 0, 0);\n        }\n        labelSelection.each(function (label, datum) {\n            if (label.text === '' || label.text == undefined) {\n                label.visible = false; // hide empty labels\n                return;\n            }\n            label.textBaseline = labelTextBaseline;\n            label.textAlign = labelTextAlign;\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            label.rotation = combinedRotation;\n            var userHidden = label.text === '' || label.text == undefined;\n            if (userHidden) {\n                return;\n            }\n            // Text.computeBBox() does not take into account any of the transformations that have been applied to the label nodes, only the width and height are useful.\n            // Rather than taking into account all transformations including those of parent nodes which would be the result of `computeTransformedBBox()`, giving the x and y in the entire axis coordinate space,\n            // take into account only the rotation and translation applied to individual label nodes to get the x y coordinates of the labels relative to each other\n            // this makes label collision detection a lot simpler\n            var bbox = label.computeBBox();\n            var _a = bbox.width, width = _a === void 0 ? 0 : _a, _b = bbox.height, height = _b === void 0 ? 0 : _b;\n            var translationY = datum.translationY;\n            var translatedBBox = new BBox(labelX, translationY, 0, 0);\n            labelRotationMatrix.transformBBox(translatedBBox, 0, bbox);\n            var _c = bbox.x, x = _c === void 0 ? 0 : _c, _d = bbox.y, y = _d === void 0 ? 0 : _d;\n            labelData.push({\n                point: {\n                    x: x,\n                    y: y,\n                    size: 0,\n                },\n                label: {\n                    width: width,\n                    height: height,\n                    text: label.text,\n                },\n            });\n        });\n        return { labelData: labelData, rotated: !!(labelRotation || labelAutoRotation) };\n    };\n    Axis.prototype.updateLine = function () {\n        // Render axis line.\n        var _a = this, lineNode = _a.lineNode, requestedRange = _a.requestedRange;\n        lineNode.x1 = 0;\n        lineNode.x2 = 0;\n        lineNode.y1 = requestedRange[0];\n        lineNode.y2 = requestedRange[1];\n        lineNode.strokeWidth = this.line.width;\n        lineNode.stroke = this.line.color;\n        lineNode.visible = true;\n    };\n    Axis.prototype.updateTitle = function (_a) {\n        var ticks = _a.ticks;\n        var _b;\n        var _c = this, label = _c.label, rotation = _c.rotation, title = _c.title, lineNode = _c.lineNode, requestedRange = _c.requestedRange, tickGroup = _c.tickGroup, lineGroup = _c.lineGroup;\n        if (!title) {\n            return;\n        }\n        var titleVisible = false;\n        if (title.enabled && lineNode.visible) {\n            titleVisible = true;\n            var sideFlag = label.mirrored ? 1 : -1;\n            var parallelFlipRotation = normalizeAngle360(rotation);\n            var padding = Caption.PADDING;\n            var titleNode = title.node;\n            var titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n            titleNode.rotation = (titleRotationFlag * sideFlag * Math.PI) / 2;\n            titleNode.x = Math.floor((titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1])) / 2);\n            var lineBBox = lineGroup.computeBBox();\n            var bboxYDimension = rotation === 0 ? lineBBox.width : lineBBox.height;\n            if (((_b = ticks) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                var tickBBox = tickGroup.computeBBox();\n                var tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\n                if (Math.abs(tickWidth) < Infinity) {\n                    bboxYDimension += tickWidth;\n                }\n            }\n            if (sideFlag === -1) {\n                titleNode.y = Math.floor(titleRotationFlag * (-padding - bboxYDimension));\n            }\n            else {\n                titleNode.y = Math.floor(-padding - bboxYDimension);\n            }\n            titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n        }\n        title.node.visible = titleVisible;\n    };\n    // For formatting (nice rounded) tick values.\n    Axis.prototype.formatTickDatum = function (datum, index) {\n        var _a = this, label = _a.label, labelFormatter = _a.labelFormatter, fractionDigits = _a.fractionDigits;\n        var meta = this.getMeta();\n        return label.formatter\n            ? label.formatter({\n                value: fractionDigits >= 0 ? datum : String(datum),\n                index: index,\n                fractionDigits: fractionDigits,\n                formatter: labelFormatter,\n                axis: meta,\n            })\n            : labelFormatter\n                ? labelFormatter(datum)\n                : typeof datum === 'number' && fractionDigits >= 0\n                    ? // the `datum` is a floating point number\n                        datum.toFixed(fractionDigits)\n                    : // the`datum` is an integer, a string or an object\n                        String(datum);\n    };\n    // For formatting arbitrary values between the ticks.\n    Axis.prototype.formatDatum = function (datum) {\n        return String(datum);\n    };\n    Axis.prototype.computeBBox = function () {\n        return this.axisGroup.computeBBox();\n    };\n    Axis.prototype.initCrossLine = function (crossLine) {\n        crossLine.scale = this.scale;\n        crossLine.gridLength = this.gridLength;\n    };\n    Axis.prototype.isAnySeriesActive = function () {\n        return false;\n    };\n    __decorate([\n        Validate(BOOLEAN)\n    ], Axis.prototype, \"nice\", void 0);\n    __decorate([\n        Validate(GRID_STYLE)\n    ], Axis.prototype, \"gridStyle\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], Axis.prototype, \"thickness\", void 0);\n    return Axis;\n}());\nexport { Axis };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}