{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\nvar util_1 = require(\"zrender/lib/core/util\");\nvar task_1 = require(\"./task\");\nvar component_1 = require(\"../util/component\");\nvar Global_1 = require(\"../model/Global\");\nvar ExtensionAPI_1 = require(\"../ExtensionAPI\");\nvar model_1 = require(\"../util/model\");\n;\nvar Scheduler = function () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    this._stageTaskMap = util_1.createHashMap();\n    this.ecInstance = ecInstance;\n    this.api = api;\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    ecModel.restoreData(payload);\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  };\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    if (!task.__pipeline) {\n      return;\n    }\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n    var data = seriesModel.getData();\n    var dataLen = data.count();\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = util_1.createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    util_1.each(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n      }\n      util_1.assert(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n    this._pipe(model, renderTask);\n  };\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    util_1.each(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n          var performArgs = scheduler.getPerformArgs(task, opt.block);\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n    this.unfinished = unfinished || this.unfinished;\n  };\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n  Scheduler.prototype.plan = function () {\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || task_1.createTask({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || task_1.createTask({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap;\n    var newAgentStubMap = overallTask.agentStubMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false;\n    var errMsg = '';\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n    }\n    util_1.assert(!stageHandler.createOnAllSeries, errMsg);\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    } else {\n      overallProgress = false;\n      util_1.each(ecModel.getSeries(), createStub);\n    }\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, task_1.createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n      scheduler._pipe(seriesModel, stub);\n    }\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n    var pipeline = this._pipelineMap.get(pipelineId);\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if (util_1.isFunction(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n    stageHandler.uid = component_1.getUID('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n  ;\n  return Scheduler;\n}();\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n  var resetDefines = context.resetDefines = model_1.normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? util_1.map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n  try {\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n  return seriesType;\n}\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, Global_1[\"default\"]);\nmockMethods(apiMock, ExtensionAPI_1[\"default\"]);\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\nfunction mockMethods(target, Clz) {\n  for (var name_1 in Clz.prototype) {\n    target[name_1] = util_1.noop;\n  }\n}\nexports[\"default\"] = Scheduler;","map":{"version":3,"names":["exports","__esModule","util_1","require","task_1","component_1","Global_1","ExtensionAPI_1","model_1","Scheduler","ecInstance","api","dataProcessorHandlers","visualHandlers","_stageTaskMap","createHashMap","_dataProcessorHandlers","slice","_visualHandlers","_allHandlers","concat","prototype","restoreData","ecModel","payload","each","taskRecord","overallTask","dirty","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","incremental","progressiveEnabled","progressiveRender","__idxInPipeline","blockIndex","step","modDataCount","modBy","Math","ceil","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","data","getData","dataLen","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","round","_pipe","dataTask","prepareStageTasks","stageTaskMap","getModel","handler","record","errMsg","process","env","NODE_ENV","assert","reset","overallReset","_createSeriesStageTask","_createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","_performStageTasks","block","performVisualTasks","opt","stageHandlers","unfinished","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallNeedDirty_1","agentStubMap","stub","needSetDirty","updatePayload","performArgs_1","perform","performArgs","skip","performRawSeries","isSeriesFiltered","setDirty","dirtyMap","performSeriesTasks","plan","getUpstream","oldSeriesTaskMap","newSeriesTaskMap","seriesType","getTargetSeries","createOnAllSeries","eachRawSeries","create","eachRawSeriesByType","createTask","seriesTaskPlan","seriesTaskReset","seriesTaskCount","useClearVisual","isVisual","isLayout","overallTaskReset","oldAgentStubMap","newAgentStubMap","overallProgress","shouldOverallTaskDirty","createStub","getSeries","stubReset","onDirty","stubOnDirty","agent","pipe","wrapStageHandler","isFunction","detectSeriseType","getUID","stubProgress","getDownstream","clearAllVisual","resetDefines","normalizeToArray","length","map","v","makeSeriesTaskProgress","singleSeriesTaskProgress","resetDefineIdx","params","resetDefine","dataEach","i","start","end","progress","legacyFunc","ecModelMock","apiMock","e","mockMethods","eachSeriesByType","type","eachComponent","cond","mainType","subType","target","Clz","name_1","noop"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/echarts/lib/stream/Scheduler.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar task_1 = require(\"./task\");\n\nvar component_1 = require(\"../util/component\");\n\nvar Global_1 = require(\"../model/Global\");\n\nvar ExtensionAPI_1 = require(\"../ExtensionAPI\");\n\nvar model_1 = require(\"../util/model\");\n\n;\n\nvar Scheduler = function () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    this._stageTaskMap = util_1.createHashMap();\n    this.ecInstance = ecInstance;\n    this.api = api;\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    ecModel.restoreData(payload);\n\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  };\n\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    if (!task.__pipeline) {\n      return;\n    }\n\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n    var data = seriesModel.getData();\n    var dataLen = data.count();\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = util_1.createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    util_1.each(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n      }\n\n      util_1.assert(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n\n    this._pipe(model, renderTask);\n  };\n\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    util_1.each(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n\n          var performArgs = scheduler.getPerformArgs(task, opt.block);\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.plan = function () {\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || task_1.createTask({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || task_1.createTask({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap;\n    var newAgentStubMap = overallTask.agentStubMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false;\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n    }\n\n    util_1.assert(!stageHandler.createOnAllSeries, errMsg);\n\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    } else {\n      overallProgress = false;\n      util_1.each(ecModel.getSeries(), createStub);\n    }\n\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, task_1.createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n\n      scheduler._pipe(seriesModel, stub);\n    }\n\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n\n    var pipeline = this._pipelineMap.get(pipelineId);\n\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if (util_1.isFunction(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n\n    stageHandler.uid = component_1.getUID('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n\n  ;\n  return Scheduler;\n}();\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = model_1.normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? util_1.map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, Global_1[\"default\"]);\nmockMethods(apiMock, ExtensionAPI_1[\"default\"]);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  for (var name_1 in Clz.prototype) {\n    target[name_1] = util_1.noop;\n  }\n}\n\nexports[\"default\"] = Scheduler;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}