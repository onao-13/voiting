{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nimport { Selection } from '../../scene/selection';\nimport { Line } from '../../scene/shape/line';\nimport { normalizeAngle360, toRadians } from '../../util/angle';\nimport { Text } from '../../scene/shape/text';\nimport { BandScale } from '../../scale/bandScale';\nimport { ticksToTree, treeLayout } from '../../layout/tree';\nimport { AxisLabel, AxisLine } from '../../axis';\nimport { ChartAxis, ChartAxisDirection } from '../chartAxis';\nimport { extent } from '../../util/array';\nimport { isContinuous } from '../../util/value';\nimport { BOOLEAN, OPT_COLOR_STRING, Validate } from '../../util/validation';\nvar GroupedCategoryAxisLabel = /** @class */function (_super) {\n  __extends(GroupedCategoryAxisLabel, _super);\n  function GroupedCategoryAxisLabel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.grid = false;\n    return _this;\n  }\n  __decorate([Validate(BOOLEAN)], GroupedCategoryAxisLabel.prototype, \"grid\", void 0);\n  return GroupedCategoryAxisLabel;\n}(AxisLabel);\nvar GroupedCategoryAxis = /** @class */function (_super) {\n  __extends(GroupedCategoryAxis, _super);\n  function GroupedCategoryAxis() {\n    var _this = _super.call(this, new BandScale()) || this;\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    _this.tickScale = new BandScale();\n    _this.translation = {\n      x: 0,\n      y: 0\n    };\n    _this.line = new AxisLine();\n    _this.label = new GroupedCategoryAxisLabel();\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n    _this.labelColor = 'rgba(87, 87, 87, 1)';\n    _this.includeInvisibleDomains = true;\n    var _a = _this,\n      axisGroup = _a.axisGroup,\n      gridlineGroup = _a.gridlineGroup,\n      tickScale = _a.tickScale,\n      scale = _a.scale;\n    scale.paddingOuter = 0.1;\n    scale.paddingInner = scale.paddingOuter * 2;\n    _this.requestedRange = scale.range.slice();\n    _this.refreshScale();\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    _this.gridLineSelection = Selection.select(gridlineGroup).selectAll();\n    _this.axisLineSelection = Selection.select(axisGroup).selectAll();\n    _this.separatorSelection = Selection.select(axisGroup).selectAll();\n    _this.labelSelection = Selection.select(axisGroup).selectAll();\n    return _this;\n  }\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n    get: function () {\n      return this.requestedRange.slice();\n    },\n    set: function (value) {\n      this.requestedRange = value.slice();\n      this.updateRange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  GroupedCategoryAxis.prototype.updateRange = function () {\n    var _a = this,\n      rr = _a.requestedRange,\n      vr = _a.visibleRange,\n      scale = _a.scale;\n    var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    var shift = span * vr[0];\n    var start = rr[0] - shift;\n    this.tickScale.range = scale.range = [start, start + span];\n    this.resizeTickTree();\n  };\n  GroupedCategoryAxis.prototype.resizeTickTree = function () {\n    var s = this.scale;\n    var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    var layout = this.tickTreeLayout;\n    var lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\n    }\n  };\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n    get: function () {\n      return this.label.fontSize * 1.5;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n    get: function () {\n      return this._gridLength;\n    },\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     */\n    set: function (value) {\n      // Was visible and now invisible, or was invisible and now visible.\n      if (this._gridLength && !value || !this._gridLength && value) {\n        this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n        this.labelSelection = this.labelSelection.remove().setData([]);\n      }\n      this._gridLength = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  GroupedCategoryAxis.prototype.calculateDomain = function () {\n    var _a;\n    var _b = this,\n      direction = _b.direction,\n      boundSeries = _b.boundSeries;\n    var domains = [];\n    var isNumericX = undefined;\n    boundSeries.filter(function (s) {\n      return s.visible;\n    }).forEach(function (series) {\n      if (direction === ChartAxisDirection.X) {\n        if (isNumericX === undefined) {\n          // always add first X domain\n          var domain_1 = series.getDomain(direction);\n          domains.push(domain_1);\n          isNumericX = typeof domain_1[0] === 'number';\n        } else if (isNumericX) {\n          // only add further X domains if the axis is numeric\n          domains.push(series.getDomain(direction));\n        }\n      } else {\n        domains.push(series.getDomain(direction));\n      }\n    });\n    var domain = (_a = new Array()).concat.apply(_a, __spread(domains));\n    var values = extent(domain, isContinuous) || domain;\n    this.dataDomain = this.normaliseDataDomain(values);\n  };\n  GroupedCategoryAxis.prototype.normaliseDataDomain = function (d) {\n    // Prevent duplicate categories.\n    var values = d.filter(function (s, i, arr) {\n      return arr.indexOf(s) === i;\n    });\n    var tickTree = ticksToTree(values);\n    this.tickTreeLayout = treeLayout(tickTree);\n    var tickScaleDomain = values.slice();\n    tickScaleDomain.push('');\n    this.tickScale.domain = tickScaleDomain;\n    this.resizeTickTree();\n    return values;\n  };\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  GroupedCategoryAxis.prototype.update = function (primaryTickCount) {\n    var _this = this;\n    this.calculateDomain();\n    var _a = this,\n      scale = _a.scale,\n      label = _a.label,\n      tickScale = _a.tickScale,\n      requestedRange = _a.requestedRange;\n    scale.domain = this.dataDomain;\n    var rangeStart = scale.range[0];\n    var rangeEnd = scale.range[1];\n    var rangeLength = Math.abs(rangeEnd - rangeStart);\n    var bandwidth = rangeLength / scale.domain.length || 0;\n    var parallelLabels = label.parallel;\n    var rotation = toRadians(this.rotation);\n    var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    var labelRotation = this.label.rotation ? normalizeAngle360(toRadians(this.label.rotation)) : 0;\n    this.updatePosition();\n    var title = this.title;\n    // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n    // The phantom root of the tree layout is used instead.\n    if (title) {\n      title.node.visible = false;\n    }\n    var lineHeight = this.lineHeight;\n    // Render ticks and labels.\n    var tickTreeLayout = this.tickTreeLayout;\n    var labels = scale.ticks();\n    var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    var ticks = tickScale.ticks();\n    // The side of the axis line to position the labels on.\n    // -1 = left (default)\n    //  1 = right\n    var sideFlag = label.mirrored ? 1 : -1;\n    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n    var parallelFlipRotation = normalizeAngle360(rotation);\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    // Flip if the axis rotation angle is in the top hemisphere.\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n    updateGridLines.exit.remove();\n    var enterGridLines = updateGridLines.enter.append(Line);\n    var gridLineSelection = updateGridLines.merge(enterGridLines);\n    var updateLabels = this.labelSelection.setData(treeLabels);\n    updateLabels.exit.remove();\n    var enterLabels = updateLabels.enter.append(Text);\n    var labelSelection = updateLabels.merge(enterLabels);\n    var labelFormatter = label.formatter;\n    var labelBBoxes = new Map();\n    var maxLeafLabelWidth = 0;\n    labelSelection.each(function (node, datum, index) {\n      node.fontStyle = label.fontStyle;\n      node.fontWeight = label.fontWeight;\n      node.fontSize = label.fontSize;\n      node.fontFamily = label.fontFamily;\n      node.fill = label.color;\n      node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n      node.textAlign = 'center';\n      node.translationX = datum.screenY - label.fontSize * 0.25;\n      node.translationY = datum.screenX;\n      if (index === 0) {\n        // use the phantom root as the axis title\n        if (title && title.enabled && labels.length > 0) {\n          node.visible = true;\n          node.text = title.text;\n          node.fontSize = title.fontSize;\n          node.fontStyle = title.fontStyle;\n          node.fontWeight = title.fontWeight;\n          node.fontFamily = title.fontFamily;\n          node.textBaseline = 'hanging';\n        } else {\n          node.visible = false;\n        }\n      } else {\n        node.text = labelFormatter ? labelFormatter({\n          value: String(datum.label),\n          index: index\n        }) : String(datum.label);\n        node.visible = datum.screenX >= requestedRange[0] && datum.screenX <= requestedRange[1];\n      }\n      var bbox = node.computeBBox();\n      labelBBoxes.set(node.id, bbox);\n      if (bbox.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox.width;\n      }\n    });\n    var labelX = sideFlag * label.padding;\n    var autoRotation = parallelLabels ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    var labelGrid = this.label.grid;\n    var separatorData = [];\n    labelSelection.each(function (label, datum, index) {\n      label.x = labelX;\n      label.rotationCenterX = labelX;\n      if (!datum.children.length) {\n        label.rotation = labelRotation;\n        label.textAlign = 'end';\n        label.textBaseline = 'middle';\n        var bbox = labelBBoxes.get(label.id);\n        if (bbox && bbox.height > bandwidth) {\n          label.visible = false;\n        }\n      } else {\n        label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n        var availableRange = datum.leafCount * bandwidth;\n        var bbox = labelBBoxes.get(label.id);\n        if (bbox && bbox.width > availableRange) {\n          label.visible = false;\n        } else if (isHorizontal) {\n          label.rotation = autoRotation;\n        } else {\n          label.rotation = -Math.PI / 2;\n        }\n      }\n      // Calculate positions of label separators for all nodes except the root.\n      // Each separator is placed to the top of the current label.\n      if (datum.parent && isLabelTree) {\n        var y = !datum.children.length ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (!datum.children.length) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y: y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - _this.label.padding * 2,\n              toString: function () {\n                return String(index);\n              }\n            });\n          }\n        } else {\n          var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y: y,\n            x1: x + lineHeight,\n            x2: x,\n            toString: function () {\n              return String(index);\n            }\n          });\n        }\n      }\n    });\n    // Calculate the position of the long separator on the far bottom of the axis.\n    var minX = 0;\n    separatorData.forEach(function (d) {\n      return minX = Math.min(minX, d.x2);\n    });\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX,\n      toString: function () {\n        return String(separatorData.length);\n      }\n    });\n    var updateSeparators = this.separatorSelection.setData(separatorData);\n    updateSeparators.exit.remove();\n    var enterSeparators = updateSeparators.enter.append(Line);\n    var separatorSelection = updateSeparators.merge(enterSeparators);\n    this.separatorSelection = separatorSelection;\n    var epsilon = 0.0000001;\n    separatorSelection.each(function (line, datum) {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n      line.stroke = _this.tick.color;\n      line.fill = undefined;\n      line.strokeWidth = 1;\n    });\n    this.gridLineSelection = gridLineSelection;\n    this.labelSelection = labelSelection;\n    // Render axis lines.\n    var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    var lines = [];\n    for (var i = 0; i < lineCount; i++) {\n      lines.push(i);\n    }\n    var updateAxisLines = this.axisLineSelection.setData(lines);\n    updateAxisLines.exit.remove();\n    var enterAxisLines = updateAxisLines.enter.append(Line);\n    var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n    this.axisLineSelection = axisLineSelection;\n    axisLineSelection.each(function (line, _, index) {\n      var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n      line.x1 = x;\n      line.x2 = x;\n      line.y1 = requestedRange[0];\n      line.y2 = requestedRange[1];\n      line.strokeWidth = _this.line.width;\n      line.stroke = _this.line.color;\n      line.visible = labels.length > 0 && (index === 0 || labelGrid && isLabelTree);\n    });\n    if (this.gridLength) {\n      var styles_1 = this.gridStyle;\n      var styleCount_1 = styles_1.length;\n      gridLineSelection.each(function (line, datum, index) {\n        var y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * _this.gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = y >= requestedRange[0] && y <= requestedRange[1] && Math.abs(line.parent.translationY - rangeStart) > 1;\n        var style = styles_1[index % styleCount_1];\n        line.stroke = style.stroke;\n        line.strokeWidth = _this.tick.width;\n        line.lineDash = style.lineDash;\n        line.fill = undefined;\n      });\n    }\n    return primaryTickCount;\n  };\n  GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n  GroupedCategoryAxis.type = 'groupedCategory';\n  __decorate([Validate(OPT_COLOR_STRING)], GroupedCategoryAxis.prototype, \"labelColor\", void 0);\n  return GroupedCategoryAxis;\n}(ChartAxis);\nexport { GroupedCategoryAxis };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__read","o","n","m","Symbol","iterator","call","ar","e","next","done","push","value","error","__spread","concat","Selection","Line","normalizeAngle360","toRadians","Text","BandScale","ticksToTree","treeLayout","AxisLabel","AxisLine","ChartAxis","ChartAxisDirection","extent","isContinuous","BOOLEAN","OPT_COLOR_STRING","Validate","GroupedCategoryAxisLabel","_super","_this","apply","grid","GroupedCategoryAxis","tickScale","translation","x","y","line","label","labelColor","includeInvisibleDomains","_a","axisGroup","gridlineGroup","scale","paddingOuter","paddingInner","requestedRange","range","slice","refreshScale","gridLineSelection","select","selectAll","axisLineSelection","separatorSelection","labelSelection","get","set","updateRange","enumerable","configurable","rr","vr","visibleRange","span","shift","start","resizeTickTree","s","domain","convert","layout","tickTreeLayout","lineHeight","resize","Math","abs","depth","min","bandwidth","fontSize","_gridLength","remove","setData","calculateDomain","_b","direction","boundSeries","domains","isNumericX","undefined","filter","visible","forEach","series","X","domain_1","getDomain","values","dataDomain","normaliseDataDomain","arr","indexOf","tickTree","tickScaleDomain","update","primaryTickCount","rangeStart","rangeEnd","rangeLength","parallelLabels","parallel","rotation","isHorizontal","cos","labelRotation","updatePosition","title","node","labels","ticks","treeLabels","nodes","isLabelTree","sideFlag","mirrored","parallelFlipRotation","parallelFlipFlag","PI","regularFlipRotation","regularFlipFlag","updateGridLines","gridLength","exit","enterGridLines","enter","append","merge","updateLabels","enterLabels","labelFormatter","formatter","labelBBoxes","Map","maxLeafLabelWidth","each","datum","index","fontStyle","fontWeight","fontFamily","fill","color","textBaseline","textAlign","translationX","screenY","translationY","screenX","enabled","text","String","bbox","computeBBox","id","width","labelX","padding","autoRotation","labelGrid","separatorData","rotationCenterX","children","height","availableRange","leafCount","parent","number","x1","x2","toString","minX","max","updateSeparators","enterSeparators","epsilon","y1","y2","stroke","tick","strokeWidth","lineCount","lines","updateAxisLines","enterAxisLines","_","styles_1","gridStyle","styleCount_1","round","style","lineDash","className","type"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/chart/axis/groupedCategoryAxis.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { Selection } from '../../scene/selection';\nimport { Line } from '../../scene/shape/line';\nimport { normalizeAngle360, toRadians } from '../../util/angle';\nimport { Text } from '../../scene/shape/text';\nimport { BandScale } from '../../scale/bandScale';\nimport { ticksToTree, treeLayout } from '../../layout/tree';\nimport { AxisLabel, AxisLine } from '../../axis';\nimport { ChartAxis, ChartAxisDirection } from '../chartAxis';\nimport { extent } from '../../util/array';\nimport { isContinuous } from '../../util/value';\nimport { BOOLEAN, OPT_COLOR_STRING, Validate } from '../../util/validation';\nvar GroupedCategoryAxisLabel = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxisLabel, _super);\n    function GroupedCategoryAxisLabel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.grid = false;\n        return _this;\n    }\n    __decorate([\n        Validate(BOOLEAN)\n    ], GroupedCategoryAxisLabel.prototype, \"grid\", void 0);\n    return GroupedCategoryAxisLabel;\n}(AxisLabel));\nvar GroupedCategoryAxis = /** @class */ (function (_super) {\n    __extends(GroupedCategoryAxis, _super);\n    function GroupedCategoryAxis() {\n        var _this = _super.call(this, new BandScale()) || this;\n        // Label scale (labels are positioned between ticks, tick count = label count + 1).\n        // We don't call is `labelScale` for consistency with other axes.\n        _this.tickScale = new BandScale();\n        _this.translation = {\n            x: 0,\n            y: 0,\n        };\n        _this.line = new AxisLine();\n        _this.label = new GroupedCategoryAxisLabel();\n        /**\n         * The color of the labels.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n         */\n        _this.labelColor = 'rgba(87, 87, 87, 1)';\n        _this.includeInvisibleDomains = true;\n        var _a = _this, axisGroup = _a.axisGroup, gridlineGroup = _a.gridlineGroup, tickScale = _a.tickScale, scale = _a.scale;\n        scale.paddingOuter = 0.1;\n        scale.paddingInner = scale.paddingOuter * 2;\n        _this.requestedRange = scale.range.slice();\n        _this.refreshScale();\n        tickScale.paddingInner = 1;\n        tickScale.paddingOuter = 0;\n        _this.gridLineSelection = Selection.select(gridlineGroup).selectAll();\n        _this.axisLineSelection = Selection.select(axisGroup).selectAll();\n        _this.separatorSelection = Selection.select(axisGroup).selectAll();\n        _this.labelSelection = Selection.select(axisGroup).selectAll();\n        return _this;\n    }\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"range\", {\n        get: function () {\n            return this.requestedRange.slice();\n        },\n        set: function (value) {\n            this.requestedRange = value.slice();\n            this.updateRange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GroupedCategoryAxis.prototype.updateRange = function () {\n        var _a = this, rr = _a.requestedRange, vr = _a.visibleRange, scale = _a.scale;\n        var span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        var shift = span * vr[0];\n        var start = rr[0] - shift;\n        this.tickScale.range = scale.range = [start, start + span];\n        this.resizeTickTree();\n    };\n    GroupedCategoryAxis.prototype.resizeTickTree = function () {\n        var s = this.scale;\n        var range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n        var layout = this.tickTreeLayout;\n        var lineHeight = this.lineHeight;\n        if (layout) {\n            layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\n        }\n    };\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"lineHeight\", {\n        get: function () {\n            return this.label.fontSize * 1.5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GroupedCategoryAxis.prototype, \"gridLength\", {\n        get: function () {\n            return this._gridLength;\n        },\n        /**\n         * The length of the grid. The grid is only visible in case of a non-zero value.\n         */\n        set: function (value) {\n            // Was visible and now invisible, or was invisible and now visible.\n            if ((this._gridLength && !value) || (!this._gridLength && value)) {\n                this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n                this.labelSelection = this.labelSelection.remove().setData([]);\n            }\n            this._gridLength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GroupedCategoryAxis.prototype.calculateDomain = function () {\n        var _a;\n        var _b = this, direction = _b.direction, boundSeries = _b.boundSeries;\n        var domains = [];\n        var isNumericX = undefined;\n        boundSeries\n            .filter(function (s) { return s.visible; })\n            .forEach(function (series) {\n            if (direction === ChartAxisDirection.X) {\n                if (isNumericX === undefined) {\n                    // always add first X domain\n                    var domain_1 = series.getDomain(direction);\n                    domains.push(domain_1);\n                    isNumericX = typeof domain_1[0] === 'number';\n                }\n                else if (isNumericX) {\n                    // only add further X domains if the axis is numeric\n                    domains.push(series.getDomain(direction));\n                }\n            }\n            else {\n                domains.push(series.getDomain(direction));\n            }\n        });\n        var domain = (_a = new Array()).concat.apply(_a, __spread(domains));\n        var values = extent(domain, isContinuous) || domain;\n        this.dataDomain = this.normaliseDataDomain(values);\n    };\n    GroupedCategoryAxis.prototype.normaliseDataDomain = function (d) {\n        // Prevent duplicate categories.\n        var values = d.filter(function (s, i, arr) { return arr.indexOf(s) === i; });\n        var tickTree = ticksToTree(values);\n        this.tickTreeLayout = treeLayout(tickTree);\n        var tickScaleDomain = values.slice();\n        tickScaleDomain.push('');\n        this.tickScale.domain = tickScaleDomain;\n        this.resizeTickTree();\n        return values;\n    };\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    GroupedCategoryAxis.prototype.update = function (primaryTickCount) {\n        var _this = this;\n        this.calculateDomain();\n        var _a = this, scale = _a.scale, label = _a.label, tickScale = _a.tickScale, requestedRange = _a.requestedRange;\n        scale.domain = this.dataDomain;\n        var rangeStart = scale.range[0];\n        var rangeEnd = scale.range[1];\n        var rangeLength = Math.abs(rangeEnd - rangeStart);\n        var bandwidth = rangeLength / scale.domain.length || 0;\n        var parallelLabels = label.parallel;\n        var rotation = toRadians(this.rotation);\n        var isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n        var labelRotation = this.label.rotation ? normalizeAngle360(toRadians(this.label.rotation)) : 0;\n        this.updatePosition();\n        var title = this.title;\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n        // The phantom root of the tree layout is used instead.\n        if (title) {\n            title.node.visible = false;\n        }\n        var lineHeight = this.lineHeight;\n        // Render ticks and labels.\n        var tickTreeLayout = this.tickTreeLayout;\n        var labels = scale.ticks();\n        var treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n        var isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n        var ticks = tickScale.ticks();\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        var sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, π] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        var parallelFlipRotation = normalizeAngle360(rotation);\n        var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n        var regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n        var updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n        updateGridLines.exit.remove();\n        var enterGridLines = updateGridLines.enter.append(Line);\n        var gridLineSelection = updateGridLines.merge(enterGridLines);\n        var updateLabels = this.labelSelection.setData(treeLabels);\n        updateLabels.exit.remove();\n        var enterLabels = updateLabels.enter.append(Text);\n        var labelSelection = updateLabels.merge(enterLabels);\n        var labelFormatter = label.formatter;\n        var labelBBoxes = new Map();\n        var maxLeafLabelWidth = 0;\n        labelSelection.each(function (node, datum, index) {\n            node.fontStyle = label.fontStyle;\n            node.fontWeight = label.fontWeight;\n            node.fontSize = label.fontSize;\n            node.fontFamily = label.fontFamily;\n            node.fill = label.color;\n            node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n            node.textAlign = 'center';\n            node.translationX = datum.screenY - label.fontSize * 0.25;\n            node.translationY = datum.screenX;\n            if (index === 0) {\n                // use the phantom root as the axis title\n                if (title && title.enabled && labels.length > 0) {\n                    node.visible = true;\n                    node.text = title.text;\n                    node.fontSize = title.fontSize;\n                    node.fontStyle = title.fontStyle;\n                    node.fontWeight = title.fontWeight;\n                    node.fontFamily = title.fontFamily;\n                    node.textBaseline = 'hanging';\n                }\n                else {\n                    node.visible = false;\n                }\n            }\n            else {\n                node.text = labelFormatter\n                    ? labelFormatter({\n                        value: String(datum.label),\n                        index: index,\n                    })\n                    : String(datum.label);\n                node.visible = datum.screenX >= requestedRange[0] && datum.screenX <= requestedRange[1];\n            }\n            var bbox = node.computeBBox();\n            labelBBoxes.set(node.id, bbox);\n            if (bbox.width > maxLeafLabelWidth) {\n                maxLeafLabelWidth = bbox.width;\n            }\n        });\n        var labelX = sideFlag * label.padding;\n        var autoRotation = parallelLabels ? (parallelFlipFlag * Math.PI) / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n        var labelGrid = this.label.grid;\n        var separatorData = [];\n        labelSelection.each(function (label, datum, index) {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            if (!datum.children.length) {\n                label.rotation = labelRotation;\n                label.textAlign = 'end';\n                label.textBaseline = 'middle';\n                var bbox = labelBBoxes.get(label.id);\n                if (bbox && bbox.height > bandwidth) {\n                    label.visible = false;\n                }\n            }\n            else {\n                label.translationX -= maxLeafLabelWidth - lineHeight + _this.label.padding;\n                var availableRange = datum.leafCount * bandwidth;\n                var bbox = labelBBoxes.get(label.id);\n                if (bbox && bbox.width > availableRange) {\n                    label.visible = false;\n                }\n                else if (isHorizontal) {\n                    label.rotation = autoRotation;\n                }\n                else {\n                    label.rotation = -Math.PI / 2;\n                }\n            }\n            // Calculate positions of label separators for all nodes except the root.\n            // Each separator is placed to the top of the current label.\n            if (datum.parent && isLabelTree) {\n                var y = !datum.children.length\n                    ? datum.screenX - bandwidth / 2\n                    : datum.screenX - (datum.leafCount * bandwidth) / 2;\n                if (!datum.children.length) {\n                    if (datum.number !== datum.children.length - 1 || labelGrid) {\n                        separatorData.push({\n                            y: y,\n                            x1: 0,\n                            x2: -maxLeafLabelWidth - _this.label.padding * 2,\n                            toString: function () { return String(index); },\n                        });\n                    }\n                }\n                else {\n                    var x = -maxLeafLabelWidth - _this.label.padding * 2 + datum.screenY;\n                    separatorData.push({\n                        y: y,\n                        x1: x + lineHeight,\n                        x2: x,\n                        toString: function () { return String(index); },\n                    });\n                }\n            }\n        });\n        // Calculate the position of the long separator on the far bottom of the axis.\n        var minX = 0;\n        separatorData.forEach(function (d) { return (minX = Math.min(minX, d.x2)); });\n        separatorData.push({\n            y: Math.max(rangeStart, rangeEnd),\n            x1: 0,\n            x2: minX,\n            toString: function () { return String(separatorData.length); },\n        });\n        var updateSeparators = this.separatorSelection.setData(separatorData);\n        updateSeparators.exit.remove();\n        var enterSeparators = updateSeparators.enter.append(Line);\n        var separatorSelection = updateSeparators.merge(enterSeparators);\n        this.separatorSelection = separatorSelection;\n        var epsilon = 0.0000001;\n        separatorSelection.each(function (line, datum) {\n            line.x1 = datum.x1;\n            line.x2 = datum.x2;\n            line.y1 = datum.y;\n            line.y2 = datum.y;\n            line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n            line.stroke = _this.tick.color;\n            line.fill = undefined;\n            line.strokeWidth = 1;\n        });\n        this.gridLineSelection = gridLineSelection;\n        this.labelSelection = labelSelection;\n        // Render axis lines.\n        var lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n        var lines = [];\n        for (var i = 0; i < lineCount; i++) {\n            lines.push(i);\n        }\n        var updateAxisLines = this.axisLineSelection.setData(lines);\n        updateAxisLines.exit.remove();\n        var enterAxisLines = updateAxisLines.enter.append(Line);\n        var axisLineSelection = updateAxisLines.merge(enterAxisLines);\n        this.axisLineSelection = axisLineSelection;\n        axisLineSelection.each(function (line, _, index) {\n            var x = index > 0 ? -maxLeafLabelWidth - _this.label.padding * 2 - (index - 1) * lineHeight : 0;\n            line.x1 = x;\n            line.x2 = x;\n            line.y1 = requestedRange[0];\n            line.y2 = requestedRange[1];\n            line.strokeWidth = _this.line.width;\n            line.stroke = _this.line.color;\n            line.visible = labels.length > 0 && (index === 0 || (labelGrid && isLabelTree));\n        });\n        if (this.gridLength) {\n            var styles_1 = this.gridStyle;\n            var styleCount_1 = styles_1.length;\n            gridLineSelection.each(function (line, datum, index) {\n                var y = Math.round(tickScale.convert(datum));\n                line.x1 = 0;\n                line.x2 = -sideFlag * _this.gridLength;\n                line.y1 = y;\n                line.y2 = y;\n                line.visible =\n                    y >= requestedRange[0] &&\n                        y <= requestedRange[1] &&\n                        Math.abs(line.parent.translationY - rangeStart) > 1;\n                var style = styles_1[index % styleCount_1];\n                line.stroke = style.stroke;\n                line.strokeWidth = _this.tick.width;\n                line.lineDash = style.lineDash;\n                line.fill = undefined;\n            });\n        }\n        return primaryTickCount;\n    };\n    GroupedCategoryAxis.className = 'GroupedCategoryAxis';\n    GroupedCategoryAxis.type = 'groupedCategory';\n    __decorate([\n        Validate(OPT_COLOR_STRING)\n    ], GroupedCategoryAxis.prototype, \"labelColor\", void 0);\n    return GroupedCategoryAxis;\n}(ChartAxis));\nexport { GroupedCategoryAxis };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}