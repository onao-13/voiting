{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nexports.__esModule = true;\nvar graphic_1 = require(\"../util/graphic\");\nfunction prepareLayoutList(input) {\n  var list = [];\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n    var label = rawItem.label;\n    var transform = label.getComputedTransform();\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new graphic_1.OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n  return list;\n}\nexports.prepareLayoutList = prepareLayoutList;\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n  if (len < 2) {\n    return;\n  }\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n    if (delta < 0) {\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n  if (totalShifts > 0 && balanceShift) {\n    shiftList(-totalShifts / len, 0, len);\n  }\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap();\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1);\n  updateMinMaxGap();\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  }\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n    if (!totalGaps) {\n      return;\n    }\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        var movement = gaps[i] * squeezePercent;\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      for (var i = len - 1; i > 0; i--) {\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n      delta -= moveForEachLabel;\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n  return adjusted;\n}\nfunction shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\nexports.shiftLayoutOnX = shiftLayoutOnX;\nfunction shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\nexports.shiftLayoutOnY = shiftLayoutOnY;\nfunction hideOverlap(labelList) {\n  var displayedLabels = [];\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new graphic_1.BoundingRect(0, 0, 0, 0);\n  function hideEl(el) {\n    if (!el.ignore) {\n      var emphasisState = el.ensureState('emphasis');\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n    el.ignore = true;\n  }\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect);\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j];\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        overlapped = true;\n        break;\n      }\n      if (!existsTextCfg.obb) {\n        existsTextCfg.obb = new graphic_1.OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n      if (!obb) {\n        obb = new graphic_1.OrientedBoundingRect(localRect, transform);\n      }\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    }\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}\nexports.hideOverlap = hideOverlap;","map":{"version":3,"names":["exports","__esModule","graphic_1","require","prepareLayoutList","input","list","i","length","rawItem","defaultAttr","ignore","label","transform","getComputedTransform","localRect","getBoundingRect","isAxisAligned","minMargin","style","margin","globalRect","clone","applyTransform","x","y","width","height","obb","OrientedBoundingRect","push","labelLine","rect","priority","layoutOption","computedLayoutOption","axisAligned","shiftLayout","xyDim","sizeDim","minBound","maxBound","balanceShift","len","sort","a","b","lastPos","delta","adjusted","shifts","totalShifts","item","shift","Math","max","shiftList","first","last","minGap","maxGap","updateMinMaxGap","squeezeGaps","takeBoundsGap","squeezeWhenBailout","gapThisBound","gapOtherBound","moveDir","moveFromMaxGap","min","remained","start","end","maxSqeezePercent","gaps","totalGaps","prevItemRect","gap","squeezePercent","abs","movement","dir","moveForEachLabel","ceil","shiftLayoutOnX","leftBound","rightBound","shiftLayoutOnY","topBound","bottomBound","hideOverlap","labelList","displayedLabels","BoundingRect","hideEl","el","emphasisState","ensureState","labelItem","copy","overlapped","j","existsTextCfg","intersect","attr","labelGuideIgnore"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/echarts/lib/label/labelLayoutHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar graphic_1 = require(\"../util/graphic\");\n\nfunction prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform();\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new graphic_1.OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nexports.prepareLayoutList = prepareLayoutList;\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    shiftList(-totalShifts / len, 0, len);\n  }\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap();\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1);\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  }\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        var movement = gaps[i] * squeezePercent;\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      for (var i = len - 1; i > 0; i--) {\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n\nfunction shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n\nexports.shiftLayoutOnX = shiftLayoutOnX;\n\nfunction shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\n\nexports.shiftLayoutOnY = shiftLayoutOnY;\n\nfunction hideOverlap(labelList) {\n  var displayedLabels = [];\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new graphic_1.BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect);\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j];\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        existsTextCfg.obb = new graphic_1.OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        obb = new graphic_1.OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    }\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}\n\nexports.hideOverlap = hideOverlap;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}