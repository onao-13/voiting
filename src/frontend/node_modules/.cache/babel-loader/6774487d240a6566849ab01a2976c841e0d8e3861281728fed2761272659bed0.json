{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { cubicSegmentIntersections, segmentIntersection } from './intersection';\nvar Path2D = /** @class */function () {\n  function Path2D() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this._closedPath = false;\n  }\n  Path2D.prototype.isDirty = function () {\n    if (this._closedPath !== this.previousClosedPath) {\n      return true;\n    }\n    if (this.previousCommands.length !== this.commands.length) {\n      return true;\n    }\n    if (this.previousParams.length !== this.params.length) {\n      return true;\n    }\n    for (var i = 0; i < this.commands.length; i++) {\n      if (this.commands[i] !== this.previousCommands[i]) {\n        return true;\n      }\n    }\n    for (var i = 0; i < this.params.length; i++) {\n      if (this.params[i] !== this.previousParams[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n  Path2D.prototype.draw = function (ctx) {\n    var e_1, _a;\n    var commands = this.commands;\n    var params = this.params;\n    var j = 0;\n    ctx.beginPath();\n    try {\n      for (var commands_1 = __values(commands), commands_1_1 = commands_1.next(); !commands_1_1.done; commands_1_1 = commands_1.next()) {\n        var command = commands_1_1.value;\n        switch (command) {\n          case 'M':\n            ctx.moveTo(params[j++], params[j++]);\n            break;\n          case 'L':\n            ctx.lineTo(params[j++], params[j++]);\n            break;\n          case 'C':\n            ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);\n            break;\n          case 'Z':\n            ctx.closePath();\n            break;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (commands_1_1 && !commands_1_1.done && (_a = commands_1.return)) _a.call(commands_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    if (commands.length === 0) {\n      ctx.closePath();\n    }\n  };\n  Path2D.prototype.moveTo = function (x, y) {\n    if (this.xy) {\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.xy = [x, y];\n    }\n    this.commands.push('M');\n    this.params.push(x, y);\n  };\n  Path2D.prototype.lineTo = function (x, y) {\n    if (this.xy) {\n      this.commands.push('L');\n      this.params.push(x, y);\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n  Path2D.prototype.rect = function (x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  };\n  /**\n   * Adds an arc segment to the path definition.\n   * https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands\n   * @param rx The major-axis radius.\n   * @param ry The minor-axis radius.\n   * @param rotation The x-axis rotation, expressed in radians.\n   * @param fA The large arc flag. `1` to use angle > π.\n   * @param fS The sweep flag. `1` for the arc that goes to `x`/`y` clockwise.\n   * @param x2 The x coordinate to arc to.\n   * @param y2 The y coordinate to arc to.\n   */\n  Path2D.prototype.arcTo = function (rx, ry, rotation, fA, fS, x2, y2) {\n    // Convert from endpoint to center parametrization:\n    // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n    var xy = this.xy;\n    if (!xy) {\n      return;\n    }\n    if (rx < 0) {\n      rx = -rx;\n    }\n    if (ry < 0) {\n      ry = -ry;\n    }\n    var x1 = xy[0];\n    var y1 = xy[1];\n    var hdx = (x1 - x2) / 2;\n    var hdy = (y1 - y2) / 2;\n    var sinPhi = Math.sin(rotation);\n    var cosPhi = Math.cos(rotation);\n    var xp = cosPhi * hdx + sinPhi * hdy;\n    var yp = -sinPhi * hdx + cosPhi * hdy;\n    var ratX = xp / rx;\n    var ratY = yp / ry;\n    var lambda = ratX * ratX + ratY * ratY;\n    var cx = (x1 + x2) / 2;\n    var cy = (y1 + y2) / 2;\n    var cpx = 0;\n    var cpy = 0;\n    if (lambda >= 1) {\n      lambda = Math.sqrt(lambda);\n      rx *= lambda;\n      ry *= lambda;\n      // me gives lambda == cpx == cpy == 0;\n    } else {\n      lambda = Math.sqrt(1 / lambda - 1);\n      if (fA === fS) {\n        lambda = -lambda;\n      }\n      cpx = lambda * rx * ratY;\n      cpy = -lambda * ry * ratX;\n      cx += cosPhi * cpx - sinPhi * cpy;\n      cy += sinPhi * cpx + cosPhi * cpy;\n    }\n    var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx);\n    var deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;\n    this.cubicArc(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);\n  };\n  /**\n   * Approximates an elliptical arc with up to four cubic Bézier curves.\n   * @param commands The string array to write SVG command letters to.\n   * @param params The number array to write SVG command parameters (cubic control points) to.\n   * @param cx The x-axis coordinate for the ellipse's center.\n   * @param cy The y-axis coordinate for the ellipse's center.\n   * @param rx The ellipse's major-axis radius.\n   * @param ry The ellipse's minor-axis radius.\n   * @param phi The rotation for this ellipse, expressed in radians.\n   * @param theta1 The starting angle, measured clockwise from the positive x-axis and expressed in radians.\n   * @param theta2 The ending angle, measured clockwise from the positive x-axis and expressed in radians.\n   * @param anticlockwise The arc control points are always placed clockwise from `theta1` to `theta2`,\n   * even when `theta1 > theta2`, unless this flag is set to `1`.\n   */\n  Path2D.cubicArc = function (commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n    if (anticlockwise) {\n      var temp = theta1;\n      theta1 = theta2;\n      theta2 = temp;\n    }\n    var start = params.length;\n    // See https://pomax.github.io/bezierinfo/#circles_cubic\n    // Arc of unit circle (start angle = 0, end angle <= π/2) in cubic Bézier coordinates:\n    // S = [1, 0]\n    // C1 = [1, f]\n    // C2 = [cos(θ) + f * sin(θ), sin(θ) - f * cos(θ)]\n    // E = [cos(θ), sin(θ)]\n    // f = 4/3 * tan(θ/4)\n    var f90 = 0.5522847498307935; // f for θ = π/2 is 4/3 * (Math.sqrt(2) - 1)\n    var sinTheta1 = Math.sin(theta1);\n    var cosTheta1 = Math.cos(theta1);\n    var sinPhi = Math.sin(phi);\n    var cosPhi = Math.cos(phi);\n    var rightAngle = Math.PI / 2;\n    // Since we know how to draw an arc of a unit circle with a cubic Bézier,\n    // to draw an elliptical arc with arbitrary rotation and radii we:\n    // 1) rotate the Bézier coordinates that represent a circular arc by θ\n    // 2) scale the circular arc separately along the x/y axes, making it elliptical\n    // 3) rotate elliptical arc by φ\n    // |cos(φ) -sin(φ)| |sx  0| |cos(θ) -sin(θ)| -> |xx xy|\n    // |sin(φ)  cos(φ)| | 0 sy| |sin(θ)  cos(θ)| -> |yx yy|\n    var xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry;\n    var yx = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry;\n    var xy = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry;\n    var yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry;\n    // Always draw clockwise from θ1 to θ2.\n    theta2 -= theta1;\n    if (theta2 < 0) {\n      theta2 += Math.PI * 2;\n    }\n    // Multiplying each point [x, y] by:\n    // |xx xy cx| |x|\n    // |yx yy cy| |y|\n    // | 0  0  1| |1|\n    commands.push('M');\n    params.push(xx + cx, yx + cy);\n    while (theta2 >= rightAngle) {\n      theta2 -= rightAngle;\n      commands.push('C');\n      // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n      // Revert this commit when fixed ^^.\n      var lastX = xy + cx;\n      params.push(xx + xy * f90 + cx, yx + yy * f90 + cy, xx * f90 + xy + cx, yx * f90 + yy + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yy + cy);\n      // Prepend π/2 rotation matrix.\n      // |xx xy| | 0 1| -> | xy -xx|\n      // |yx yy| |-1 0| -> | yy -yx|\n      // [xx, yx, xy, yy] = [xy, yy, -xx, -yx];\n      // Compared to swapping with a temp variable, destructuring is:\n      // - 10% faster in Chrome 70\n      // - 99% slower in Firefox 63\n      // Temp variable solution is 45% faster in FF than Chrome.\n      // https://jsperf.com/multi-swap\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1165569\n      var temp = xx;\n      xx = xy;\n      xy = -temp;\n      temp = yx;\n      yx = yy;\n      yy = -temp;\n    }\n    if (theta2) {\n      var f = 4 / 3 * Math.tan(theta2 / 4);\n      var sinPhi2 = Math.sin(theta2);\n      var cosPhi2 = Math.cos(theta2);\n      var C2x = cosPhi2 + f * sinPhi2;\n      var C2y = sinPhi2 - f * cosPhi2;\n      commands.push('C');\n      // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n      // Revert this commit when fixed ^^.\n      var lastX = xx * cosPhi2 + xy * sinPhi2 + cx;\n      params.push(xx + xy * f + cx, yx + yy * f + cy, xx * C2x + xy * C2y + cx, yx * C2x + yy * C2y + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yx * cosPhi2 + yy * sinPhi2 + cy);\n    }\n    if (anticlockwise) {\n      for (var i = start, j = params.length - 2; i < j; i += 2, j -= 2) {\n        var temp = params[i];\n        params[i] = params[j];\n        params[j] = temp;\n        temp = params[i + 1];\n        params[i + 1] = params[j + 1];\n        params[j + 1] = temp;\n      }\n    }\n  };\n  Path2D.prototype.cubicArc = function (cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n    var commands = this.commands;\n    var params = this.params;\n    var start = commands.length;\n    Path2D.cubicArc(commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise);\n    var x = params[params.length - 2];\n    var y = params[params.length - 1];\n    if (this.xy) {\n      commands[start] = 'L';\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.xy = [x, y];\n    }\n  };\n  /**\n   * Returns the `[x, y]` coordinates of the curve at `t`.\n   * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n   * @param t\n   */\n  Path2D.prototype.deCasteljau = function (points, t) {\n    var n = points.length;\n    if (n < 2 || n % 2 === 1) {\n      throw new Error('Fewer than two points or not an even count.');\n    } else if (n === 2 || t === 0) {\n      return points.slice(0, 2);\n    } else if (t === 1) {\n      return points.slice(-2);\n    } else {\n      var newPoints = [];\n      var last = n - 2;\n      for (var i = 0; i < last; i += 2) {\n        newPoints.push((1 - t) * points[i] + t * points[i + 2],\n        // x\n        (1 - t) * points[i + 1] + t * points[i + 3] // y\n        );\n      }\n\n      return this.deCasteljau(newPoints, t);\n    }\n  };\n  /**\n   * Approximates the given curve using `n` line segments.\n   * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n   * @param n\n   */\n  Path2D.prototype.approximateCurve = function (points, n) {\n    var xy = this.deCasteljau(points, 0);\n    this.moveTo(xy[0], xy[1]);\n    var step = 1 / n;\n    for (var t = step; t <= 1; t += step) {\n      var xy_1 = this.deCasteljau(points, t);\n      this.lineTo(xy_1[0], xy_1[1]);\n    }\n  };\n  /**\n   * Adds a quadratic curve segment to the path definition.\n   * Note: the given quadratic segment is converted and stored as a cubic one.\n   * @param cx x-component of the curve's control point\n   * @param cy y-component of the curve's control point\n   * @param x x-component of the end point\n   * @param y y-component of the end point\n   */\n  Path2D.prototype.quadraticCurveTo = function (cx, cy, x, y) {\n    if (!this.xy) {\n      this.moveTo(cx, cy);\n    }\n    // See https://pomax.github.io/bezierinfo/#reordering\n    this.cubicCurveTo((this.xy[0] + 2 * cx) / 3, (this.xy[1] + 2 * cy) / 3,\n    // 1/3 start + 2/3 control\n    (2 * cx + x) / 3, (2 * cy + y) / 3,\n    // 2/3 control + 1/3 end\n    x, y);\n  };\n  Path2D.prototype.cubicCurveTo = function (cx1, cy1, cx2, cy2, x, y) {\n    if (!this.xy) {\n      this.moveTo(cx1, cy1);\n    }\n    this.commands.push('C');\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n    this.xy[0] = x;\n    this.xy[1] = y;\n  };\n  Object.defineProperty(Path2D.prototype, \"closedPath\", {\n    get: function () {\n      return this._closedPath;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Path2D.prototype.closePath = function () {\n    if (this.xy) {\n      this.xy = undefined;\n      this.commands.push('Z');\n      this._closedPath = true;\n    }\n  };\n  Path2D.prototype.clear = function (_a) {\n    var trackChanges = (_a === void 0 ? {\n      trackChanges: false\n    } : _a).trackChanges;\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this._closedPath;\n      this.commands = [];\n      this.params = [];\n    } else {\n      this.commands.length = 0;\n      this.params.length = 0;\n    }\n    this.xy = undefined;\n    this._closedPath = false;\n  };\n  Path2D.prototype.isPointInPath = function (x, y) {\n    var commands = this.commands;\n    var params = this.params;\n    var cn = commands.length;\n    // Hit testing using ray casting method, where the ray's origin is some point\n    // outside the path. In this case, an offscreen point that is remote enough, so that\n    // even if the path itself is large and is partially offscreen, the ray's origin\n    // will likely be outside the path anyway. To test if the given point is inside the\n    // path or not, we cast a ray from the origin to the given point and check the number\n    // of intersections of this segment with the path. If the number of intersections is\n    // even, then the ray both entered and exited the path an equal number of times,\n    // therefore the point is outside the path, and inside the path, if the number of\n    // intersections is odd. Since the path is compound, we check if the ray segment\n    // intersects with each of the path's segments, which can be either a line segment\n    // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\n    // points).\n    var ox = -10000;\n    var oy = -10000;\n    // the starting point of the  current path\n    var sx = NaN;\n    var sy = NaN;\n    // the previous point of the current path\n    var px = 0;\n    var py = 0;\n    var intersectionCount = 0;\n    for (var ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 'M':\n          if (!isNaN(sx)) {\n            if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n              intersectionCount++;\n            }\n          }\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 'L':\n          if (segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y)) {\n            intersectionCount++;\n          }\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 'C':\n          intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], ox, oy, x, y).length;\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 'Z':\n          if (!isNaN(sx)) {\n            if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n              intersectionCount++;\n            }\n          }\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  };\n  /**\n   * Returns an array of sub-paths of this Path,\n   * where each sub-path is represented exclusively by cubic segments.\n   */\n  Path2D.prototype.toCubicPaths = function () {\n    // Each sub-path is an array of `(n * 3 + 1) * 2` numbers,\n    // where `n` is the number of segments.\n    var paths = [];\n    var params = this.params;\n    // current path\n    var path;\n    // the starting point of the  current path\n    var sx;\n    var sy;\n    // the previous point of the current path\n    var px;\n    var py;\n    var i = 0; // current parameter\n    this.commands.forEach(function (command) {\n      switch (command) {\n        case 'M':\n          px = params[i++];\n          py = params[i++];\n          sx = px;\n          sy = py;\n          paths.push([sx, sy]);\n          break;\n        case 'L':\n          var x = params[i++];\n          var y = params[i++];\n          // Place control points along the line `a + (b - a) * t`\n          // at t = 1/3 and 2/3:\n          path.push((px + px + x) / 3, (py + py + y) / 3, (px + x + x) / 3, (py + y + y) / 3, x, y);\n          px = x;\n          py = y;\n          break;\n        case 'C':\n          path.push(params[i++], params[i++], params[i++], params[i++], params[i++], params[i++]);\n          px = params[i - 2];\n          py = params[i - 1];\n          break;\n        case 'Z':\n          path.push((px + px + sx) / 3, (py + py + sy) / 3, (px + sx + sx) / 3, (py + sy + sy) / 3, sx, sy);\n          px = sx;\n          py = sy;\n          break;\n      }\n    });\n    return paths;\n  };\n  Path2D.cubicPathToString = function (path) {\n    var n = path.length;\n    if (!(n % 2 === 0 && (n / 2 - 1) / 2 >= 1)) {\n      throw new Error('Invalid path.');\n    }\n    return 'M' + path.slice(0, 2).join(',') + 'C' + path.slice(2).join(',');\n  };\n  return Path2D;\n}();\nexport { Path2D };","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","cubicSegmentIntersections","segmentIntersection","Path2D","previousCommands","previousParams","previousClosedPath","commands","params","_closedPath","prototype","isDirty","draw","ctx","e_1","_a","j","beginPath","commands_1","commands_1_1","command","moveTo","lineTo","bezierCurveTo","closePath","e_1_1","error","return","x","y","xy","push","rect","width","height","arcTo","rx","ry","rotation","fA","fS","x2","y2","x1","y1","hdx","hdy","sinPhi","Math","sin","cosPhi","cos","xp","yp","ratX","ratY","lambda","cx","cy","cpx","cpy","sqrt","theta1","atan2","deltaTheta","cubicArc","phi","theta2","anticlockwise","temp","start","f90","sinTheta1","cosTheta1","rightAngle","PI","xx","yx","yy","lastX","abs","f","tan","sinPhi2","cosPhi2","C2x","C2y","deCasteljau","points","t","n","Error","slice","newPoints","last","approximateCurve","step","xy_1","quadraticCurveTo","cubicCurveTo","cx1","cy1","cx2","cy2","Object","defineProperty","get","enumerable","configurable","undefined","clear","trackChanges","isPointInPath","cn","ox","oy","sx","NaN","sy","px","py","intersectionCount","ci","pi","isNaN","toCubicPaths","paths","path","forEach","cubicPathToString","join"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/scene/path2D.js"],"sourcesContent":["var __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { cubicSegmentIntersections, segmentIntersection } from './intersection';\nvar Path2D = /** @class */ (function () {\n    function Path2D() {\n        // The methods of this class will likely be called many times per animation frame,\n        // and any allocation can trigger a GC cycle during animation, so we attempt\n        // to minimize the number of allocations.\n        this.previousCommands = [];\n        this.previousParams = [];\n        this.previousClosedPath = false;\n        this.commands = [];\n        this.params = [];\n        this._closedPath = false;\n    }\n    Path2D.prototype.isDirty = function () {\n        if (this._closedPath !== this.previousClosedPath) {\n            return true;\n        }\n        if (this.previousCommands.length !== this.commands.length) {\n            return true;\n        }\n        if (this.previousParams.length !== this.params.length) {\n            return true;\n        }\n        for (var i = 0; i < this.commands.length; i++) {\n            if (this.commands[i] !== this.previousCommands[i]) {\n                return true;\n            }\n        }\n        for (var i = 0; i < this.params.length; i++) {\n            if (this.params[i] !== this.previousParams[i]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Path2D.prototype.draw = function (ctx) {\n        var e_1, _a;\n        var commands = this.commands;\n        var params = this.params;\n        var j = 0;\n        ctx.beginPath();\n        try {\n            for (var commands_1 = __values(commands), commands_1_1 = commands_1.next(); !commands_1_1.done; commands_1_1 = commands_1.next()) {\n                var command = commands_1_1.value;\n                switch (command) {\n                    case 'M':\n                        ctx.moveTo(params[j++], params[j++]);\n                        break;\n                    case 'L':\n                        ctx.lineTo(params[j++], params[j++]);\n                        break;\n                    case 'C':\n                        ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);\n                        break;\n                    case 'Z':\n                        ctx.closePath();\n                        break;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (commands_1_1 && !commands_1_1.done && (_a = commands_1.return)) _a.call(commands_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (commands.length === 0) {\n            ctx.closePath();\n        }\n    };\n    Path2D.prototype.moveTo = function (x, y) {\n        if (this.xy) {\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.xy = [x, y];\n        }\n        this.commands.push('M');\n        this.params.push(x, y);\n    };\n    Path2D.prototype.lineTo = function (x, y) {\n        if (this.xy) {\n            this.commands.push('L');\n            this.params.push(x, y);\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.moveTo(x, y);\n        }\n    };\n    Path2D.prototype.rect = function (x, y, width, height) {\n        this.moveTo(x, y);\n        this.lineTo(x + width, y);\n        this.lineTo(x + width, y + height);\n        this.lineTo(x, y + height);\n        this.closePath();\n    };\n    /**\n     * Adds an arc segment to the path definition.\n     * https://www.w3.org/TR/SVG11/paths.html#PathDataEllipticalArcCommands\n     * @param rx The major-axis radius.\n     * @param ry The minor-axis radius.\n     * @param rotation The x-axis rotation, expressed in radians.\n     * @param fA The large arc flag. `1` to use angle > π.\n     * @param fS The sweep flag. `1` for the arc that goes to `x`/`y` clockwise.\n     * @param x2 The x coordinate to arc to.\n     * @param y2 The y coordinate to arc to.\n     */\n    Path2D.prototype.arcTo = function (rx, ry, rotation, fA, fS, x2, y2) {\n        // Convert from endpoint to center parametrization:\n        // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n        var xy = this.xy;\n        if (!xy) {\n            return;\n        }\n        if (rx < 0) {\n            rx = -rx;\n        }\n        if (ry < 0) {\n            ry = -ry;\n        }\n        var x1 = xy[0];\n        var y1 = xy[1];\n        var hdx = (x1 - x2) / 2;\n        var hdy = (y1 - y2) / 2;\n        var sinPhi = Math.sin(rotation);\n        var cosPhi = Math.cos(rotation);\n        var xp = cosPhi * hdx + sinPhi * hdy;\n        var yp = -sinPhi * hdx + cosPhi * hdy;\n        var ratX = xp / rx;\n        var ratY = yp / ry;\n        var lambda = ratX * ratX + ratY * ratY;\n        var cx = (x1 + x2) / 2;\n        var cy = (y1 + y2) / 2;\n        var cpx = 0;\n        var cpy = 0;\n        if (lambda >= 1) {\n            lambda = Math.sqrt(lambda);\n            rx *= lambda;\n            ry *= lambda;\n            // me gives lambda == cpx == cpy == 0;\n        }\n        else {\n            lambda = Math.sqrt(1 / lambda - 1);\n            if (fA === fS) {\n                lambda = -lambda;\n            }\n            cpx = lambda * rx * ratY;\n            cpy = -lambda * ry * ratX;\n            cx += cosPhi * cpx - sinPhi * cpy;\n            cy += sinPhi * cpx + cosPhi * cpy;\n        }\n        var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx);\n        var deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;\n        this.cubicArc(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);\n    };\n    /**\n     * Approximates an elliptical arc with up to four cubic Bézier curves.\n     * @param commands The string array to write SVG command letters to.\n     * @param params The number array to write SVG command parameters (cubic control points) to.\n     * @param cx The x-axis coordinate for the ellipse's center.\n     * @param cy The y-axis coordinate for the ellipse's center.\n     * @param rx The ellipse's major-axis radius.\n     * @param ry The ellipse's minor-axis radius.\n     * @param phi The rotation for this ellipse, expressed in radians.\n     * @param theta1 The starting angle, measured clockwise from the positive x-axis and expressed in radians.\n     * @param theta2 The ending angle, measured clockwise from the positive x-axis and expressed in radians.\n     * @param anticlockwise The arc control points are always placed clockwise from `theta1` to `theta2`,\n     * even when `theta1 > theta2`, unless this flag is set to `1`.\n     */\n    Path2D.cubicArc = function (commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n        if (anticlockwise) {\n            var temp = theta1;\n            theta1 = theta2;\n            theta2 = temp;\n        }\n        var start = params.length;\n        // See https://pomax.github.io/bezierinfo/#circles_cubic\n        // Arc of unit circle (start angle = 0, end angle <= π/2) in cubic Bézier coordinates:\n        // S = [1, 0]\n        // C1 = [1, f]\n        // C2 = [cos(θ) + f * sin(θ), sin(θ) - f * cos(θ)]\n        // E = [cos(θ), sin(θ)]\n        // f = 4/3 * tan(θ/4)\n        var f90 = 0.5522847498307935; // f for θ = π/2 is 4/3 * (Math.sqrt(2) - 1)\n        var sinTheta1 = Math.sin(theta1);\n        var cosTheta1 = Math.cos(theta1);\n        var sinPhi = Math.sin(phi);\n        var cosPhi = Math.cos(phi);\n        var rightAngle = Math.PI / 2;\n        // Since we know how to draw an arc of a unit circle with a cubic Bézier,\n        // to draw an elliptical arc with arbitrary rotation and radii we:\n        // 1) rotate the Bézier coordinates that represent a circular arc by θ\n        // 2) scale the circular arc separately along the x/y axes, making it elliptical\n        // 3) rotate elliptical arc by φ\n        // |cos(φ) -sin(φ)| |sx  0| |cos(θ) -sin(θ)| -> |xx xy|\n        // |sin(φ)  cos(φ)| | 0 sy| |sin(θ)  cos(θ)| -> |yx yy|\n        var xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry;\n        var yx = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry;\n        var xy = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry;\n        var yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry;\n        // Always draw clockwise from θ1 to θ2.\n        theta2 -= theta1;\n        if (theta2 < 0) {\n            theta2 += Math.PI * 2;\n        }\n        // Multiplying each point [x, y] by:\n        // |xx xy cx| |x|\n        // |yx yy cy| |y|\n        // | 0  0  1| |1|\n        commands.push('M');\n        params.push(xx + cx, yx + cy);\n        while (theta2 >= rightAngle) {\n            theta2 -= rightAngle;\n            commands.push('C');\n            // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n            // Revert this commit when fixed ^^.\n            var lastX = xy + cx;\n            params.push(xx + xy * f90 + cx, yx + yy * f90 + cy, xx * f90 + xy + cx, yx * f90 + yy + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yy + cy);\n            // Prepend π/2 rotation matrix.\n            // |xx xy| | 0 1| -> | xy -xx|\n            // |yx yy| |-1 0| -> | yy -yx|\n            // [xx, yx, xy, yy] = [xy, yy, -xx, -yx];\n            // Compared to swapping with a temp variable, destructuring is:\n            // - 10% faster in Chrome 70\n            // - 99% slower in Firefox 63\n            // Temp variable solution is 45% faster in FF than Chrome.\n            // https://jsperf.com/multi-swap\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1165569\n            var temp = xx;\n            xx = xy;\n            xy = -temp;\n            temp = yx;\n            yx = yy;\n            yy = -temp;\n        }\n        if (theta2) {\n            var f = (4 / 3) * Math.tan(theta2 / 4);\n            var sinPhi2 = Math.sin(theta2);\n            var cosPhi2 = Math.cos(theta2);\n            var C2x = cosPhi2 + f * sinPhi2;\n            var C2y = sinPhi2 - f * cosPhi2;\n            commands.push('C');\n            // Temp workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=993330\n            // Revert this commit when fixed ^^.\n            var lastX = xx * cosPhi2 + xy * sinPhi2 + cx;\n            params.push(xx + xy * f + cx, yx + yy * f + cy, xx * C2x + xy * C2y + cx, yx * C2x + yy * C2y + cy, Math.abs(lastX) < 1e-8 ? 0 : lastX, yx * cosPhi2 + yy * sinPhi2 + cy);\n        }\n        if (anticlockwise) {\n            for (var i = start, j = params.length - 2; i < j; i += 2, j -= 2) {\n                var temp = params[i];\n                params[i] = params[j];\n                params[j] = temp;\n                temp = params[i + 1];\n                params[i + 1] = params[j + 1];\n                params[j + 1] = temp;\n            }\n        }\n    };\n    Path2D.prototype.cubicArc = function (cx, cy, rx, ry, phi, theta1, theta2, anticlockwise) {\n        var commands = this.commands;\n        var params = this.params;\n        var start = commands.length;\n        Path2D.cubicArc(commands, params, cx, cy, rx, ry, phi, theta1, theta2, anticlockwise);\n        var x = params[params.length - 2];\n        var y = params[params.length - 1];\n        if (this.xy) {\n            commands[start] = 'L';\n            this.xy[0] = x;\n            this.xy[1] = y;\n        }\n        else {\n            this.xy = [x, y];\n        }\n    };\n    /**\n     * Returns the `[x, y]` coordinates of the curve at `t`.\n     * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n     * @param t\n     */\n    Path2D.prototype.deCasteljau = function (points, t) {\n        var n = points.length;\n        if (n < 2 || n % 2 === 1) {\n            throw new Error('Fewer than two points or not an even count.');\n        }\n        else if (n === 2 || t === 0) {\n            return points.slice(0, 2);\n        }\n        else if (t === 1) {\n            return points.slice(-2);\n        }\n        else {\n            var newPoints = [];\n            var last = n - 2;\n            for (var i = 0; i < last; i += 2) {\n                newPoints.push((1 - t) * points[i] + t * points[i + 2], // x\n                (1 - t) * points[i + 1] + t * points[i + 3] // y\n                );\n            }\n            return this.deCasteljau(newPoints, t);\n        }\n    };\n    /**\n     * Approximates the given curve using `n` line segments.\n     * @param points `(n + 1) * 2` control point coordinates for a Bézier curve of n-th order.\n     * @param n\n     */\n    Path2D.prototype.approximateCurve = function (points, n) {\n        var xy = this.deCasteljau(points, 0);\n        this.moveTo(xy[0], xy[1]);\n        var step = 1 / n;\n        for (var t = step; t <= 1; t += step) {\n            var xy_1 = this.deCasteljau(points, t);\n            this.lineTo(xy_1[0], xy_1[1]);\n        }\n    };\n    /**\n     * Adds a quadratic curve segment to the path definition.\n     * Note: the given quadratic segment is converted and stored as a cubic one.\n     * @param cx x-component of the curve's control point\n     * @param cy y-component of the curve's control point\n     * @param x x-component of the end point\n     * @param y y-component of the end point\n     */\n    Path2D.prototype.quadraticCurveTo = function (cx, cy, x, y) {\n        if (!this.xy) {\n            this.moveTo(cx, cy);\n        }\n        // See https://pomax.github.io/bezierinfo/#reordering\n        this.cubicCurveTo((this.xy[0] + 2 * cx) / 3, (this.xy[1] + 2 * cy) / 3, // 1/3 start + 2/3 control\n        (2 * cx + x) / 3, (2 * cy + y) / 3, // 2/3 control + 1/3 end\n        x, y);\n    };\n    Path2D.prototype.cubicCurveTo = function (cx1, cy1, cx2, cy2, x, y) {\n        if (!this.xy) {\n            this.moveTo(cx1, cy1);\n        }\n        this.commands.push('C');\n        this.params.push(cx1, cy1, cx2, cy2, x, y);\n        this.xy[0] = x;\n        this.xy[1] = y;\n    };\n    Object.defineProperty(Path2D.prototype, \"closedPath\", {\n        get: function () {\n            return this._closedPath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path2D.prototype.closePath = function () {\n        if (this.xy) {\n            this.xy = undefined;\n            this.commands.push('Z');\n            this._closedPath = true;\n        }\n    };\n    Path2D.prototype.clear = function (_a) {\n        var trackChanges = (_a === void 0 ? { trackChanges: false } : _a).trackChanges;\n        if (trackChanges) {\n            this.previousCommands = this.commands;\n            this.previousParams = this.params;\n            this.previousClosedPath = this._closedPath;\n            this.commands = [];\n            this.params = [];\n        }\n        else {\n            this.commands.length = 0;\n            this.params.length = 0;\n        }\n        this.xy = undefined;\n        this._closedPath = false;\n    };\n    Path2D.prototype.isPointInPath = function (x, y) {\n        var commands = this.commands;\n        var params = this.params;\n        var cn = commands.length;\n        // Hit testing using ray casting method, where the ray's origin is some point\n        // outside the path. In this case, an offscreen point that is remote enough, so that\n        // even if the path itself is large and is partially offscreen, the ray's origin\n        // will likely be outside the path anyway. To test if the given point is inside the\n        // path or not, we cast a ray from the origin to the given point and check the number\n        // of intersections of this segment with the path. If the number of intersections is\n        // even, then the ray both entered and exited the path an equal number of times,\n        // therefore the point is outside the path, and inside the path, if the number of\n        // intersections is odd. Since the path is compound, we check if the ray segment\n        // intersects with each of the path's segments, which can be either a line segment\n        // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\n        // points).\n        var ox = -10000;\n        var oy = -10000;\n        // the starting point of the  current path\n        var sx = NaN;\n        var sy = NaN;\n        // the previous point of the current path\n        var px = 0;\n        var py = 0;\n        var intersectionCount = 0;\n        for (var ci = 0, pi = 0; ci < cn; ci++) {\n            switch (commands[ci]) {\n                case 'M':\n                    if (!isNaN(sx)) {\n                        if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n                            intersectionCount++;\n                        }\n                    }\n                    px = params[pi++];\n                    sx = px;\n                    py = params[pi++];\n                    sy = py;\n                    break;\n                case 'L':\n                    if (segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y)) {\n                        intersectionCount++;\n                    }\n                    px = params[pi - 2];\n                    py = params[pi - 1];\n                    break;\n                case 'C':\n                    intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], ox, oy, x, y).length;\n                    px = params[pi - 2];\n                    py = params[pi - 1];\n                    break;\n                case 'Z':\n                    if (!isNaN(sx)) {\n                        if (segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n                            intersectionCount++;\n                        }\n                    }\n                    break;\n            }\n        }\n        return intersectionCount % 2 === 1;\n    };\n    /**\n     * Returns an array of sub-paths of this Path,\n     * where each sub-path is represented exclusively by cubic segments.\n     */\n    Path2D.prototype.toCubicPaths = function () {\n        // Each sub-path is an array of `(n * 3 + 1) * 2` numbers,\n        // where `n` is the number of segments.\n        var paths = [];\n        var params = this.params;\n        // current path\n        var path;\n        // the starting point of the  current path\n        var sx;\n        var sy;\n        // the previous point of the current path\n        var px;\n        var py;\n        var i = 0; // current parameter\n        this.commands.forEach(function (command) {\n            switch (command) {\n                case 'M':\n                    px = params[i++];\n                    py = params[i++];\n                    sx = px;\n                    sy = py;\n                    paths.push([sx, sy]);\n                    break;\n                case 'L':\n                    var x = params[i++];\n                    var y = params[i++];\n                    // Place control points along the line `a + (b - a) * t`\n                    // at t = 1/3 and 2/3:\n                    path.push((px + px + x) / 3, (py + py + y) / 3, (px + x + x) / 3, (py + y + y) / 3, x, y);\n                    px = x;\n                    py = y;\n                    break;\n                case 'C':\n                    path.push(params[i++], params[i++], params[i++], params[i++], params[i++], params[i++]);\n                    px = params[i - 2];\n                    py = params[i - 1];\n                    break;\n                case 'Z':\n                    path.push((px + px + sx) / 3, (py + py + sy) / 3, (px + sx + sx) / 3, (py + sy + sy) / 3, sx, sy);\n                    px = sx;\n                    py = sy;\n                    break;\n            }\n        });\n        return paths;\n    };\n    Path2D.cubicPathToString = function (path) {\n        var n = path.length;\n        if (!(n % 2 === 0 && (n / 2 - 1) / 2 >= 1)) {\n            throw new Error('Invalid path.');\n        }\n        return 'M' + path.slice(0, 2).join(',') + 'C' + path.slice(2).join(',');\n    };\n    return Path2D;\n}());\nexport { Path2D };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}