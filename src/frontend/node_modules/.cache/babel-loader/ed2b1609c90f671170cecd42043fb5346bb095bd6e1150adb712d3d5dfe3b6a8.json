{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nexports.__esModule = true;\nvar types_1 = require(\"../../util/types\");\nvar model_1 = require(\"../../util/model\");\nvar util_1 = require(\"zrender/lib/core/util\");\nvar dataProvider_1 = require(\"./dataProvider\");\nvar dataValueHelper_1 = require(\"./dataValueHelper\");\nvar sourceHelper_1 = require(\"./sourceHelper\");\nvar log_1 = require(\"../../util/log\");\nvar Source_1 = require(\"../Source\");\nvar ExternalSource = function () {\n  function ExternalSource() {}\n  ExternalSource.prototype.getRawData = function () {\n    throw new Error('not supported');\n  };\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    throw new Error('not supported');\n  };\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return dataValueHelper_1.parseDataValue(rawVal, dimInfo);\n  };\n  return ExternalSource;\n}();\nexports.ExternalSource = ExternalSource;\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n  if (dimsDef) {\n    util_1.each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n      if (name != null) {\n        var errMsg = '';\n        if (util_1.hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = 'dimension name \"' + name + '\" duplicated.';\n          }\n          log_1.throwError(errMsg);\n        }\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n  var rawItemGetter = dataProvider_1.getRawSourceItemGetter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n    extSource.getRawData = util_1.bind(getRawData, null, internalSource);\n  }\n  extSource.cloneRawData = util_1.bind(cloneRawData, null, internalSource);\n  var rawCounter = dataProvider_1.getRawSourceDataCounter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = util_1.bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = dataProvider_1.getRawSourceValueGetter(sourceFormat);\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n    var dimDef = dimensions[dimIndex];\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n  extSource.getDimensionInfo = util_1.bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = util_1.bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n  if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS || !data || util_1.isArray(data) && !data.length) {\n    return upstream.data;\n  }\n  var errMsg = '';\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n  }\n  log_1.throwError(errMsg);\n}\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n  if (!data) {\n    return data;\n  } else if (util_1.isArray(data) && !data.length) {\n    return [];\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(data[i].slice());\n    }\n    return result;\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(util_1.extend({}, data[i]));\n    }\n    return result;\n  }\n}\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n  if (typeof dim === 'number' || !isNaN(dim) && !util_1.hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (util_1.hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\nfunction cloneAllDimensionInfo(dimensions) {\n  return util_1.clone(dimensions);\n}\nvar externalTransformMap = util_1.createHashMap();\nfunction registerExternalTransform(externalTransform) {\n  externalTransform = util_1.clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n    log_1.throwError(errMsg);\n  }\n  var typeParsed = type.split(':');\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n    log_1.throwError(errMsg);\n  }\n  var isBuiltIn = false;\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexports.registerExternalTransform = registerExternalTransform;\nfunction applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = model_1.normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n    log_1.throwError(errMsg);\n  }\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n  return sourceList;\n}\nexports.applyDataTransform = applyDataTransform;\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {\n  var errMsg = '';\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n    log_1.throwError(errMsg);\n  }\n  if (!util_1.isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n    log_1.throwError(errMsg);\n  }\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n    log_1.throwError(errMsg);\n  }\n  var extUpSourceList = util_1.map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = model_1.normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: util_1.clone(transOption.config)\n  }));\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = util_1.map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', log_1.makePrintable(extSource.data), '- transform result dimensions:', log_1.makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log_1.consoleLog(printStrArr);\n    }\n  }\n  return util_1.map(resultList, function (result) {\n    var errMsg = '';\n    if (!util_1.isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n      log_1.throwError(errMsg);\n    }\n    var resultData = result.data;\n    if (resultData != null) {\n      if (!util_1.isObject(resultData) && !util_1.isArrayLike(resultData)) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Result data should be object or array in data transform.';\n        }\n        log_1.throwError(errMsg);\n      }\n    } else {\n      resultData = upSourceList[0].data;\n    }\n    var resultMetaRawOption = sourceHelper_1.inheritSourceMetaRawOption(upSourceList[0], {\n      seriesLayoutBy: types_1.SERIES_LAYOUT_BY_COLUMN,\n      sourceHeader: 0,\n      dimensions: result.dimensions\n    });\n    return Source_1.createSource(resultData, resultMetaRawOption, null, null);\n  });\n}","map":{"version":3,"names":["exports","__esModule","types_1","require","model_1","util_1","dataProvider_1","dataValueHelper_1","sourceHelper_1","log_1","Source_1","ExternalSource","prototype","getRawData","Error","getRawDataItem","dataIndex","cloneRawData","getDimensionInfo","dim","cloneAllDimensionInfo","count","retrieveValue","dimIndex","retrieveValueFromItem","dataItem","convertValue","rawVal","dimInfo","parseDataValue","createExternalSource","internalSource","externalTransform","extSource","data","sourceFormat","sourceHeaderCount","startIndex","dimensions","dimsByName","dimsDef","dimensionsDefine","each","dimDef","idx","name","dimDefExt","index","displayName","push","errMsg","hasOwn","process","env","NODE_ENV","throwError","i","dimensionsDetectedCount","rawItemGetter","getRawSourceItemGetter","SERIES_LAYOUT_BY_COLUMN","__isBuiltIn","bind","rawCounter","getRawSourceDataCounter","rawValueGetter","getRawSourceValueGetter","rawItem","upstream","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","isArray","length","result","len","slice","extend","isNaN","clone","externalTransformMap","createHashMap","registerExternalTransform","type","typeParsed","split","isBuiltIn","set","applyDataTransform","rawTransOption","sourceList","infoForPrint","pipedTransOption","normalizeToArray","pipeLen","transOption","applySingleDataTransform","Math","max","upSourceList","pipeIndex","isObject","transType","get","extUpSourceList","map","upSource","resultList","transform","upstreamList","config","print","printStrArr","pipeIndexStr","datasetIndex","makePrintable","join","consoleLog","resultData","isArrayLike","resultMetaRawOption","inheritSourceMetaRawOption","seriesLayoutBy","sourceHeader","createSource"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/echarts/lib/data/helper/transform.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar types_1 = require(\"../../util/types\");\n\nvar model_1 = require(\"../../util/model\");\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar dataProvider_1 = require(\"./dataProvider\");\n\nvar dataValueHelper_1 = require(\"./dataValueHelper\");\n\nvar sourceHelper_1 = require(\"./sourceHelper\");\n\nvar log_1 = require(\"../../util/log\");\n\nvar Source_1 = require(\"../Source\");\n\nvar ExternalSource = function () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return dataValueHelper_1.parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexports.ExternalSource = ExternalSource;\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    util_1.each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n\n      if (name != null) {\n        var errMsg = '';\n\n        if (util_1.hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          log_1.throwError(errMsg);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n\n  var rawItemGetter = dataProvider_1.getRawSourceItemGetter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = util_1.bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = util_1.bind(cloneRawData, null, internalSource);\n  var rawCounter = dataProvider_1.getRawSourceDataCounter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = util_1.bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = dataProvider_1.getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex];\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = util_1.bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = util_1.bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS || !data || util_1.isArray(data) && !data.length) {\n    return upstream.data;\n  }\n\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n  }\n\n  log_1.throwError(errMsg);\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!data) {\n    return data;\n  } else if (util_1.isArray(data) && !data.length) {\n    return [];\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(util_1.extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n\n  if (typeof dim === 'number' || !isNaN(dim) && !util_1.hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (util_1.hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return util_1.clone(dimensions);\n}\n\nvar externalTransformMap = util_1.createHashMap();\n\nfunction registerExternalTransform(externalTransform) {\n  externalTransform = util_1.clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\n\nexports.registerExternalTransform = registerExternalTransform;\n\nfunction applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = model_1.normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nexports.applyDataTransform = applyDataTransform;\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  if (!util_1.isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var extUpSourceList = util_1.map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = model_1.normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: util_1.clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = util_1.map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', log_1.makePrintable(extSource.data), '- transform result dimensions:', log_1.makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log_1.consoleLog(printStrArr);\n    }\n  }\n\n  return util_1.map(resultList, function (result) {\n    var errMsg = '';\n\n    if (!util_1.isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      log_1.throwError(errMsg);\n    }\n\n    var resultData = result.data;\n\n    if (resultData != null) {\n      if (!util_1.isObject(resultData) && !util_1.isArrayLike(resultData)) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Result data should be object or array in data transform.';\n        }\n\n        log_1.throwError(errMsg);\n      }\n    } else {\n      resultData = upSourceList[0].data;\n    }\n\n    var resultMetaRawOption = sourceHelper_1.inheritSourceMetaRawOption(upSourceList[0], {\n      seriesLayoutBy: types_1.SERIES_LAYOUT_BY_COLUMN,\n      sourceHeader: 0,\n      dimensions: result.dimensions\n    });\n    return Source_1.createSource(resultData, resultMetaRawOption, null, null);\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}