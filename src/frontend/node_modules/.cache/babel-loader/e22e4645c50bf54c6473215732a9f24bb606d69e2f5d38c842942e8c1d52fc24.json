{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { tickStep } from './ticks';\nfunction formatDefault(x, p) {\n  var xs = x.toPrecision(p);\n  var i0 = -1;\n  var i1 = 0;\n  var exit = false;\n  for (var n = xs.length, i = 1; !exit && i < n; ++i) {\n    switch (xs[i]) {\n      case '.':\n        i0 = i1 = i;\n        break;\n      case '0':\n        if (i0 === 0) i0 = i;\n        i1 = i;\n        break;\n      case 'e':\n        exit = true;\n        break;\n      default:\n        if (i0 > 0) i0 = 0;\n        break;\n    }\n  }\n  return i0 > 0 ? xs.slice(0, i0) + xs.slice(i1 + 1) : xs;\n}\nvar formatTypes = {\n  '': formatDefault,\n  // Multiply by 100, and then decimal notation with a percent sign.\n  '%': function (x, p) {\n    return (x * 100).toFixed(p);\n  },\n  // Binary notation, rounded to integer.\n  b: function (x) {\n    return Math.round(x).toString(2);\n  },\n  // Converts the integer to the corresponding unicode character before printing.\n  c: function (x) {\n    return String(x);\n  },\n  // Decimal notation, rounded to integer.\n  d: formatDecimal,\n  // Exponent notation.\n  e: function (x, p) {\n    return x.toExponential(p);\n  },\n  // Fixed point notation.\n  f: function (x, p) {\n    return x.toFixed(p);\n  },\n  // Either decimal or exponent notation, rounded to significant digits.\n  g: function (x, p) {\n    return x.toPrecision(p);\n  },\n  // Octal notation, rounded to integer.\n  o: function (x) {\n    return Math.round(x).toString(8);\n  },\n  // Multiply by 100, round to significant digits, and then decimal notation with a percent sign.\n  p: function (x, p) {\n    return formatRounded(x * 100, p);\n  },\n  // Decimal notation, rounded to significant digits.\n  r: formatRounded,\n  // Decimal notation with a SI prefix, rounded to significant digits.\n  s: formatPrefixAuto,\n  // Hexadecimal notation, using upper-case letters, rounded to integer.\n  X: function (x) {\n    return Math.round(x).toString(16).toUpperCase();\n  },\n  // Hexadecimal notation, using lower-case letters, rounded to integer.\n  x: function (x) {\n    return Math.round(x).toString(16);\n  }\n};\nvar prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '\\xB5', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\n/**\n * [[fill]align][sign][#][0][width][grouping_option][.precision][type]\n */\nvar FormatSpecifier = /** @class */function () {\n  function FormatSpecifier(specifier) {\n    if (specifier instanceof FormatSpecifier) {\n      this.fill = specifier.fill;\n      this.align = specifier.align;\n      this.sign = specifier.sign;\n      this.symbol = specifier.symbol;\n      this.zero = specifier.zero;\n      this.width = specifier.width;\n      this.comma = specifier.comma;\n      this.precision = specifier.precision;\n      this.trim = specifier.trim;\n      this.type = specifier.type;\n      this.string = specifier.string;\n    } else {\n      this.fill = specifier.fill === undefined ? ' ' : String(specifier.fill);\n      this.align = specifier.align === undefined ? '>' : String(specifier.align);\n      this.sign = specifier.sign === undefined ? '-' : String(specifier.sign);\n      this.symbol = specifier.symbol === undefined ? '' : String(specifier.symbol);\n      this.zero = !!specifier.zero;\n      this.width = specifier.width === undefined ? undefined : +specifier.width;\n      this.comma = !!specifier.comma;\n      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;\n      this.trim = !!specifier.trim;\n      this.type = specifier.type === undefined ? '' : String(specifier.type);\n      this.string = specifier.string;\n    }\n  }\n  return FormatSpecifier;\n}();\nexport { FormatSpecifier };\n// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\nvar interpolateRegEx = /(#\\{(.*?)\\})/g;\nexport function makeFormatSpecifier(specifier) {\n  if (specifier instanceof FormatSpecifier) {\n    return new FormatSpecifier(specifier);\n  }\n  var found = false;\n  var string = specifier.replace(interpolateRegEx, function () {\n    if (!found) {\n      specifier = arguments[2];\n      found = true;\n    }\n    return '#{}';\n  });\n  var match = formatRegEx.exec(specifier);\n  if (!match) {\n    throw new Error(\"Invalid format: \" + specifier);\n  }\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10],\n    string: found ? string : undefined\n  });\n}\nexport function tickFormat(start, stop, count, specifier) {\n  var step = tickStep(start, stop, count);\n  var formatSpecifier = makeFormatSpecifier(specifier == undefined ? ',f' : specifier);\n  var precision;\n  switch (formatSpecifier.type) {\n    case 's':\n      {\n        var value = Math.max(Math.abs(start), Math.abs(stop));\n        if (formatSpecifier.precision == null) {\n          precision = precisionPrefix(step, value);\n          if (!isNaN(precision)) {\n            formatSpecifier.precision = precision;\n          }\n        }\n        return formatPrefix(formatSpecifier, value);\n      }\n    case '':\n    case 'e':\n    case 'g':\n    case 'p':\n    case 'r':\n      {\n        if (formatSpecifier.precision == null) {\n          precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)));\n          if (!isNaN(precision)) {\n            formatSpecifier.precision = precision - +(formatSpecifier.type === 'e');\n          }\n        }\n        break;\n      }\n    case 'f':\n    case '%':\n      {\n        if (formatSpecifier.precision == null) {\n          precision = precisionFixed(step);\n          if (!isNaN(precision)) {\n            formatSpecifier.precision = precision - +(formatSpecifier.type === '%') * 2;\n          }\n        }\n        break;\n      }\n  }\n  return format(formatSpecifier);\n}\nvar prefixExponent;\nfunction formatPrefixAuto(x, p) {\n  if (p === void 0) {\n    p = 0;\n  }\n  var d = formatDecimalParts(x, p);\n  if (!d) {\n    return String(x);\n  }\n  var coefficient = d[0];\n  var exponent = d[1];\n  prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3;\n  var i = exponent - prefixExponent + 1;\n  var n = coefficient.length;\n  if (i === n) {\n    return coefficient;\n  } else if (i > n) {\n    return coefficient + new Array(i - n + 1).join('0');\n  } else if (i > 0) {\n    return coefficient.slice(0, i) + '.' + coefficient.slice(i);\n  } else {\n    var parts = formatDecimalParts(x, Math.max(0, p + i - 1));\n    return '0.' + new Array(1 - i).join('0') + parts[0]; // less than 1y!\n  }\n}\n\nfunction formatDecimal(x) {\n  x = Math.round(x);\n  return Math.abs(x) >= 1e21 ? x.toLocaleString('en').replace(/,/g, '') : x.toString(10);\n}\nfunction formatGroup(grouping, thousands) {\n  return function (value, width) {\n    var t = [];\n    var i = value.length;\n    var j = 0;\n    var g = grouping[0];\n    var length = 0;\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) {\n        g = Math.max(1, width - length);\n      }\n      i -= g;\n      t.push(value.substring(i, i + g));\n      if ((length += g + 1) > width) {\n        break;\n      }\n      j = (j + 1) % grouping.length;\n      g = grouping[j];\n    }\n    t.reverse();\n    return t.join(thousands);\n  };\n}\nexport function formatNumerals(numerals) {\n  return function (value) {\n    return value.replace(/\\d/g, function (i) {\n      return numerals[+i];\n    });\n  };\n}\n// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nfunction formatTrim(s) {\n  var i0 = -1,\n    i1 = 0;\n  var exit = false;\n  for (var n = s.length, i = 1; !exit && i < n; ++i) {\n    switch (s[i]) {\n      case '.':\n        i0 = i1 = i;\n        break;\n      case '0':\n        if (i0 === 0) i0 = i;\n        i1 = i;\n        break;\n      default:\n        if (!+s[i]) {\n          exit = true;\n          break;\n        }\n        if (i0 > 0) i0 = 0;\n        break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\nfunction formatRounded(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) {\n    return String(x);\n  }\n  var coefficient = d[0];\n  var exponent = d[1];\n  if (exponent < 0) {\n    return '0.' + new Array(-exponent).join('0') + coefficient;\n  } else {\n    if (coefficient.length > exponent + 1) {\n      return coefficient.slice(0, exponent + 1) + '.' + coefficient.slice(exponent + 1);\n    } else {\n      return coefficient + new Array(exponent - coefficient.length + 2).join('0');\n    }\n  }\n}\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimalParts(1.23) returns ['123', 0].\nexport function formatDecimalParts(x, p) {\n  var sx = p ? x.toExponential(p - 1) : x.toExponential();\n  var i = sx.indexOf('e');\n  if (i < 0) {\n    // NaN, ±Infinity\n    return undefined;\n  }\n  var coefficient = sx.slice(0, i);\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +sx.slice(i + 1)];\n}\nfunction identity(x) {\n  return x;\n}\nexport var formatDefaultLocale;\nexport var format;\nexport var formatPrefix;\ndefaultLocale({\n  thousands: ',',\n  grouping: [3],\n  currency: ['$', '']\n});\nfunction defaultLocale(definition) {\n  formatDefaultLocale = formatLocale(definition);\n  format = formatDefaultLocale.format;\n  formatPrefix = formatDefaultLocale.formatPrefix;\n}\nfunction exponent(x) {\n  var parts = formatDecimalParts(Math.abs(x));\n  if (parts) {\n    return parts[1];\n  }\n  return NaN;\n}\nfunction precisionFixed(step) {\n  return Math.max(0, -exponent(Math.abs(step)));\n}\nfunction precisionPrefix(step, value) {\n  var x = Math.floor(exponent(value) / 3);\n  x = Math.min(8, x);\n  x = Math.max(-8, x);\n  return Math.max(0, x * 3 - exponent(Math.abs(step)));\n}\nfunction precisionRound(step, max) {\n  step = Math.abs(step);\n  max = Math.abs(max) - step;\n  return Math.max(0, exponent(max) - exponent(step)) + 1;\n}\nexport function formatLocale(locale) {\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(locale.grouping.map(Number), String(locale.thousands));\n  var currencyPrefix = locale.currency === undefined ? '' : String(locale.currency[0]);\n  var currencySuffix = locale.currency === undefined ? '' : String(locale.currency[1]);\n  var decimal = locale.decimal === undefined ? '.' : String(locale.decimal);\n  var numerals = locale.numerals === undefined ? identity : formatNumerals(locale.numerals.map(String));\n  var percent = locale.percent === undefined ? '%' : String(locale.percent);\n  var minus = locale.minus === undefined ? '\\u2212' : String(locale.minus);\n  var nan = locale.nan === undefined ? 'NaN' : String(locale.nan);\n  function newFormat(specifier) {\n    var formatSpecifier = makeFormatSpecifier(specifier);\n    var fill = formatSpecifier.fill;\n    var align = formatSpecifier.align;\n    var sign = formatSpecifier.sign;\n    var symbol = formatSpecifier.symbol;\n    var zero = formatSpecifier.zero;\n    var width = formatSpecifier.width;\n    var comma = formatSpecifier.comma;\n    var precision = formatSpecifier.precision;\n    var trim = formatSpecifier.trim;\n    var type = formatSpecifier.type;\n    // The 'n' type is an alias for ',g'.\n    if (type === 'n') {\n      comma = true;\n      type = 'g';\n    } else if (!formatTypes[type]) {\n      // The '' type, and any invalid type, is an alias for '.12~g'.\n      if (precision === undefined) {\n        precision = 12;\n      }\n      trim = true;\n      type = 'g';\n    }\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || fill === '0' && align === '=') {\n      zero = true;\n      fill = '0';\n      align = '=';\n    }\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === '$' ? currencyPrefix : symbol === '#' && /[boxX]/.test(type) ? '0' + type.toLowerCase() : '';\n    var suffix = symbol === '$' ? currencySuffix : /[%p]/.test(type) ? percent : '';\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type];\n    var maybeSuffix = /[defgprs%]/.test(type);\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    if (precision === undefined) {\n      precision = 6;\n    } else if (/[gprs]/.test(type)) {\n      precision = Math.max(1, Math.min(21, precision));\n    } else {\n      precision = Math.max(0, Math.min(20, precision));\n    }\n    function format(x) {\n      var valuePrefix = prefix;\n      var valueSuffix = suffix;\n      var value;\n      if (type === 'c') {\n        valueSuffix = formatType(+x) + valueSuffix;\n        value = '';\n      } else {\n        var nx = +x;\n        // Determine the sign. -0 is not less than 0, but 1 / -0 is!\n        var valueNegative = x < 0 || 1 / nx < 0;\n        // Perform the initial formatting.\n        value = isNaN(nx) ? nan : formatType(Math.abs(nx), precision);\n        // Trim insignificant zeros.\n        if (trim) {\n          value = formatTrim(value);\n        }\n        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\n        if (valueNegative && +value === 0 && sign !== '+') {\n          valueNegative = false;\n        }\n        // Compute the prefix and suffix.\n        var signPrefix = valueNegative ? sign === '(' ? sign : minus : sign === '-' || sign === '(' ? '' : sign;\n        var signSuffix = valueNegative && sign === '(' ? ')' : '';\n        valuePrefix = signPrefix + valuePrefix;\n        valueSuffix = (type === 's' ? prefixes[8 + prefixExponent / 3] : '') + valueSuffix + signSuffix;\n        // Break the formatted value into the integer “value” part that can be\n        // grouped, and fractional or exponential “suffix” part that is not.\n        if (maybeSuffix) {\n          for (var i = 0, n = value.length; i < n; i++) {\n            var c = value.charCodeAt(i);\n            if (48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n      // If the fill character is not '0', grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length;\n      var padding = length < width ? new Array(width - length + 1).join(fill) : '';\n      // If the fill character is '0', grouping is applied after padding.\n      if (comma && zero) {\n        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity);\n        padding = '';\n      }\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case '<':\n          value = valuePrefix + value + valueSuffix + padding;\n          break;\n        case '=':\n          value = valuePrefix + padding + value + valueSuffix;\n          break;\n        case '^':\n          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n          break;\n        default:\n          value = padding + valuePrefix + value + valueSuffix;\n          break;\n      }\n      var string = formatSpecifier.string;\n      if (string) {\n        return string.replace(interpolateRegEx, function () {\n          return numerals(value);\n        });\n      }\n      return numerals(value);\n    }\n    return format;\n  }\n  function formatPrefix(specifier, value) {\n    var formatSpecifier = makeFormatSpecifier(specifier);\n    formatSpecifier.type = 'f';\n    var f = newFormat(formatSpecifier);\n    var e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3;\n    var k = Math.pow(10, -e);\n    var prefix = prefixes[8 + e / 3];\n    return function (value) {\n      return f(k * +value) + prefix;\n    };\n  }\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}","map":{"version":3,"names":["tickStep","formatDefault","x","p","xs","toPrecision","i0","i1","exit","n","length","i","slice","formatTypes","toFixed","b","Math","round","toString","c","String","d","formatDecimal","e","toExponential","f","g","o","formatRounded","r","s","formatPrefixAuto","X","toUpperCase","prefixes","FormatSpecifier","specifier","fill","align","sign","symbol","zero","width","comma","precision","trim","type","string","undefined","formatRegEx","interpolateRegEx","makeFormatSpecifier","found","replace","arguments","match","exec","Error","tickFormat","start","stop","count","step","formatSpecifier","value","max","abs","precisionPrefix","isNaN","formatPrefix","precisionRound","precisionFixed","format","prefixExponent","formatDecimalParts","coefficient","exponent","min","floor","Array","join","parts","toLocaleString","formatGroup","grouping","thousands","t","j","push","substring","reverse","formatNumerals","numerals","formatTrim","sx","indexOf","identity","formatDefaultLocale","defaultLocale","currency","definition","formatLocale","NaN","locale","group","map","Number","currencyPrefix","currencySuffix","decimal","percent","minus","nan","newFormat","prefix","test","toLowerCase","suffix","formatType","maybeSuffix","valuePrefix","valueSuffix","nx","valueNegative","signPrefix","signSuffix","charCodeAt","Infinity","padding","k","pow"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/util/numberFormat.js"],"sourcesContent":["import { tickStep } from './ticks';\nfunction formatDefault(x, p) {\n    var xs = x.toPrecision(p);\n    var i0 = -1;\n    var i1 = 0;\n    var exit = false;\n    for (var n = xs.length, i = 1; !exit && i < n; ++i) {\n        switch (xs[i]) {\n            case '.':\n                i0 = i1 = i;\n                break;\n            case '0':\n                if (i0 === 0)\n                    i0 = i;\n                i1 = i;\n                break;\n            case 'e':\n                exit = true;\n                break;\n            default:\n                if (i0 > 0)\n                    i0 = 0;\n                break;\n        }\n    }\n    return i0 > 0 ? xs.slice(0, i0) + xs.slice(i1 + 1) : xs;\n}\nvar formatTypes = {\n    '': formatDefault,\n    // Multiply by 100, and then decimal notation with a percent sign.\n    '%': function (x, p) { return (x * 100).toFixed(p); },\n    // Binary notation, rounded to integer.\n    b: function (x) { return Math.round(x).toString(2); },\n    // Converts the integer to the corresponding unicode character before printing.\n    c: function (x) { return String(x); },\n    // Decimal notation, rounded to integer.\n    d: formatDecimal,\n    // Exponent notation.\n    e: function (x, p) { return x.toExponential(p); },\n    // Fixed point notation.\n    f: function (x, p) { return x.toFixed(p); },\n    // Either decimal or exponent notation, rounded to significant digits.\n    g: function (x, p) { return x.toPrecision(p); },\n    // Octal notation, rounded to integer.\n    o: function (x) { return Math.round(x).toString(8); },\n    // Multiply by 100, round to significant digits, and then decimal notation with a percent sign.\n    p: function (x, p) { return formatRounded(x * 100, p); },\n    // Decimal notation, rounded to significant digits.\n    r: formatRounded,\n    // Decimal notation with a SI prefix, rounded to significant digits.\n    s: formatPrefixAuto,\n    // Hexadecimal notation, using upper-case letters, rounded to integer.\n    X: function (x) { return Math.round(x).toString(16).toUpperCase(); },\n    // Hexadecimal notation, using lower-case letters, rounded to integer.\n    x: function (x) { return Math.round(x).toString(16); },\n};\nvar prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '\\xB5', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\n/**\n * [[fill]align][sign][#][0][width][grouping_option][.precision][type]\n */\nvar FormatSpecifier = /** @class */ (function () {\n    function FormatSpecifier(specifier) {\n        if (specifier instanceof FormatSpecifier) {\n            this.fill = specifier.fill;\n            this.align = specifier.align;\n            this.sign = specifier.sign;\n            this.symbol = specifier.symbol;\n            this.zero = specifier.zero;\n            this.width = specifier.width;\n            this.comma = specifier.comma;\n            this.precision = specifier.precision;\n            this.trim = specifier.trim;\n            this.type = specifier.type;\n            this.string = specifier.string;\n        }\n        else {\n            this.fill = specifier.fill === undefined ? ' ' : String(specifier.fill);\n            this.align = specifier.align === undefined ? '>' : String(specifier.align);\n            this.sign = specifier.sign === undefined ? '-' : String(specifier.sign);\n            this.symbol = specifier.symbol === undefined ? '' : String(specifier.symbol);\n            this.zero = !!specifier.zero;\n            this.width = specifier.width === undefined ? undefined : +specifier.width;\n            this.comma = !!specifier.comma;\n            this.precision = specifier.precision === undefined ? undefined : +specifier.precision;\n            this.trim = !!specifier.trim;\n            this.type = specifier.type === undefined ? '' : String(specifier.type);\n            this.string = specifier.string;\n        }\n    }\n    return FormatSpecifier;\n}());\nexport { FormatSpecifier };\n// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\nvar interpolateRegEx = /(#\\{(.*?)\\})/g;\nexport function makeFormatSpecifier(specifier) {\n    if (specifier instanceof FormatSpecifier) {\n        return new FormatSpecifier(specifier);\n    }\n    var found = false;\n    var string = specifier.replace(interpolateRegEx, function () {\n        if (!found) {\n            specifier = arguments[2];\n            found = true;\n        }\n        return '#{}';\n    });\n    var match = formatRegEx.exec(specifier);\n    if (!match) {\n        throw new Error(\"Invalid format: \" + specifier);\n    }\n    return new FormatSpecifier({\n        fill: match[1],\n        align: match[2],\n        sign: match[3],\n        symbol: match[4],\n        zero: match[5],\n        width: match[6],\n        comma: match[7],\n        precision: match[8] && match[8].slice(1),\n        trim: match[9],\n        type: match[10],\n        string: found ? string : undefined,\n    });\n}\nexport function tickFormat(start, stop, count, specifier) {\n    var step = tickStep(start, stop, count);\n    var formatSpecifier = makeFormatSpecifier(specifier == undefined ? ',f' : specifier);\n    var precision;\n    switch (formatSpecifier.type) {\n        case 's': {\n            var value = Math.max(Math.abs(start), Math.abs(stop));\n            if (formatSpecifier.precision == null) {\n                precision = precisionPrefix(step, value);\n                if (!isNaN(precision)) {\n                    formatSpecifier.precision = precision;\n                }\n            }\n            return formatPrefix(formatSpecifier, value);\n        }\n        case '':\n        case 'e':\n        case 'g':\n        case 'p':\n        case 'r': {\n            if (formatSpecifier.precision == null) {\n                precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)));\n                if (!isNaN(precision)) {\n                    formatSpecifier.precision = precision - +(formatSpecifier.type === 'e');\n                }\n            }\n            break;\n        }\n        case 'f':\n        case '%': {\n            if (formatSpecifier.precision == null) {\n                precision = precisionFixed(step);\n                if (!isNaN(precision)) {\n                    formatSpecifier.precision = precision - +(formatSpecifier.type === '%') * 2;\n                }\n            }\n            break;\n        }\n    }\n    return format(formatSpecifier);\n}\nvar prefixExponent;\nfunction formatPrefixAuto(x, p) {\n    if (p === void 0) { p = 0; }\n    var d = formatDecimalParts(x, p);\n    if (!d) {\n        return String(x);\n    }\n    var coefficient = d[0];\n    var exponent = d[1];\n    prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3;\n    var i = exponent - prefixExponent + 1;\n    var n = coefficient.length;\n    if (i === n) {\n        return coefficient;\n    }\n    else if (i > n) {\n        return coefficient + new Array(i - n + 1).join('0');\n    }\n    else if (i > 0) {\n        return coefficient.slice(0, i) + '.' + coefficient.slice(i);\n    }\n    else {\n        var parts = formatDecimalParts(x, Math.max(0, p + i - 1));\n        return '0.' + new Array(1 - i).join('0') + parts[0]; // less than 1y!\n    }\n}\nfunction formatDecimal(x) {\n    x = Math.round(x);\n    return Math.abs(x) >= 1e21 ? x.toLocaleString('en').replace(/,/g, '') : x.toString(10);\n}\nfunction formatGroup(grouping, thousands) {\n    return function (value, width) {\n        var t = [];\n        var i = value.length;\n        var j = 0;\n        var g = grouping[0];\n        var length = 0;\n        while (i > 0 && g > 0) {\n            if (length + g + 1 > width) {\n                g = Math.max(1, width - length);\n            }\n            i -= g;\n            t.push(value.substring(i, i + g));\n            if ((length += g + 1) > width) {\n                break;\n            }\n            j = (j + 1) % grouping.length;\n            g = grouping[j];\n        }\n        t.reverse();\n        return t.join(thousands);\n    };\n}\nexport function formatNumerals(numerals) {\n    return function (value) { return value.replace(/\\d/g, function (i) { return numerals[+i]; }); };\n}\n// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nfunction formatTrim(s) {\n    var i0 = -1, i1 = 0;\n    var exit = false;\n    for (var n = s.length, i = 1; !exit && i < n; ++i) {\n        switch (s[i]) {\n            case '.':\n                i0 = i1 = i;\n                break;\n            case '0':\n                if (i0 === 0)\n                    i0 = i;\n                i1 = i;\n                break;\n            default:\n                if (!+s[i]) {\n                    exit = true;\n                    break;\n                }\n                if (i0 > 0)\n                    i0 = 0;\n                break;\n        }\n    }\n    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\nfunction formatRounded(x, p) {\n    var d = formatDecimalParts(x, p);\n    if (!d) {\n        return String(x);\n    }\n    var coefficient = d[0];\n    var exponent = d[1];\n    if (exponent < 0) {\n        return '0.' + new Array(-exponent).join('0') + coefficient;\n    }\n    else {\n        if (coefficient.length > exponent + 1) {\n            return coefficient.slice(0, exponent + 1) + '.' + coefficient.slice(exponent + 1);\n        }\n        else {\n            return coefficient + new Array(exponent - coefficient.length + 2).join('0');\n        }\n    }\n}\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimalParts(1.23) returns ['123', 0].\nexport function formatDecimalParts(x, p) {\n    var sx = p ? x.toExponential(p - 1) : x.toExponential();\n    var i = sx.indexOf('e');\n    if (i < 0) {\n        // NaN, ±Infinity\n        return undefined;\n    }\n    var coefficient = sx.slice(0, i);\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +sx.slice(i + 1)];\n}\nfunction identity(x) {\n    return x;\n}\nexport var formatDefaultLocale;\nexport var format;\nexport var formatPrefix;\ndefaultLocale({\n    thousands: ',',\n    grouping: [3],\n    currency: ['$', ''],\n});\nfunction defaultLocale(definition) {\n    formatDefaultLocale = formatLocale(definition);\n    format = formatDefaultLocale.format;\n    formatPrefix = formatDefaultLocale.formatPrefix;\n}\nfunction exponent(x) {\n    var parts = formatDecimalParts(Math.abs(x));\n    if (parts) {\n        return parts[1];\n    }\n    return NaN;\n}\nfunction precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n}\nfunction precisionPrefix(step, value) {\n    var x = Math.floor(exponent(value) / 3);\n    x = Math.min(8, x);\n    x = Math.max(-8, x);\n    return Math.max(0, x * 3 - exponent(Math.abs(step)));\n}\nfunction precisionRound(step, max) {\n    step = Math.abs(step);\n    max = Math.abs(max) - step;\n    return Math.max(0, exponent(max) - exponent(step)) + 1;\n}\nexport function formatLocale(locale) {\n    var group = locale.grouping === undefined || locale.thousands === undefined\n        ? identity\n        : formatGroup(locale.grouping.map(Number), String(locale.thousands));\n    var currencyPrefix = locale.currency === undefined ? '' : String(locale.currency[0]);\n    var currencySuffix = locale.currency === undefined ? '' : String(locale.currency[1]);\n    var decimal = locale.decimal === undefined ? '.' : String(locale.decimal);\n    var numerals = locale.numerals === undefined ? identity : formatNumerals(locale.numerals.map(String));\n    var percent = locale.percent === undefined ? '%' : String(locale.percent);\n    var minus = locale.minus === undefined ? '\\u2212' : String(locale.minus);\n    var nan = locale.nan === undefined ? 'NaN' : String(locale.nan);\n    function newFormat(specifier) {\n        var formatSpecifier = makeFormatSpecifier(specifier);\n        var fill = formatSpecifier.fill;\n        var align = formatSpecifier.align;\n        var sign = formatSpecifier.sign;\n        var symbol = formatSpecifier.symbol;\n        var zero = formatSpecifier.zero;\n        var width = formatSpecifier.width;\n        var comma = formatSpecifier.comma;\n        var precision = formatSpecifier.precision;\n        var trim = formatSpecifier.trim;\n        var type = formatSpecifier.type;\n        // The 'n' type is an alias for ',g'.\n        if (type === 'n') {\n            comma = true;\n            type = 'g';\n        }\n        else if (!formatTypes[type]) {\n            // The '' type, and any invalid type, is an alias for '.12~g'.\n            if (precision === undefined) {\n                precision = 12;\n            }\n            trim = true;\n            type = 'g';\n        }\n        // If zero fill is specified, padding goes after sign and before digits.\n        if (zero || (fill === '0' && align === '=')) {\n            zero = true;\n            fill = '0';\n            align = '=';\n        }\n        // Compute the prefix and suffix.\n        // For SI-prefix, the suffix is lazily computed.\n        var prefix = symbol === '$' ? currencyPrefix : symbol === '#' && /[boxX]/.test(type) ? '0' + type.toLowerCase() : '';\n        var suffix = symbol === '$' ? currencySuffix : /[%p]/.test(type) ? percent : '';\n        // What format function should we use?\n        // Is this an integer type?\n        // Can this type generate exponential notation?\n        var formatType = formatTypes[type];\n        var maybeSuffix = /[defgprs%]/.test(type);\n        // Set the default precision if not specified,\n        // or clamp the specified precision to the supported range.\n        // For significant precision, it must be in [1, 21].\n        // For fixed precision, it must be in [0, 20].\n        if (precision === undefined) {\n            precision = 6;\n        }\n        else if (/[gprs]/.test(type)) {\n            precision = Math.max(1, Math.min(21, precision));\n        }\n        else {\n            precision = Math.max(0, Math.min(20, precision));\n        }\n        function format(x) {\n            var valuePrefix = prefix;\n            var valueSuffix = suffix;\n            var value;\n            if (type === 'c') {\n                valueSuffix = formatType(+x) + valueSuffix;\n                value = '';\n            }\n            else {\n                var nx = +x;\n                // Determine the sign. -0 is not less than 0, but 1 / -0 is!\n                var valueNegative = x < 0 || 1 / nx < 0;\n                // Perform the initial formatting.\n                value = isNaN(nx) ? nan : formatType(Math.abs(nx), precision);\n                // Trim insignificant zeros.\n                if (trim) {\n                    value = formatTrim(value);\n                }\n                // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\n                if (valueNegative && +value === 0 && sign !== '+') {\n                    valueNegative = false;\n                }\n                // Compute the prefix and suffix.\n                var signPrefix = valueNegative\n                    ? sign === '('\n                        ? sign\n                        : minus\n                    : sign === '-' || sign === '('\n                        ? ''\n                        : sign;\n                var signSuffix = valueNegative && sign === '(' ? ')' : '';\n                valuePrefix = signPrefix + valuePrefix;\n                valueSuffix = (type === 's' ? prefixes[8 + prefixExponent / 3] : '') + valueSuffix + signSuffix;\n                // Break the formatted value into the integer “value” part that can be\n                // grouped, and fractional or exponential “suffix” part that is not.\n                if (maybeSuffix) {\n                    for (var i = 0, n = value.length; i < n; i++) {\n                        var c = value.charCodeAt(i);\n                        if (48 > c || c > 57) {\n                            valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                            value = value.slice(0, i);\n                            break;\n                        }\n                    }\n                }\n            }\n            // If the fill character is not '0', grouping is applied before padding.\n            if (comma && !zero)\n                value = group(value, Infinity);\n            // Compute the padding.\n            var length = valuePrefix.length + value.length + valueSuffix.length;\n            var padding = length < width ? new Array(width - length + 1).join(fill) : '';\n            // If the fill character is '0', grouping is applied after padding.\n            if (comma && zero) {\n                value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity);\n                padding = '';\n            }\n            // Reconstruct the final output based on the desired alignment.\n            switch (align) {\n                case '<':\n                    value = valuePrefix + value + valueSuffix + padding;\n                    break;\n                case '=':\n                    value = valuePrefix + padding + value + valueSuffix;\n                    break;\n                case '^':\n                    value =\n                        padding.slice(0, (length = padding.length >> 1)) +\n                            valuePrefix +\n                            value +\n                            valueSuffix +\n                            padding.slice(length);\n                    break;\n                default:\n                    value = padding + valuePrefix + value + valueSuffix;\n                    break;\n            }\n            var string = formatSpecifier.string;\n            if (string) {\n                return string.replace(interpolateRegEx, function () { return numerals(value); });\n            }\n            return numerals(value);\n        }\n        return format;\n    }\n    function formatPrefix(specifier, value) {\n        var formatSpecifier = makeFormatSpecifier(specifier);\n        formatSpecifier.type = 'f';\n        var f = newFormat(formatSpecifier);\n        var e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3;\n        var k = Math.pow(10, -e);\n        var prefix = prefixes[8 + e / 3];\n        return function (value) {\n            return f(k * +value) + prefix;\n        };\n    }\n    return {\n        format: newFormat,\n        formatPrefix: formatPrefix,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}