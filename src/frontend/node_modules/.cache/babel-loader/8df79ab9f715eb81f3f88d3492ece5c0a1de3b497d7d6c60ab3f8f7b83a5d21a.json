{"ast":null,"code":"import { windowValue } from '../util/window';\nexport var RedrawType;\n(function (RedrawType) {\n  RedrawType[RedrawType[\"NONE\"] = 0] = \"NONE\";\n  // Canvas doesn't need clearing, an incremental re-rerender is sufficient.\n  RedrawType[RedrawType[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  // Group needs clearing, a semi-incremental re-render is sufficient.\n  RedrawType[RedrawType[\"MINOR\"] = 2] = \"MINOR\";\n  // Canvas needs to be cleared for these redraw types.\n  RedrawType[RedrawType[\"MAJOR\"] = 3] = \"MAJOR\";\n})(RedrawType || (RedrawType = {}));\n/** @returns true if eval() is disabled in the current execution context. */\nfunction evalAvailable() {\n  try {\n    eval('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar EVAL_USEABLE = evalAvailable();\nexport function SceneChangeDetection(opts) {\n  var _a = opts || {},\n    _b = _a.redraw,\n    redraw = _b === void 0 ? RedrawType.TRIVIAL : _b,\n    _c = _a.type,\n    type = _c === void 0 ? 'normal' : _c,\n    changeCb = _a.changeCb,\n    convertor = _a.convertor,\n    _d = _a.checkDirtyOnAssignment,\n    checkDirtyOnAssignment = _d === void 0 ? false : _d;\n  var debug = windowValue('agChartsSceneChangeDetectionDebug') != null;\n  return function (target, key) {\n    // `target` is either a constructor (static member) or prototype (instance member)\n    var privateKey = \"__\" + key;\n    if (target[key]) {\n      return;\n    }\n    if (EVAL_USEABLE) {\n      // Optimised code-path.\n      // Remove all conditional logic from runtime - generate a setter with the exact necessary\n      // steps, as these setters are called a LOT during update cycles.\n      var setterJs = \"\\n                \" + (debug ? 'var setCount = 0;' : '') + \"\\n                function set_\" + key + \"(value) {\\n                    const oldValue = this.\" + privateKey + \";\\n                    \" + (convertor ? 'value = convertor(value);' : '') + \"\\n                    if (value !== oldValue) {\\n                        this.\" + privateKey + \" = value;\\n                        \" + (debug ? \"console.log({ t: this, property: '\" + key + \"', oldValue, value, stack: new Error().stack });\" : '') + \"\\n                        \" + (type === 'normal' ? \"this.markDirty(this, \" + redraw + \");\" : '') + \"\\n                        \" + (type === 'transform' ? \"this.markDirtyTransform(\" + redraw + \");\" : '') + \"\\n                        \" + (type === 'path' ? \"if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, \" + redraw + \"); }\" : '') + \"\\n                        \" + (type === 'font' ? \"if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, \" + redraw + \"); }\" : '') + \"\\n                        \" + (changeCb ? 'changeCb(this);' : '') + \"\\n                    }\\n                    \" + (checkDirtyOnAssignment ? \"if (value != null && value._dirty > \" + RedrawType.NONE + \") { this.markDirty(value, value._dirty); }\" : '') + \"\\n                };\\n                set_\" + key + \";\\n            \";\n      var getterJs = \"\\n                function get_\" + key + \"() {\\n                    return this.\" + privateKey + \";\\n                };\\n                get_\" + key + \";\\n            \";\n      Object.defineProperty(target, key, {\n        set: eval(setterJs),\n        get: eval(getterJs),\n        enumerable: true,\n        configurable: true\n      });\n    } else {\n      // Unoptimised but 'safe' code-path, for environments with CSP headers and no 'unsafe-eval'.\n      // We deliberately do not support debug branches found in the optimised path above, since\n      // for large data-set series performance deteriorates with every extra branch here.\n      var setter = function (value) {\n        var oldValue = this[privateKey];\n        value = convertor ? convertor(value) : value;\n        if (value !== oldValue) {\n          this[privateKey] = value;\n          if (type === 'normal') this.markDirty(this, redraw);\n          if (type === 'transform') this.markDirtyTransform(redraw);\n          if (type === 'path' && !this._dirtyPath) {\n            this._dirtyPath = true;\n            this.markDirty(this, redraw);\n          }\n          if (type === 'font' && !this._dirtyFont) {\n            this._dirtyFont = true;\n            this.markDirty(this, redraw);\n          }\n          if (changeCb) changeCb(this);\n        }\n        if (checkDirtyOnAssignment && value != null && value._dirty > RedrawType.NONE) this.markDirty(value, value._dirty);\n      };\n      var getter = function () {\n        return this[privateKey];\n      };\n      Object.defineProperty(target, key, {\n        set: setter,\n        get: getter,\n        enumerable: true,\n        configurable: true\n      });\n    }\n  };\n}\nvar ChangeDetectable = /** @class */function () {\n  function ChangeDetectable() {\n    this._dirty = RedrawType.MAJOR;\n  }\n  ChangeDetectable.prototype.markDirty = function (_source, type) {\n    if (type === void 0) {\n      type = RedrawType.TRIVIAL;\n    }\n    if (this._dirty > type) {\n      return;\n    }\n    this._dirty = type;\n  };\n  ChangeDetectable.prototype.markClean = function (_opts) {\n    this._dirty = RedrawType.NONE;\n  };\n  ChangeDetectable.prototype.isDirty = function () {\n    return this._dirty > RedrawType.NONE;\n  };\n  return ChangeDetectable;\n}();\nexport { ChangeDetectable };","map":{"version":3,"names":["windowValue","RedrawType","evalAvailable","eval","e","EVAL_USEABLE","SceneChangeDetection","opts","_a","_b","redraw","TRIVIAL","_c","type","changeCb","convertor","_d","checkDirtyOnAssignment","debug","target","key","privateKey","setterJs","NONE","getterJs","Object","defineProperty","set","get","enumerable","configurable","setter","value","oldValue","markDirty","markDirtyTransform","_dirtyPath","_dirtyFont","_dirty","getter","ChangeDetectable","MAJOR","prototype","_source","markClean","_opts","isDirty"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/scene/changeDetectable.js"],"sourcesContent":["import { windowValue } from '../util/window';\nexport var RedrawType;\n(function (RedrawType) {\n    RedrawType[RedrawType[\"NONE\"] = 0] = \"NONE\";\n    // Canvas doesn't need clearing, an incremental re-rerender is sufficient.\n    RedrawType[RedrawType[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n    // Group needs clearing, a semi-incremental re-render is sufficient.\n    RedrawType[RedrawType[\"MINOR\"] = 2] = \"MINOR\";\n    // Canvas needs to be cleared for these redraw types.\n    RedrawType[RedrawType[\"MAJOR\"] = 3] = \"MAJOR\";\n})(RedrawType || (RedrawType = {}));\n/** @returns true if eval() is disabled in the current execution context. */\nfunction evalAvailable() {\n    try {\n        eval('');\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nvar EVAL_USEABLE = evalAvailable();\nexport function SceneChangeDetection(opts) {\n    var _a = opts || {}, _b = _a.redraw, redraw = _b === void 0 ? RedrawType.TRIVIAL : _b, _c = _a.type, type = _c === void 0 ? 'normal' : _c, changeCb = _a.changeCb, convertor = _a.convertor, _d = _a.checkDirtyOnAssignment, checkDirtyOnAssignment = _d === void 0 ? false : _d;\n    var debug = windowValue('agChartsSceneChangeDetectionDebug') != null;\n    return function (target, key) {\n        // `target` is either a constructor (static member) or prototype (instance member)\n        var privateKey = \"__\" + key;\n        if (target[key]) {\n            return;\n        }\n        if (EVAL_USEABLE) {\n            // Optimised code-path.\n            // Remove all conditional logic from runtime - generate a setter with the exact necessary\n            // steps, as these setters are called a LOT during update cycles.\n            var setterJs = \"\\n                \" + (debug ? 'var setCount = 0;' : '') + \"\\n                function set_\" + key + \"(value) {\\n                    const oldValue = this.\" + privateKey + \";\\n                    \" + (convertor ? 'value = convertor(value);' : '') + \"\\n                    if (value !== oldValue) {\\n                        this.\" + privateKey + \" = value;\\n                        \" + (debug\n                ? \"console.log({ t: this, property: '\" + key + \"', oldValue, value, stack: new Error().stack });\"\n                : '') + \"\\n                        \" + (type === 'normal' ? \"this.markDirty(this, \" + redraw + \");\" : '') + \"\\n                        \" + (type === 'transform' ? \"this.markDirtyTransform(\" + redraw + \");\" : '') + \"\\n                        \" + (type === 'path'\n                ? \"if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, \" + redraw + \"); }\"\n                : '') + \"\\n                        \" + (type === 'font'\n                ? \"if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, \" + redraw + \"); }\"\n                : '') + \"\\n                        \" + (changeCb ? 'changeCb(this);' : '') + \"\\n                    }\\n                    \" + (checkDirtyOnAssignment\n                ? \"if (value != null && value._dirty > \" + RedrawType.NONE + \") { this.markDirty(value, value._dirty); }\"\n                : '') + \"\\n                };\\n                set_\" + key + \";\\n            \";\n            var getterJs = \"\\n                function get_\" + key + \"() {\\n                    return this.\" + privateKey + \";\\n                };\\n                get_\" + key + \";\\n            \";\n            Object.defineProperty(target, key, {\n                set: eval(setterJs),\n                get: eval(getterJs),\n                enumerable: true,\n                configurable: true,\n            });\n        }\n        else {\n            // Unoptimised but 'safe' code-path, for environments with CSP headers and no 'unsafe-eval'.\n            // We deliberately do not support debug branches found in the optimised path above, since\n            // for large data-set series performance deteriorates with every extra branch here.\n            var setter = function (value) {\n                var oldValue = this[privateKey];\n                value = convertor ? convertor(value) : value;\n                if (value !== oldValue) {\n                    this[privateKey] = value;\n                    if (type === 'normal')\n                        this.markDirty(this, redraw);\n                    if (type === 'transform')\n                        this.markDirtyTransform(redraw);\n                    if (type === 'path' && !this._dirtyPath) {\n                        this._dirtyPath = true;\n                        this.markDirty(this, redraw);\n                    }\n                    if (type === 'font' && !this._dirtyFont) {\n                        this._dirtyFont = true;\n                        this.markDirty(this, redraw);\n                    }\n                    if (changeCb)\n                        changeCb(this);\n                }\n                if (checkDirtyOnAssignment && value != null && value._dirty > RedrawType.NONE)\n                    this.markDirty(value, value._dirty);\n            };\n            var getter = function () {\n                return this[privateKey];\n            };\n            Object.defineProperty(target, key, {\n                set: setter,\n                get: getter,\n                enumerable: true,\n                configurable: true,\n            });\n        }\n    };\n}\nvar ChangeDetectable = /** @class */ (function () {\n    function ChangeDetectable() {\n        this._dirty = RedrawType.MAJOR;\n    }\n    ChangeDetectable.prototype.markDirty = function (_source, type) {\n        if (type === void 0) { type = RedrawType.TRIVIAL; }\n        if (this._dirty > type) {\n            return;\n        }\n        this._dirty = type;\n    };\n    ChangeDetectable.prototype.markClean = function (_opts) {\n        this._dirty = RedrawType.NONE;\n    };\n    ChangeDetectable.prototype.isDirty = function () {\n        return this._dirty > RedrawType.NONE;\n    };\n    return ChangeDetectable;\n}());\nexport { ChangeDetectable };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}