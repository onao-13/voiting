{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { Matrix } from './matrix';\nimport { createId } from '../util/id';\nimport { ChangeDetectable, SceneChangeDetection, RedrawType } from './changeDetectable';\nexport { SceneChangeDetection, RedrawType };\nexport var PointerEvents;\n(function (PointerEvents) {\n  PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n  PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\nvar zIndexChangedCallback = function (o) {\n  if (o.parent) {\n    o.parent.dirtyZIndex = true;\n  }\n  o.zIndexChanged();\n};\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\nvar Node = /** @class */function (_super) {\n  __extends(Node, _super);\n  function Node() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** Unique number to allow creation order to be easily determined. */\n    _this.serialNumber = Node._nextSerialNumber++;\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    _this.id = createId(_this);\n    /**\n     * Some number to identify this node, typically within a `Group` node.\n     * Usually this will be some enum value used as a selector.\n     */\n    _this.tag = NaN;\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    _this.isContainerNode = false;\n    _this._children = [];\n    // Used to check for duplicate nodes.\n    _this.childSet = {}; // new Set<Node>()\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    _this.matrix = new Matrix();\n    _this.inverseMatrix = new Matrix();\n    _this._dirtyTransform = false;\n    _this.scalingX = 1;\n    _this.scalingY = 1;\n    /**\n     * The center of scaling.\n     * The default value of `null` means the scaling center will be\n     * determined automatically, as the center of the bounding box\n     * of a node.\n     */\n    _this.scalingCenterX = null;\n    _this.scalingCenterY = null;\n    _this.rotationCenterX = null;\n    _this.rotationCenterY = null;\n    /**\n     * Rotation angle in radians.\n     * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n     * interval is performed.\n     */\n    _this.rotation = 0;\n    _this.translationX = 0;\n    _this.translationY = 0;\n    _this.visible = true;\n    _this.dirtyZIndex = false;\n    _this.zIndex = 0;\n    /** Discriminators for render order within a zIndex. */\n    _this.zIndexSubOrder = undefined;\n    _this.pointerEvents = PointerEvents.All;\n    return _this;\n  }\n  /**\n   * This is meaningfully faster than `instanceof` and should be the preferred way\n   * of checking inside loops.\n   * @param node\n   */\n  Node.isNode = function (node) {\n    return node ? node.matrix !== undefined : false;\n  };\n  Node.prototype._setScene = function (value) {\n    var e_1, _a;\n    var _b;\n    this._scene = value;\n    this._debug = (_b = value) === null || _b === void 0 ? void 0 : _b.debug;\n    try {\n      for (var _c = __values(this.children), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var child = _d.value;\n        child._setScene(value);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  Object.defineProperty(Node.prototype, \"scene\", {\n    get: function () {\n      return this._scene;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"parent\", {\n    get: function () {\n      return this._parent;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"children\", {\n    get: function () {\n      return this._children;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.countChildren = function (depth) {\n    if (depth === void 0) {\n      depth = Node.MAX_SAFE_INTEGER;\n    }\n    if (depth <= 0) {\n      return 0;\n    }\n    var children = this.children;\n    var n = children.length;\n    var size = n;\n    for (var i = 0; i < n; i++) {\n      size += children[i].countChildren(depth - 1);\n    }\n    return size;\n  };\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  Node.prototype.append = function (nodes) {\n    var e_2, _a;\n    // Passing a single parameter to an open-ended version of `append`\n    // would be 30-35% slower than this.\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n    try {\n      for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n        var node = nodes_1_1.value;\n        if (node.parent) {\n          throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n        }\n        if (node.scene) {\n          throw new Error(node + \" already belongs to a scene: \" + node.scene + \".\");\n        }\n        if (this.childSet[node.id]) {\n          // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n          throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n        }\n        this._children.push(node);\n        this.childSet[node.id] = true;\n        node._parent = this;\n        node._setScene(this.scene);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    this.dirtyZIndex = true;\n    this.markDirty(this, RedrawType.MAJOR);\n  };\n  Node.prototype.appendChild = function (node) {\n    this.append(node);\n    return node;\n  };\n  Node.prototype.removeChild = function (node) {\n    if (node.parent === this) {\n      var i = this.children.indexOf(node);\n      if (i >= 0) {\n        this._children.splice(i, 1);\n        delete this.childSet[node.id];\n        node._parent = undefined;\n        node._setScene();\n        this.dirtyZIndex = true;\n        this.markDirty(node, RedrawType.MAJOR);\n        return node;\n      }\n    }\n    throw new Error(\"The node to be removed is not a child of this node.\");\n  };\n  /**\n   * Inserts the node `node` before the existing child node `nextNode`.\n   * If `nextNode` is null, insert `node` at the end of the list of children.\n   * If the `node` belongs to another parent, it is first removed.\n   * Returns the `node`.\n   * @param node\n   * @param nextNode\n   */\n  Node.prototype.insertBefore = function (node, nextNode) {\n    var parent = node.parent;\n    if (node.parent) {\n      node.parent.removeChild(node);\n    }\n    if (nextNode && nextNode.parent === this) {\n      var i = this.children.indexOf(nextNode);\n      if (i >= 0) {\n        this._children.splice(i, 0, node);\n        this.childSet[node.id] = true;\n        node._parent = this;\n        node._setScene(this.scene);\n      } else {\n        throw new Error(nextNode + \" has \" + parent + \" as the parent, \" + \"but is not in its list of children.\");\n      }\n      this.dirtyZIndex = true;\n      this.markDirty(node, RedrawType.MAJOR);\n    } else {\n      this.append(node);\n    }\n    return node;\n  };\n  Object.defineProperty(Node.prototype, \"nextSibling\", {\n    get: function () {\n      var parent = this.parent;\n      if (parent) {\n        var children = parent.children;\n        var index = children.indexOf(this);\n        if (index >= 0 && index <= children.length - 1) {\n          return children[index + 1];\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.transformPoint = function (x, y) {\n    var matrix = Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n    while (parent) {\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n    return matrix.invertSelf().transformPoint(x, y);\n  };\n  Node.prototype.inverseTransformPoint = function (x, y) {\n    var matrix = Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n    while (parent) {\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n    return matrix.transformPoint(x, y);\n  };\n  Node.prototype.markDirtyTransform = function () {\n    this._dirtyTransform = true;\n    this.markDirty(this, RedrawType.MAJOR);\n  };\n  Object.defineProperty(Node.prototype, \"rotationDeg\", {\n    get: function () {\n      return this.rotation / Math.PI * 180;\n    },\n    /**\n     * For performance reasons the rotation angle's internal representation\n     * is in radians. Therefore, don't expect to get the same number you set.\n     * Even with integer angles about a quarter of them from 0 to 359 cannot\n     * be converted to radians and back without precision loss.\n     * For example:\n     *\n     *     node.rotationDeg = 11;\n     *     console.log(node.rotationDeg); // 10.999999999999998\n     *\n     * @param value Rotation angle in degrees.\n     */\n    set: function (value) {\n      this.rotation = value / 180 * Math.PI;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.containsPoint = function (_x, _y) {\n    return false;\n  };\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  Node.prototype.pickNode = function (x, y) {\n    var _a;\n    if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n      return;\n    }\n    var children = this.children;\n    if (children.length > 1000) {\n      // Try to optimise which children to interrogate; BBox calculation is an approximation\n      // for more complex shapes, so discarding items based on this will save a lot of\n      // processing when the point is nowhere near the child.\n      for (var i = children.length - 1; i >= 0; i--) {\n        var hit = ((_a = children[i].computeBBox()) === null || _a === void 0 ? void 0 : _a.containsPoint(x, y)) ? children[i].pickNode(x, y) : undefined;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      // Nodes added later should be hit-tested first,\n      // as they are rendered on top of the previously added nodes.\n      for (var i = children.length - 1; i >= 0; i--) {\n        var hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      // a leaf node, but not a container leaf\n      return this;\n    }\n  };\n  Node.prototype.computeBBox = function () {\n    return;\n  };\n  Node.prototype.computeTransformedBBox = function () {\n    var bbox = this.computeBBox();\n    if (!bbox) {\n      return undefined;\n    }\n    this.computeTransformMatrix();\n    var matrix = Matrix.flyweight(this.matrix);\n    var parent = this.parent;\n    while (parent) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n    matrix.transformBBox(bbox, 0, bbox);\n    return bbox;\n  };\n  Node.prototype.computeBBoxCenter = function () {\n    var bbox = this.computeBBox && this.computeBBox();\n    if (bbox) {\n      return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];\n    }\n    return [0, 0];\n  };\n  Node.prototype.computeTransformMatrix = function () {\n    if (!this._dirtyTransform) {\n      return;\n    }\n    var _a = this,\n      matrix = _a.matrix,\n      scalingX = _a.scalingX,\n      scalingY = _a.scalingY,\n      rotation = _a.rotation,\n      translationX = _a.translationX,\n      translationY = _a.translationY,\n      scalingCenterX = _a.scalingCenterX,\n      scalingCenterY = _a.scalingCenterY,\n      rotationCenterX = _a.rotationCenterX,\n      rotationCenterY = _a.rotationCenterY;\n    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\n      scalingCenterX: scalingCenterX,\n      scalingCenterY: scalingCenterY,\n      rotationCenterX: rotationCenterX,\n      rotationCenterY: rotationCenterY\n    });\n    matrix.inverseTo(this.inverseMatrix);\n    this._dirtyTransform = false;\n  };\n  Node.prototype.render = function (renderCtx) {\n    var stats = renderCtx.stats;\n    this._dirty = RedrawType.NONE;\n    if (stats) stats.nodesRendered++;\n  };\n  Node.prototype.clearBBox = function (ctx) {\n    var bbox = this.computeBBox();\n    if (bbox == null) {\n      return;\n    }\n    var x = bbox.x,\n      y = bbox.y,\n      width = bbox.width,\n      height = bbox.height;\n    var topLeft = this.transformPoint(x, y);\n    var bottomRight = this.transformPoint(x + width, y + height);\n    ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n  };\n  Node.prototype.markDirty = function (_source, type, parentType) {\n    if (type === void 0) {\n      type = RedrawType.TRIVIAL;\n    }\n    if (parentType === void 0) {\n      parentType = type;\n    }\n    if (this._dirty > type) {\n      return;\n    }\n    if (this._dirty === type && type === parentType) {\n      return;\n    }\n    this._dirty = type;\n    if (this.parent) {\n      this.parent.markDirty(this, parentType);\n    } else if (this.scene) {\n      this.scene.markDirty();\n    }\n  };\n  Object.defineProperty(Node.prototype, \"dirty\", {\n    get: function () {\n      return this._dirty;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.markClean = function (opts) {\n    var e_3, _a;\n    var _b = opts || {},\n      _c = _b.force,\n      force = _c === void 0 ? false : _c,\n      _d = _b.recursive,\n      recursive = _d === void 0 ? true : _d;\n    if (this._dirty === RedrawType.NONE && !force) {\n      return;\n    }\n    this._dirty = RedrawType.NONE;\n    if (recursive) {\n      try {\n        for (var _e = __values(this.children), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var child = _f.value;\n          child.markClean();\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n  };\n  Node.prototype.visibilityChanged = function () {\n    // Override point for sub-classes to react to visibility changes.\n  };\n  Object.defineProperty(Node.prototype, \"nodeCount\", {\n    get: function () {\n      var e_4, _a;\n      var count = 1;\n      var dirtyCount = this._dirty >= RedrawType.NONE || this._dirtyTransform ? 1 : 0;\n      var visibleCount = this.visible ? 1 : 0;\n      try {\n        for (var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          var _d = child.nodeCount,\n            childCount = _d.count,\n            childVisibleCount = _d.visibleCount,\n            childDirtyCount = _d.dirtyCount;\n          count += childCount;\n          visibleCount += childVisibleCount;\n          dirtyCount += childDirtyCount;\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n      return {\n        count: count,\n        visibleCount: visibleCount,\n        dirtyCount: dirtyCount\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Node.prototype.zIndexChanged = function () {\n    // Override point for sub-classes.\n  };\n  Node._nextSerialNumber = 0;\n  Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"scalingX\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"scalingY\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"scalingCenterX\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"scalingCenterY\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"rotationCenterX\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"rotationCenterY\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"rotation\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"translationX\", void 0);\n  __decorate([SceneChangeDetection({\n    type: 'transform'\n  })], Node.prototype, \"translationY\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MAJOR,\n    changeCb: function (o) {\n      return o.visibilityChanged();\n    }\n  })], Node.prototype, \"visible\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.TRIVIAL,\n    changeCb: zIndexChangedCallback\n  })], Node.prototype, \"zIndex\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.TRIVIAL,\n    changeCb: zIndexChangedCallback\n  })], Node.prototype, \"zIndexSubOrder\", void 0);\n  return Node;\n}(ChangeDetectable);\nexport { Node };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__values","o","s","Symbol","iterator","m","call","next","value","done","TypeError","Matrix","createId","ChangeDetectable","SceneChangeDetection","RedrawType","PointerEvents","zIndexChangedCallback","parent","dirtyZIndex","zIndexChanged","Node","_super","_this","apply","serialNumber","_nextSerialNumber","id","tag","NaN","isContainerNode","_children","childSet","matrix","inverseMatrix","_dirtyTransform","scalingX","scalingY","scalingCenterX","scalingCenterY","rotationCenterX","rotationCenterY","rotation","translationX","translationY","visible","zIndex","zIndexSubOrder","undefined","pointerEvents","All","isNode","node","_setScene","e_1","_a","_b","_scene","_debug","debug","_c","children","_d","child","e_1_1","error","return","get","enumerable","configurable","_parent","countChildren","depth","MAX_SAFE_INTEGER","n","size","append","nodes","e_2","nodes_1","nodes_1_1","Error","scene","name","push","e_2_1","markDirty","MAJOR","appendChild","removeChild","indexOf","splice","insertBefore","nextNode","index","transformPoint","x","y","flyweight","preMultiplySelf","invertSelf","inverseTransformPoint","markDirtyTransform","Math","PI","set","containsPoint","_x","_y","pickNode","None","hit","computeBBox","computeTransformedBBox","bbox","computeTransformMatrix","transformBBox","computeBBoxCenter","width","height","updateTransformMatrix","inverseTo","render","renderCtx","stats","_dirty","NONE","nodesRendered","clearBBox","ctx","topLeft","bottomRight","clearRect","_source","type","parentType","TRIVIAL","markClean","opts","e_3","force","recursive","_e","_f","e_3_1","visibilityChanged","e_4","count","dirtyCount","visibleCount","nodeCount","childCount","childVisibleCount","childDirtyCount","e_4_1","pow","redraw","changeCb"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/scene/node.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { Matrix } from './matrix';\nimport { createId } from '../util/id';\nimport { ChangeDetectable, SceneChangeDetection, RedrawType } from './changeDetectable';\nexport { SceneChangeDetection, RedrawType };\nexport var PointerEvents;\n(function (PointerEvents) {\n    PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n    PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\nvar zIndexChangedCallback = function (o) {\n    if (o.parent) {\n        o.parent.dirtyZIndex = true;\n    }\n    o.zIndexChanged();\n};\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\nvar Node = /** @class */ (function (_super) {\n    __extends(Node, _super);\n    function Node() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /** Unique number to allow creation order to be easily determined. */\n        _this.serialNumber = Node._nextSerialNumber++;\n        /**\n         * Unique node ID in the form `ClassName-NaturalNumber`.\n         */\n        _this.id = createId(_this);\n        /**\n         * Some number to identify this node, typically within a `Group` node.\n         * Usually this will be some enum value used as a selector.\n         */\n        _this.tag = NaN;\n        /**\n         * To simplify the type system (especially in Selections) we don't have the `Parent` node\n         * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n         * But we still need to distinguish regular leaf nodes from container leafs somehow.\n         */\n        _this.isContainerNode = false;\n        _this._children = [];\n        // Used to check for duplicate nodes.\n        _this.childSet = {}; // new Set<Node>()\n        // These matrices may need to have package level visibility\n        // for performance optimization purposes.\n        _this.matrix = new Matrix();\n        _this.inverseMatrix = new Matrix();\n        _this._dirtyTransform = false;\n        _this.scalingX = 1;\n        _this.scalingY = 1;\n        /**\n         * The center of scaling.\n         * The default value of `null` means the scaling center will be\n         * determined automatically, as the center of the bounding box\n         * of a node.\n         */\n        _this.scalingCenterX = null;\n        _this.scalingCenterY = null;\n        _this.rotationCenterX = null;\n        _this.rotationCenterY = null;\n        /**\n         * Rotation angle in radians.\n         * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n         * interval is performed.\n         */\n        _this.rotation = 0;\n        _this.translationX = 0;\n        _this.translationY = 0;\n        _this.visible = true;\n        _this.dirtyZIndex = false;\n        _this.zIndex = 0;\n        /** Discriminators for render order within a zIndex. */\n        _this.zIndexSubOrder = undefined;\n        _this.pointerEvents = PointerEvents.All;\n        return _this;\n    }\n    /**\n     * This is meaningfully faster than `instanceof` and should be the preferred way\n     * of checking inside loops.\n     * @param node\n     */\n    Node.isNode = function (node) {\n        return node ? node.matrix !== undefined : false;\n    };\n    Node.prototype._setScene = function (value) {\n        var e_1, _a;\n        var _b;\n        this._scene = value;\n        this._debug = (_b = value) === null || _b === void 0 ? void 0 : _b.debug;\n        try {\n            for (var _c = __values(this.children), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var child = _d.value;\n                child._setScene(value);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    Object.defineProperty(Node.prototype, \"scene\", {\n        get: function () {\n            return this._scene;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"children\", {\n        get: function () {\n            return this._children;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.countChildren = function (depth) {\n        if (depth === void 0) { depth = Node.MAX_SAFE_INTEGER; }\n        if (depth <= 0) {\n            return 0;\n        }\n        var children = this.children;\n        var n = children.length;\n        var size = n;\n        for (var i = 0; i < n; i++) {\n            size += children[i].countChildren(depth - 1);\n        }\n        return size;\n    };\n    /**\n     * Appends one or more new node instances to this parent.\n     * If one needs to:\n     * - move a child to the end of the list of children\n     * - move a child from one parent to another (including parents in other scenes)\n     * one should use the {@link insertBefore} method instead.\n     * @param nodes A node or nodes to append.\n     */\n    Node.prototype.append = function (nodes) {\n        var e_2, _a;\n        // Passing a single parameter to an open-ended version of `append`\n        // would be 30-35% slower than this.\n        if (Node.isNode(nodes)) {\n            nodes = [nodes];\n        }\n        try {\n            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n                var node = nodes_1_1.value;\n                if (node.parent) {\n                    throw new Error(node + \" already belongs to another parent: \" + node.parent + \".\");\n                }\n                if (node.scene) {\n                    throw new Error(node + \" already belongs to a scene: \" + node.scene + \".\");\n                }\n                if (this.childSet[node.id]) {\n                    // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n                    throw new Error(\"Duplicate \" + node.constructor.name + \" node: \" + node);\n                }\n                this._children.push(node);\n                this.childSet[node.id] = true;\n                node._parent = this;\n                node._setScene(this.scene);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        this.dirtyZIndex = true;\n        this.markDirty(this, RedrawType.MAJOR);\n    };\n    Node.prototype.appendChild = function (node) {\n        this.append(node);\n        return node;\n    };\n    Node.prototype.removeChild = function (node) {\n        if (node.parent === this) {\n            var i = this.children.indexOf(node);\n            if (i >= 0) {\n                this._children.splice(i, 1);\n                delete this.childSet[node.id];\n                node._parent = undefined;\n                node._setScene();\n                this.dirtyZIndex = true;\n                this.markDirty(node, RedrawType.MAJOR);\n                return node;\n            }\n        }\n        throw new Error(\"The node to be removed is not a child of this node.\");\n    };\n    /**\n     * Inserts the node `node` before the existing child node `nextNode`.\n     * If `nextNode` is null, insert `node` at the end of the list of children.\n     * If the `node` belongs to another parent, it is first removed.\n     * Returns the `node`.\n     * @param node\n     * @param nextNode\n     */\n    Node.prototype.insertBefore = function (node, nextNode) {\n        var parent = node.parent;\n        if (node.parent) {\n            node.parent.removeChild(node);\n        }\n        if (nextNode && nextNode.parent === this) {\n            var i = this.children.indexOf(nextNode);\n            if (i >= 0) {\n                this._children.splice(i, 0, node);\n                this.childSet[node.id] = true;\n                node._parent = this;\n                node._setScene(this.scene);\n            }\n            else {\n                throw new Error(nextNode + \" has \" + parent + \" as the parent, \" + \"but is not in its list of children.\");\n            }\n            this.dirtyZIndex = true;\n            this.markDirty(node, RedrawType.MAJOR);\n        }\n        else {\n            this.append(node);\n        }\n        return node;\n    };\n    Object.defineProperty(Node.prototype, \"nextSibling\", {\n        get: function () {\n            var parent = this.parent;\n            if (parent) {\n                var children = parent.children;\n                var index = children.indexOf(this);\n                if (index >= 0 && index <= children.length - 1) {\n                    return children[index + 1];\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.transformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.invertSelf().transformPoint(x, y);\n    };\n    Node.prototype.inverseTransformPoint = function (x, y) {\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        return matrix.transformPoint(x, y);\n    };\n    Node.prototype.markDirtyTransform = function () {\n        this._dirtyTransform = true;\n        this.markDirty(this, RedrawType.MAJOR);\n    };\n    Object.defineProperty(Node.prototype, \"rotationDeg\", {\n        get: function () {\n            return (this.rotation / Math.PI) * 180;\n        },\n        /**\n         * For performance reasons the rotation angle's internal representation\n         * is in radians. Therefore, don't expect to get the same number you set.\n         * Even with integer angles about a quarter of them from 0 to 359 cannot\n         * be converted to radians and back without precision loss.\n         * For example:\n         *\n         *     node.rotationDeg = 11;\n         *     console.log(node.rotationDeg); // 10.999999999999998\n         *\n         * @param value Rotation angle in degrees.\n         */\n        set: function (value) {\n            this.rotation = (value / 180) * Math.PI;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.containsPoint = function (_x, _y) {\n        return false;\n    };\n    /**\n     * Hit testing method.\n     * Recursively checks if the given point is inside this node or any of its children.\n     * Returns the first matching node or `undefined`.\n     * Nodes that render later (show on top) are hit tested first.\n     */\n    Node.prototype.pickNode = function (x, y) {\n        var _a;\n        if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n            return;\n        }\n        var children = this.children;\n        if (children.length > 1000) {\n            // Try to optimise which children to interrogate; BBox calculation is an approximation\n            // for more complex shapes, so discarding items based on this will save a lot of\n            // processing when the point is nowhere near the child.\n            for (var i = children.length - 1; i >= 0; i--) {\n                var hit = ((_a = children[i].computeBBox()) === null || _a === void 0 ? void 0 : _a.containsPoint(x, y)) ? children[i].pickNode(x, y) : undefined;\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n        else if (children.length) {\n            // Nodes added later should be hit-tested first,\n            // as they are rendered on top of the previously added nodes.\n            for (var i = children.length - 1; i >= 0; i--) {\n                var hit = children[i].pickNode(x, y);\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n        else if (!this.isContainerNode) {\n            // a leaf node, but not a container leaf\n            return this;\n        }\n    };\n    Node.prototype.computeBBox = function () {\n        return;\n    };\n    Node.prototype.computeTransformedBBox = function () {\n        var bbox = this.computeBBox();\n        if (!bbox) {\n            return undefined;\n        }\n        this.computeTransformMatrix();\n        var matrix = Matrix.flyweight(this.matrix);\n        var parent = this.parent;\n        while (parent) {\n            parent.computeTransformMatrix();\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n        matrix.transformBBox(bbox, 0, bbox);\n        return bbox;\n    };\n    Node.prototype.computeBBoxCenter = function () {\n        var bbox = this.computeBBox && this.computeBBox();\n        if (bbox) {\n            return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];\n        }\n        return [0, 0];\n    };\n    Node.prototype.computeTransformMatrix = function () {\n        if (!this._dirtyTransform) {\n            return;\n        }\n        var _a = this, matrix = _a.matrix, scalingX = _a.scalingX, scalingY = _a.scalingY, rotation = _a.rotation, translationX = _a.translationX, translationY = _a.translationY, scalingCenterX = _a.scalingCenterX, scalingCenterY = _a.scalingCenterY, rotationCenterX = _a.rotationCenterX, rotationCenterY = _a.rotationCenterY;\n        Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\n            scalingCenterX: scalingCenterX,\n            scalingCenterY: scalingCenterY,\n            rotationCenterX: rotationCenterX,\n            rotationCenterY: rotationCenterY,\n        });\n        matrix.inverseTo(this.inverseMatrix);\n        this._dirtyTransform = false;\n    };\n    Node.prototype.render = function (renderCtx) {\n        var stats = renderCtx.stats;\n        this._dirty = RedrawType.NONE;\n        if (stats)\n            stats.nodesRendered++;\n    };\n    Node.prototype.clearBBox = function (ctx) {\n        var bbox = this.computeBBox();\n        if (bbox == null) {\n            return;\n        }\n        var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;\n        var topLeft = this.transformPoint(x, y);\n        var bottomRight = this.transformPoint(x + width, y + height);\n        ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n    };\n    Node.prototype.markDirty = function (_source, type, parentType) {\n        if (type === void 0) { type = RedrawType.TRIVIAL; }\n        if (parentType === void 0) { parentType = type; }\n        if (this._dirty > type) {\n            return;\n        }\n        if (this._dirty === type && type === parentType) {\n            return;\n        }\n        this._dirty = type;\n        if (this.parent) {\n            this.parent.markDirty(this, parentType);\n        }\n        else if (this.scene) {\n            this.scene.markDirty();\n        }\n    };\n    Object.defineProperty(Node.prototype, \"dirty\", {\n        get: function () {\n            return this._dirty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.markClean = function (opts) {\n        var e_3, _a;\n        var _b = opts || {}, _c = _b.force, force = _c === void 0 ? false : _c, _d = _b.recursive, recursive = _d === void 0 ? true : _d;\n        if (this._dirty === RedrawType.NONE && !force) {\n            return;\n        }\n        this._dirty = RedrawType.NONE;\n        if (recursive) {\n            try {\n                for (var _e = __values(this.children), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var child = _f.value;\n                    child.markClean();\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }\n    };\n    Node.prototype.visibilityChanged = function () {\n        // Override point for sub-classes to react to visibility changes.\n    };\n    Object.defineProperty(Node.prototype, \"nodeCount\", {\n        get: function () {\n            var e_4, _a;\n            var count = 1;\n            var dirtyCount = this._dirty >= RedrawType.NONE || this._dirtyTransform ? 1 : 0;\n            var visibleCount = this.visible ? 1 : 0;\n            try {\n                for (var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var child = _c.value;\n                    var _d = child.nodeCount, childCount = _d.count, childVisibleCount = _d.visibleCount, childDirtyCount = _d.dirtyCount;\n                    count += childCount;\n                    visibleCount += childVisibleCount;\n                    dirtyCount += childDirtyCount;\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            return { count: count, visibleCount: visibleCount, dirtyCount: dirtyCount };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Node.prototype.zIndexChanged = function () {\n        // Override point for sub-classes.\n    };\n    Node._nextSerialNumber = 0;\n    Node.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"scalingX\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"scalingY\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"scalingCenterX\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"scalingCenterY\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"rotationCenterX\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"rotationCenterY\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"rotation\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"translationX\", void 0);\n    __decorate([\n        SceneChangeDetection({ type: 'transform' })\n    ], Node.prototype, \"translationY\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MAJOR, changeCb: function (o) { return o.visibilityChanged(); } })\n    ], Node.prototype, \"visible\", void 0);\n    __decorate([\n        SceneChangeDetection({\n            redraw: RedrawType.TRIVIAL,\n            changeCb: zIndexChangedCallback,\n        })\n    ], Node.prototype, \"zIndex\", void 0);\n    __decorate([\n        SceneChangeDetection({\n            redraw: RedrawType.TRIVIAL,\n            changeCb: zIndexChangedCallback,\n        })\n    ], Node.prototype, \"zIndexSubOrder\", void 0);\n    return Node;\n}(ChangeDetectable));\nexport { Node };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}