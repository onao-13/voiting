{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar _a, _b, _c;\nexports.__esModule = true;\nvar util_1 = require(\"zrender/lib/core/util\");\nvar model_1 = require(\"../../util/model\");\nvar Source_1 = require(\"../Source\");\nvar types_1 = require(\"../../util/types\");\nvar providerMethods;\nvar mountMethods;\nvar DefaultDataProvider = function () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    var source = !Source_1.isSourceInstance(sourceParam) ? Source_1.createSourceFromSeriesDataOption(sourceParam) : sourceParam;\n    this._source = source;\n    var data = this._data = source.data;\n    if (source.sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n    mountMethods(this, data, source);\n  }\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n  DefaultDataProvider.prototype.clean = function () {};\n  DefaultDataProvider.protoInitialize = function () {\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n  DefaultDataProvider.internalField = function () {\n    var _a;\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n      if (process.env.NODE_ENV !== 'production') {\n        util_1.assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n      util_1.extend(provider, methods);\n      if (sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = util_1.bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = util_1.bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n      return out;\n    };\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n        for (var i = 0; i < count; i++) {\n          var val = data[(start + i) * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n    providerMethods = (_a = {}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[types_1.SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        util_1.each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[types_1.SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[types_1.SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          util_1.assert(util_1.isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n        this._data = newData;\n      },\n      clean: function () {\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n  return DefaultDataProvider;\n}();\nexports.DefaultDataProvider = DefaultDataProvider;\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\nvar rawSourceItemGetterMap = (_a = {}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx) {\n  idx += startIndex;\n  var item = [];\n  var data = rawData;\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item.push(row ? row[idx] : null);\n  }\n  return item;\n}, _a[types_1.SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx) {\n  var item = [];\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n    var col = rawData[dimName];\n    item.push(col ? col[idx] : null);\n  }\n  return item;\n}, _a[types_1.SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nfunction getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    util_1.assert(method, 'Do not suppport get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nexports.getRawSourceItemGetter = getRawSourceItemGetter;\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\nvar rawSourceDataCounterMap = (_b = {}, _b[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[types_1.SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[types_1.SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nfunction getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    util_1.assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nexports.getRawSourceDataCounter = getRawSourceDataCounter;\nvar getRawValueSimply = function (dataItem, dimIndex, dimName) {\n  return dimIndex != null ? dataItem[dimIndex] : dataItem;\n};\nvar rawSourceValueGetterMap = (_c = {}, _c[types_1.SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[types_1.SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, dimName) {\n  return dimIndex != null ? dataItem[dimName] : dataItem;\n}, _c[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[types_1.SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, dimName) {\n  var value = model_1.getDataItemValue(dataItem);\n  return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];\n}, _c[types_1.SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nfunction getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n  if (process.env.NODE_ENV !== 'production') {\n    util_1.assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n  return method;\n}\nexports.getRawSourceValueGetter = getRawSourceValueGetter;\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n}\nfunction retrieveRawValue(data, dataIndex, dim) {\n  if (!data) {\n    return;\n  }\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (dataItem == null) {\n    return;\n  }\n  var sourceFormat = data.getProvider().getSource().sourceFormat;\n  var dimName;\n  var dimIndex;\n  var dimInfo = data.getDimensionInfo(dim);\n  if (dimInfo) {\n    dimName = dimInfo.name;\n    dimIndex = dimInfo.index;\n  }\n  return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, dimName);\n}\nexports.retrieveRawValue = retrieveRawValue;\nfunction retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n  var sourceFormat = data.getProvider().getSource().sourceFormat;\n  if (sourceFormat !== types_1.SOURCE_FORMAT_ORIGINAL && sourceFormat !== types_1.SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL && !util_1.isObject(dataItem)) {\n    dataItem = null;\n  }\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}\nexports.retrieveRawAttr = retrieveRawAttr;","map":{"version":3,"names":["_a","_b","_c","exports","__esModule","util_1","require","model_1","Source_1","types_1","providerMethods","mountMethods","DefaultDataProvider","sourceParam","dimSize","source","isSourceInstance","createSourceFromSeriesDataOption","_source","data","_data","sourceFormat","SOURCE_FORMAT_TYPED_ARRAY","process","env","NODE_ENV","Error","_offset","_dimSize","prototype","getSource","count","getItem","idx","out","appendData","newData","clean","protoInitialize","proto","pure","persistent","internalField","provider","seriesLayoutBy","startIndex","dimsDef","dimensionsDefine","methods","getMethodMapKey","assert","extend","getItemForTypedArray","countForTypedArray","fillStorage","fillStorageForTypedArray","rawItemGetter","getRawSourceItemGetter","bind","rawCounter","getRawSourceDataCounter","offset","i","start","end","storage","extent","dim","dimExtent","min","Infinity","max","arr","val","length","SOURCE_FORMAT_ARRAY_ROWS","SERIES_LAYOUT_BY_COLUMN","appendDataSimply","SERIES_LAYOUT_BY_ROW","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","each","newCol","key","oldCol","push","SOURCE_FORMAT_ORIGINAL","isTypedArray","getItemSimply","rawData","rawSourceItemGetterMap","item","row","dimName","name","col","method","countSimply","rawSourceDataCounterMap","Math","getRawValueSimply","dataItem","dimIndex","rawSourceValueGetterMap","value","getDataItemValue","Array","getRawSourceValueGetter","retrieveRawValue","dataIndex","getRawDataItem","getProvider","dimInfo","getDimensionInfo","index","retrieveRawAttr","attr","isObject"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/echarts/lib/data/helper/dataProvider.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nvar _a, _b, _c;\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar model_1 = require(\"../../util/model\");\n\nvar Source_1 = require(\"../Source\");\n\nvar types_1 = require(\"../../util/types\");\n\nvar providerMethods;\nvar mountMethods;\n\nvar DefaultDataProvider = function () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    var source = !Source_1.isSourceInstance(sourceParam) ? Source_1.createSourceFromSeriesDataOption(sourceParam) : sourceParam;\n    this._source = source;\n    var data = this._data = source.data;\n\n    if (source.sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        util_1.assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      util_1.extend(provider, methods);\n\n      if (sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = util_1.bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = util_1.bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          var val = data[(start + i) * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[types_1.SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        util_1.each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[types_1.SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[types_1.SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          util_1.assert(util_1.isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      clean: function () {\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexports.DefaultDataProvider = DefaultDataProvider;\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx) {\n  idx += startIndex;\n  var item = [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item.push(row ? row[idx] : null);\n  }\n\n  return item;\n}, _a[types_1.SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx) {\n  var item = [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item.push(col ? col[idx] : null);\n  }\n\n  return item;\n}, _a[types_1.SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\n\nfunction getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    util_1.assert(method, 'Do not suppport get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nexports.getRawSourceItemGetter = getRawSourceItemGetter;\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[types_1.SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[types_1.SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\n\nfunction getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    util_1.assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nexports.getRawSourceDataCounter = getRawSourceDataCounter;\n\nvar getRawValueSimply = function (dataItem, dimIndex, dimName) {\n  return dimIndex != null ? dataItem[dimIndex] : dataItem;\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[types_1.SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[types_1.SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, dimName) {\n  return dimIndex != null ? dataItem[dimName] : dataItem;\n}, _c[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[types_1.SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, dimName) {\n  var value = model_1.getDataItemValue(dataItem);\n  return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];\n}, _c[types_1.SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\n\nfunction getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    util_1.assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nexports.getRawSourceValueGetter = getRawSourceValueGetter;\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n}\n\nfunction retrieveRawValue(data, dataIndex, dim) {\n  if (!data) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var sourceFormat = data.getProvider().getSource().sourceFormat;\n  var dimName;\n  var dimIndex;\n  var dimInfo = data.getDimensionInfo(dim);\n\n  if (dimInfo) {\n    dimName = dimInfo.name;\n    dimIndex = dimInfo.index;\n  }\n\n  return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, dimName);\n}\n\nexports.retrieveRawValue = retrieveRawValue;\n\nfunction retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getProvider().getSource().sourceFormat;\n\n  if (sourceFormat !== types_1.SOURCE_FORMAT_ORIGINAL && sourceFormat !== types_1.SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL && !util_1.isObject(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}\n\nexports.retrieveRawAttr = retrieveRawAttr;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}