{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { PointerEvents } from '../../scene/node';\nimport { Group } from '../../scene/group';\nimport { Text } from '../../scene/shape/text';\nimport { clamper, ContinuousScale } from '../../scale/continuousScale';\nimport { createId } from '../../util/id';\nimport { normalizeAngle360, toRadians } from '../../util/angle';\nimport { ChartAxisDirection } from '../chartAxis';\nimport { labeldDirectionHandling, POSITION_TOP_COORDINATES, calculateLabelTranslation } from './crossLineLabelPosition';\nimport { checkDatum } from '../../util/value';\nimport { Layers } from '../layers';\nimport { Range } from '../../scene/shape/range';\nimport { OPT_ARRAY, OPT_BOOLEAN, OPT_NUMBER, OPT_STRING, OPT_COLOR_STRING, STRING, Validate, OPT_LINE_DASH, OPT_FONT_STYLE, OPT_FONT_WEIGHT, NUMBER, OPTIONAL, predicateWithMessage } from '../../util/validation';\nvar CROSSLINE_LABEL_POSITIONS = ['top', 'left', 'right', 'bottom', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'inside', 'insideLeft', 'insideRight', 'insideTop', 'insideBottom', 'insideTopLeft', 'insideBottomLeft', 'insideTopRight', 'insideBottomRight'];\nvar OPT_CROSSLINE_LABEL_POSITION = predicateWithMessage(function (v, ctx) {\n  return OPTIONAL(v, ctx, function (v) {\n    return CROSSLINE_LABEL_POSITIONS.includes(v);\n  });\n}, \"expecting an optional crossLine label position keyword such as 'topLeft', 'topRight' or 'inside'\");\nvar OPT_CROSSLINE_TYPE = predicateWithMessage(function (v, ctx) {\n  return OPTIONAL(v, ctx, function (v) {\n    return v === 'range' || v === 'line';\n  });\n}, \"expecting a crossLine type keyword such as 'range' or 'line'\");\nvar CrossLineLabel = /** @class */function () {\n  function CrossLineLabel() {\n    this.enabled = undefined;\n    this.text = undefined;\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 14;\n    this.fontFamily = 'Verdana, sans-serif';\n    /**\n     * The padding between the label and the line.\n     */\n    this.padding = 5;\n    /**\n     * The color of the labels.\n     */\n    this.color = 'rgba(87, 87, 87, 1)';\n    this.position = undefined;\n    this.rotation = undefined;\n    this.parallel = undefined;\n  }\n  __decorate([Validate(OPT_BOOLEAN)], CrossLineLabel.prototype, \"enabled\", void 0);\n  __decorate([Validate(OPT_STRING)], CrossLineLabel.prototype, \"text\", void 0);\n  __decorate([Validate(OPT_FONT_STYLE)], CrossLineLabel.prototype, \"fontStyle\", void 0);\n  __decorate([Validate(OPT_FONT_WEIGHT)], CrossLineLabel.prototype, \"fontWeight\", void 0);\n  __decorate([Validate(NUMBER(0))], CrossLineLabel.prototype, \"fontSize\", void 0);\n  __decorate([Validate(STRING)], CrossLineLabel.prototype, \"fontFamily\", void 0);\n  __decorate([Validate(NUMBER(0))], CrossLineLabel.prototype, \"padding\", void 0);\n  __decorate([Validate(OPT_COLOR_STRING)], CrossLineLabel.prototype, \"color\", void 0);\n  __decorate([Validate(OPT_CROSSLINE_LABEL_POSITION)], CrossLineLabel.prototype, \"position\", void 0);\n  __decorate([Validate(OPT_NUMBER(-360, 360))], CrossLineLabel.prototype, \"rotation\", void 0);\n  __decorate([Validate(OPT_BOOLEAN)], CrossLineLabel.prototype, \"parallel\", void 0);\n  return CrossLineLabel;\n}();\nexport { CrossLineLabel };\nvar CrossLine = /** @class */function () {\n  function CrossLine() {\n    this.id = createId(this);\n    this.enabled = undefined;\n    this.type = undefined;\n    this.range = undefined;\n    this.value = undefined;\n    this.fill = undefined;\n    this.fillOpacity = undefined;\n    this.stroke = undefined;\n    this.strokeWidth = undefined;\n    this.strokeOpacity = undefined;\n    this.lineDash = undefined;\n    this.label = new CrossLineLabel();\n    this.scale = undefined;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = ChartAxisDirection.X;\n    this.group = new Group({\n      name: \"\" + this.id,\n      layer: true,\n      zIndex: CrossLine.LINE_LAYER_ZINDEX\n    });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new Text();\n    this.labelPoint = undefined;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    var _a = this,\n      group = _a.group,\n      crossLineRange = _a.crossLineRange,\n      crossLineLabel = _a.crossLineLabel;\n    group.append([crossLineRange, crossLineLabel]);\n    crossLineRange.pointerEvents = PointerEvents.None;\n  }\n  CrossLine.prototype.update = function (visible) {\n    if (!this.enabled) {\n      return;\n    }\n    this.group.visible = visible;\n    if (!visible) {\n      return;\n    }\n    var dataCreated = this.createNodeData();\n    if (!dataCreated) {\n      this.group.visible = false;\n      return;\n    }\n    this.updateNodes();\n    this.group.zIndex = this.getZIndex(this.isRange);\n  };\n  CrossLine.prototype.updateNodes = function () {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  };\n  CrossLine.prototype.createNodeData = function () {\n    var _a, _b, _c, _d, _e, _f;\n    var _g, _h;\n    var _j = this,\n      scale = _j.scale,\n      gridLength = _j.gridLength,\n      sideFlag = _j.sideFlag,\n      direction = _j.direction,\n      _k = _j.label.position,\n      position = _k === void 0 ? 'top' : _k,\n      clippedRange = _j.clippedRange,\n      _l = _j.strokeWidth,\n      strokeWidth = _l === void 0 ? 0 : _l;\n    if (!scale) {\n      return false;\n    }\n    var isContinuous = scale instanceof ContinuousScale;\n    var bandwidth = (_g = scale.bandwidth, _g !== null && _g !== void 0 ? _g : 0);\n    var clippedRangeClamper = clamper(clippedRange);\n    var xStart, xEnd, yStart, yEnd, clampedYStart, clampedYEnd;\n    _a = __read([0, sideFlag * gridLength], 2), xStart = _a[0], xEnd = _a[1];\n    _b = __read(this.getRange(), 2), yStart = _b[0], yEnd = _b[1];\n    _c = __read([Number(scale.convert(yStart, isContinuous ? clamper : undefined)), scale.convert(yEnd, isContinuous ? clamper : undefined) + bandwidth], 2), clampedYStart = _c[0], clampedYEnd = _c[1];\n    clampedYStart = clippedRangeClamper(clampedYStart);\n    clampedYEnd = clippedRangeClamper(clampedYEnd);\n    _d = __read([Number(scale.convert(yStart)), scale.convert(yEnd) + bandwidth], 2), yStart = _d[0], yEnd = _d[1];\n    var validRange = !isNaN(clampedYStart) && !isNaN(clampedYEnd) && (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange) {\n      var reverse = clampedYStart !== Math.min(clampedYStart, clampedYEnd);\n      if (reverse) {\n        _e = __read([Math.min(clampedYStart, clampedYEnd), Math.max(clampedYStart, clampedYEnd)], 2), clampedYStart = _e[0], clampedYEnd = _e[1];\n        _f = __read([yEnd, yStart], 2), yStart = _f[0], yEnd = _f[1];\n      }\n    }\n    this.isRange = validRange;\n    this.startLine = !isNaN(yStart) && strokeWidth > 0 && yStart === clampedYStart;\n    this.endLine = !isNaN(yEnd) && strokeWidth > 0 && yEnd === clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine) {\n      return false;\n    }\n    this.data = [clampedYStart, clampedYEnd];\n    if (this.label.enabled) {\n      var yDirection = direction === ChartAxisDirection.Y;\n      var _m = (_h = labeldDirectionHandling[position], _h !== null && _h !== void 0 ? _h : {}).c,\n        c = _m === void 0 ? POSITION_TOP_COORDINATES : _m;\n      var _o = c({\n          yDirection: yDirection,\n          xStart: xStart,\n          xEnd: xEnd,\n          yStart: clampedYStart,\n          yEnd: clampedYEnd\n        }),\n        labelX = _o.x,\n        labelY = _o.y;\n      this.labelPoint = {\n        x: labelX,\n        y: labelY\n      };\n    }\n    return true;\n  };\n  CrossLine.prototype.updateRangeNode = function () {\n    var _a;\n    var _b = this,\n      crossLineRange = _b.crossLineRange,\n      sideFlag = _b.sideFlag,\n      gridLength = _b.gridLength,\n      data = _b.data,\n      startLine = _b.startLine,\n      endLine = _b.endLine,\n      isRange = _b.isRange,\n      fill = _b.fill,\n      fillOpacity = _b.fillOpacity,\n      stroke = _b.stroke,\n      strokeWidth = _b.strokeWidth,\n      lineDash = _b.lineDash;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1;\n    crossLineRange.strokeOpacity = (_a = this.strokeOpacity, _a !== null && _a !== void 0 ? _a : 1);\n    crossLineRange.lineDash = lineDash;\n  };\n  CrossLine.prototype.updateLabel = function () {\n    var _a = this,\n      crossLineLabel = _a.crossLineLabel,\n      label = _a.label;\n    if (!label.text) {\n      return;\n    }\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  };\n  CrossLine.prototype.positionLabel = function () {\n    var _a = this,\n      crossLineLabel = _a.crossLineLabel,\n      _b = _a.labelPoint,\n      _c = _b === void 0 ? {} : _b,\n      _d = _c.x,\n      x = _d === void 0 ? undefined : _d,\n      _e = _c.y,\n      y = _e === void 0 ? undefined : _e,\n      _f = _a.label,\n      parallel = _f.parallel,\n      rotation = _f.rotation,\n      _g = _f.position,\n      position = _g === void 0 ? 'top' : _g,\n      _h = _f.padding,\n      padding = _h === void 0 ? 0 : _h,\n      direction = _a.direction,\n      parallelFlipRotation = _a.parallelFlipRotation,\n      regularFlipRotation = _a.regularFlipRotation;\n    if (x === undefined || y === undefined) {\n      return;\n    }\n    var labelRotation = rotation ? normalizeAngle360(toRadians(rotation)) : 0;\n    var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n    var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n    var autoRotation = parallel ? parallelFlipFlag * Math.PI / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n    crossLineLabel.rotation = autoRotation + labelRotation;\n    crossLineLabel.textBaseline = 'middle';\n    crossLineLabel.textAlign = 'center';\n    var bbox = this.computeLabelBBox();\n    if (!bbox) {\n      return;\n    }\n    var yDirection = direction === ChartAxisDirection.Y;\n    var _j = calculateLabelTranslation({\n        yDirection: yDirection,\n        padding: padding,\n        position: position,\n        bbox: bbox\n      }),\n      xTranslation = _j.xTranslation,\n      yTranslation = _j.yTranslation;\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  };\n  CrossLine.prototype.getZIndex = function (isRange) {\n    if (isRange === void 0) {\n      isRange = false;\n    }\n    if (isRange) {\n      return CrossLine.RANGE_LAYER_ZINDEX;\n    }\n    return CrossLine.LINE_LAYER_ZINDEX;\n  };\n  CrossLine.prototype.getRange = function () {\n    var _a;\n    var _b = this,\n      value = _b.value,\n      range = _b.range,\n      scale = _b.scale;\n    var isContinuous = scale instanceof ContinuousScale;\n    var _c = __read(range !== null && range !== void 0 ? range : [value, undefined], 2),\n      start = _c[0],\n      end = _c[1];\n    if (!isContinuous && end === undefined) {\n      end = start;\n    }\n    _a = __read([checkDatum(start, isContinuous), checkDatum(end, isContinuous)], 2), start = _a[0], end = _a[1];\n    if (isContinuous && start === end) {\n      end = undefined;\n    }\n    if (start === undefined && end !== undefined) {\n      start = end;\n      end = undefined;\n    }\n    return [start, end];\n  };\n  CrossLine.prototype.computeLabelBBox = function () {\n    return this.crossLineLabel.computeTransformedBBox();\n  };\n  CrossLine.prototype.calculatePadding = function (padding, seriesRect) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    var _l = this,\n      isRange = _l.isRange,\n      startLine = _l.startLine,\n      endLine = _l.endLine;\n    if (!isRange && !startLine && !endLine) {\n      return;\n    }\n    var crossLineLabelBBox = this.computeLabelBBox();\n    var labelX = (_a = crossLineLabelBBox) === null || _a === void 0 ? void 0 : _a.x;\n    var labelY = (_b = crossLineLabelBBox) === null || _b === void 0 ? void 0 : _b.y;\n    if (labelX == undefined || labelY == undefined) {\n      return;\n    }\n    var labelWidth = (_d = (_c = crossLineLabelBBox) === null || _c === void 0 ? void 0 : _c.width, _d !== null && _d !== void 0 ? _d : 0);\n    var labelHeight = (_f = (_e = crossLineLabelBBox) === null || _e === void 0 ? void 0 : _e.height, _f !== null && _f !== void 0 ? _f : 0);\n    if (labelX + labelWidth >= seriesRect.x + seriesRect.width) {\n      var paddingRight = labelX + labelWidth - (seriesRect.x + seriesRect.width);\n      padding.right = (_g = padding.right, _g !== null && _g !== void 0 ? _g : 0) >= paddingRight ? padding.right : paddingRight;\n    } else if (labelX <= seriesRect.x) {\n      var paddingLeft = seriesRect.x - labelX;\n      padding.left = (_h = padding.left, _h !== null && _h !== void 0 ? _h : 0) >= paddingLeft ? padding.left : paddingLeft;\n    }\n    if (labelY + labelHeight >= seriesRect.y + seriesRect.height) {\n      var paddingbottom = labelY + labelHeight - (seriesRect.y + seriesRect.height);\n      padding.bottom = (_j = padding.bottom, _j !== null && _j !== void 0 ? _j : 0) >= paddingbottom ? padding.bottom : paddingbottom;\n    } else if (labelY <= seriesRect.y) {\n      var paddingTop = seriesRect.y - labelY;\n      padding.top = (_k = padding.top, _k !== null && _k !== void 0 ? _k : 0) >= paddingTop ? padding.top : paddingTop;\n    }\n  };\n  CrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;\n  CrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;\n  CrossLine.className = 'CrossLine';\n  __decorate([Validate(OPT_BOOLEAN)], CrossLine.prototype, \"enabled\", void 0);\n  __decorate([Validate(OPT_CROSSLINE_TYPE)], CrossLine.prototype, \"type\", void 0);\n  __decorate([Validate(OPT_ARRAY(2))], CrossLine.prototype, \"range\", void 0);\n  __decorate([Validate(OPT_COLOR_STRING)], CrossLine.prototype, \"fill\", void 0);\n  __decorate([Validate(OPT_NUMBER(0, 1))], CrossLine.prototype, \"fillOpacity\", void 0);\n  __decorate([Validate(OPT_COLOR_STRING)], CrossLine.prototype, \"stroke\", void 0);\n  __decorate([Validate(OPT_NUMBER())], CrossLine.prototype, \"strokeWidth\", void 0);\n  __decorate([Validate(OPT_NUMBER(0, 1))], CrossLine.prototype, \"strokeOpacity\", void 0);\n  __decorate([Validate(OPT_LINE_DASH)], CrossLine.prototype, \"lineDash\", void 0);\n  return CrossLine;\n}();\nexport { CrossLine };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__read","o","n","m","Symbol","iterator","call","ar","e","next","done","push","value","error","PointerEvents","Group","Text","clamper","ContinuousScale","createId","normalizeAngle360","toRadians","ChartAxisDirection","labeldDirectionHandling","POSITION_TOP_COORDINATES","calculateLabelTranslation","checkDatum","Layers","Range","OPT_ARRAY","OPT_BOOLEAN","OPT_NUMBER","OPT_STRING","OPT_COLOR_STRING","STRING","Validate","OPT_LINE_DASH","OPT_FONT_STYLE","OPT_FONT_WEIGHT","NUMBER","OPTIONAL","predicateWithMessage","CROSSLINE_LABEL_POSITIONS","OPT_CROSSLINE_LABEL_POSITION","v","ctx","includes","OPT_CROSSLINE_TYPE","CrossLineLabel","enabled","undefined","text","fontStyle","fontWeight","fontSize","fontFamily","padding","color","position","rotation","parallel","prototype","CrossLine","id","type","range","fill","fillOpacity","stroke","strokeWidth","strokeOpacity","lineDash","label","scale","clippedRange","Infinity","gridLength","sideFlag","parallelFlipRotation","regularFlipRotation","direction","X","group","name","layer","zIndex","LINE_LAYER_ZINDEX","crossLineRange","crossLineLabel","labelPoint","data","startLine","endLine","isRange","_a","append","pointerEvents","None","update","visible","dataCreated","createNodeData","updateNodes","getZIndex","updateRangeNode","updateLabel","positionLabel","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","isContinuous","bandwidth","clippedRangeClamper","xStart","xEnd","yStart","yEnd","clampedYStart","clampedYEnd","getRange","Number","convert","validRange","isNaN","Math","abs","reverse","min","max","yDirection","Y","_m","_o","labelX","x","labelY","y","x1","x2","y1","y2","labelRotation","parallelFlipFlag","PI","regularFlipFlag","autoRotation","textBaseline","textAlign","bbox","computeLabelBBox","xTranslation","yTranslation","translationX","translationY","RANGE_LAYER_ZINDEX","start","end","computeTransformedBBox","calculatePadding","seriesRect","crossLineLabelBBox","labelWidth","width","labelHeight","height","paddingRight","right","paddingLeft","left","paddingbottom","bottom","paddingTop","top","SERIES_CROSSLINE_LINE_ZINDEX","SERIES_CROSSLINE_RANGE_ZINDEX","className"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/chart/crossline/crossLine.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { PointerEvents } from '../../scene/node';\nimport { Group } from '../../scene/group';\nimport { Text } from '../../scene/shape/text';\nimport { clamper, ContinuousScale } from '../../scale/continuousScale';\nimport { createId } from '../../util/id';\nimport { normalizeAngle360, toRadians } from '../../util/angle';\nimport { ChartAxisDirection } from '../chartAxis';\nimport { labeldDirectionHandling, POSITION_TOP_COORDINATES, calculateLabelTranslation, } from './crossLineLabelPosition';\nimport { checkDatum } from '../../util/value';\nimport { Layers } from '../layers';\nimport { Range } from '../../scene/shape/range';\nimport { OPT_ARRAY, OPT_BOOLEAN, OPT_NUMBER, OPT_STRING, OPT_COLOR_STRING, STRING, Validate, OPT_LINE_DASH, OPT_FONT_STYLE, OPT_FONT_WEIGHT, NUMBER, OPTIONAL, predicateWithMessage, } from '../../util/validation';\nvar CROSSLINE_LABEL_POSITIONS = [\n    'top',\n    'left',\n    'right',\n    'bottom',\n    'topLeft',\n    'topRight',\n    'bottomLeft',\n    'bottomRight',\n    'inside',\n    'insideLeft',\n    'insideRight',\n    'insideTop',\n    'insideBottom',\n    'insideTopLeft',\n    'insideBottomLeft',\n    'insideTopRight',\n    'insideBottomRight',\n];\nvar OPT_CROSSLINE_LABEL_POSITION = predicateWithMessage(function (v, ctx) { return OPTIONAL(v, ctx, function (v) { return CROSSLINE_LABEL_POSITIONS.includes(v); }); }, \"expecting an optional crossLine label position keyword such as 'topLeft', 'topRight' or 'inside'\");\nvar OPT_CROSSLINE_TYPE = predicateWithMessage(function (v, ctx) { return OPTIONAL(v, ctx, function (v) { return v === 'range' || v === 'line'; }); }, \"expecting a crossLine type keyword such as 'range' or 'line'\");\nvar CrossLineLabel = /** @class */ (function () {\n    function CrossLineLabel() {\n        this.enabled = undefined;\n        this.text = undefined;\n        this.fontStyle = undefined;\n        this.fontWeight = undefined;\n        this.fontSize = 14;\n        this.fontFamily = 'Verdana, sans-serif';\n        /**\n         * The padding between the label and the line.\n         */\n        this.padding = 5;\n        /**\n         * The color of the labels.\n         */\n        this.color = 'rgba(87, 87, 87, 1)';\n        this.position = undefined;\n        this.rotation = undefined;\n        this.parallel = undefined;\n    }\n    __decorate([\n        Validate(OPT_BOOLEAN)\n    ], CrossLineLabel.prototype, \"enabled\", void 0);\n    __decorate([\n        Validate(OPT_STRING)\n    ], CrossLineLabel.prototype, \"text\", void 0);\n    __decorate([\n        Validate(OPT_FONT_STYLE)\n    ], CrossLineLabel.prototype, \"fontStyle\", void 0);\n    __decorate([\n        Validate(OPT_FONT_WEIGHT)\n    ], CrossLineLabel.prototype, \"fontWeight\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], CrossLineLabel.prototype, \"fontSize\", void 0);\n    __decorate([\n        Validate(STRING)\n    ], CrossLineLabel.prototype, \"fontFamily\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], CrossLineLabel.prototype, \"padding\", void 0);\n    __decorate([\n        Validate(OPT_COLOR_STRING)\n    ], CrossLineLabel.prototype, \"color\", void 0);\n    __decorate([\n        Validate(OPT_CROSSLINE_LABEL_POSITION)\n    ], CrossLineLabel.prototype, \"position\", void 0);\n    __decorate([\n        Validate(OPT_NUMBER(-360, 360))\n    ], CrossLineLabel.prototype, \"rotation\", void 0);\n    __decorate([\n        Validate(OPT_BOOLEAN)\n    ], CrossLineLabel.prototype, \"parallel\", void 0);\n    return CrossLineLabel;\n}());\nexport { CrossLineLabel };\nvar CrossLine = /** @class */ (function () {\n    function CrossLine() {\n        this.id = createId(this);\n        this.enabled = undefined;\n        this.type = undefined;\n        this.range = undefined;\n        this.value = undefined;\n        this.fill = undefined;\n        this.fillOpacity = undefined;\n        this.stroke = undefined;\n        this.strokeWidth = undefined;\n        this.strokeOpacity = undefined;\n        this.lineDash = undefined;\n        this.label = new CrossLineLabel();\n        this.scale = undefined;\n        this.clippedRange = [-Infinity, Infinity];\n        this.gridLength = 0;\n        this.sideFlag = -1;\n        this.parallelFlipRotation = 0;\n        this.regularFlipRotation = 0;\n        this.direction = ChartAxisDirection.X;\n        this.group = new Group({ name: \"\" + this.id, layer: true, zIndex: CrossLine.LINE_LAYER_ZINDEX });\n        this.crossLineRange = new Range();\n        this.crossLineLabel = new Text();\n        this.labelPoint = undefined;\n        this.data = [];\n        this.startLine = false;\n        this.endLine = false;\n        this.isRange = false;\n        var _a = this, group = _a.group, crossLineRange = _a.crossLineRange, crossLineLabel = _a.crossLineLabel;\n        group.append([crossLineRange, crossLineLabel]);\n        crossLineRange.pointerEvents = PointerEvents.None;\n    }\n    CrossLine.prototype.update = function (visible) {\n        if (!this.enabled) {\n            return;\n        }\n        this.group.visible = visible;\n        if (!visible) {\n            return;\n        }\n        var dataCreated = this.createNodeData();\n        if (!dataCreated) {\n            this.group.visible = false;\n            return;\n        }\n        this.updateNodes();\n        this.group.zIndex = this.getZIndex(this.isRange);\n    };\n    CrossLine.prototype.updateNodes = function () {\n        this.updateRangeNode();\n        if (this.label.enabled) {\n            this.updateLabel();\n            this.positionLabel();\n        }\n    };\n    CrossLine.prototype.createNodeData = function () {\n        var _a, _b, _c, _d, _e, _f;\n        var _g, _h;\n        var _j = this, scale = _j.scale, gridLength = _j.gridLength, sideFlag = _j.sideFlag, direction = _j.direction, _k = _j.label.position, position = _k === void 0 ? 'top' : _k, clippedRange = _j.clippedRange, _l = _j.strokeWidth, strokeWidth = _l === void 0 ? 0 : _l;\n        if (!scale) {\n            return false;\n        }\n        var isContinuous = scale instanceof ContinuousScale;\n        var bandwidth = (_g = scale.bandwidth, (_g !== null && _g !== void 0 ? _g : 0));\n        var clippedRangeClamper = clamper(clippedRange);\n        var xStart, xEnd, yStart, yEnd, clampedYStart, clampedYEnd;\n        _a = __read([0, sideFlag * gridLength], 2), xStart = _a[0], xEnd = _a[1];\n        _b = __read(this.getRange(), 2), yStart = _b[0], yEnd = _b[1];\n        _c = __read([\n            Number(scale.convert(yStart, isContinuous ? clamper : undefined)),\n            scale.convert(yEnd, isContinuous ? clamper : undefined) + bandwidth,\n        ], 2), clampedYStart = _c[0], clampedYEnd = _c[1];\n        clampedYStart = clippedRangeClamper(clampedYStart);\n        clampedYEnd = clippedRangeClamper(clampedYEnd);\n        _d = __read([Number(scale.convert(yStart)), scale.convert(yEnd) + bandwidth], 2), yStart = _d[0], yEnd = _d[1];\n        var validRange = !isNaN(clampedYStart) &&\n            !isNaN(clampedYEnd) &&\n            (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) &&\n            Math.abs(clampedYEnd - clampedYStart) > 0;\n        if (validRange) {\n            var reverse = clampedYStart !== Math.min(clampedYStart, clampedYEnd);\n            if (reverse) {\n                _e = __read([\n                    Math.min(clampedYStart, clampedYEnd),\n                    Math.max(clampedYStart, clampedYEnd),\n                ], 2), clampedYStart = _e[0], clampedYEnd = _e[1];\n                _f = __read([yEnd, yStart], 2), yStart = _f[0], yEnd = _f[1];\n            }\n        }\n        this.isRange = validRange;\n        this.startLine = !isNaN(yStart) && strokeWidth > 0 && yStart === clampedYStart;\n        this.endLine = !isNaN(yEnd) && strokeWidth > 0 && yEnd === clampedYEnd;\n        if (!validRange && !this.startLine && !this.endLine) {\n            return false;\n        }\n        this.data = [clampedYStart, clampedYEnd];\n        if (this.label.enabled) {\n            var yDirection = direction === ChartAxisDirection.Y;\n            var _m = (_h = labeldDirectionHandling[position], (_h !== null && _h !== void 0 ? _h : {})).c, c = _m === void 0 ? POSITION_TOP_COORDINATES : _m;\n            var _o = c({ yDirection: yDirection, xStart: xStart, xEnd: xEnd, yStart: clampedYStart, yEnd: clampedYEnd }), labelX = _o.x, labelY = _o.y;\n            this.labelPoint = {\n                x: labelX,\n                y: labelY,\n            };\n        }\n        return true;\n    };\n    CrossLine.prototype.updateRangeNode = function () {\n        var _a;\n        var _b = this, crossLineRange = _b.crossLineRange, sideFlag = _b.sideFlag, gridLength = _b.gridLength, data = _b.data, startLine = _b.startLine, endLine = _b.endLine, isRange = _b.isRange, fill = _b.fill, fillOpacity = _b.fillOpacity, stroke = _b.stroke, strokeWidth = _b.strokeWidth, lineDash = _b.lineDash;\n        crossLineRange.x1 = 0;\n        crossLineRange.x2 = sideFlag * gridLength;\n        crossLineRange.y1 = data[0];\n        crossLineRange.y2 = data[1];\n        crossLineRange.startLine = startLine;\n        crossLineRange.endLine = endLine;\n        crossLineRange.isRange = isRange;\n        crossLineRange.fill = fill;\n        crossLineRange.fillOpacity = (fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1);\n        crossLineRange.stroke = stroke;\n        crossLineRange.strokeWidth = (strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1);\n        crossLineRange.strokeOpacity = (_a = this.strokeOpacity, (_a !== null && _a !== void 0 ? _a : 1));\n        crossLineRange.lineDash = lineDash;\n    };\n    CrossLine.prototype.updateLabel = function () {\n        var _a = this, crossLineLabel = _a.crossLineLabel, label = _a.label;\n        if (!label.text) {\n            return;\n        }\n        crossLineLabel.fontStyle = label.fontStyle;\n        crossLineLabel.fontWeight = label.fontWeight;\n        crossLineLabel.fontSize = label.fontSize;\n        crossLineLabel.fontFamily = label.fontFamily;\n        crossLineLabel.fill = label.color;\n        crossLineLabel.text = label.text;\n    };\n    CrossLine.prototype.positionLabel = function () {\n        var _a = this, crossLineLabel = _a.crossLineLabel, _b = _a.labelPoint, _c = _b === void 0 ? {} : _b, _d = _c.x, x = _d === void 0 ? undefined : _d, _e = _c.y, y = _e === void 0 ? undefined : _e, _f = _a.label, parallel = _f.parallel, rotation = _f.rotation, _g = _f.position, position = _g === void 0 ? 'top' : _g, _h = _f.padding, padding = _h === void 0 ? 0 : _h, direction = _a.direction, parallelFlipRotation = _a.parallelFlipRotation, regularFlipRotation = _a.regularFlipRotation;\n        if (x === undefined || y === undefined) {\n            return;\n        }\n        var labelRotation = rotation ? normalizeAngle360(toRadians(rotation)) : 0;\n        var parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n        var regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n        var autoRotation = parallel ? (parallelFlipFlag * Math.PI) / 2 : regularFlipFlag === -1 ? Math.PI : 0;\n        crossLineLabel.rotation = autoRotation + labelRotation;\n        crossLineLabel.textBaseline = 'middle';\n        crossLineLabel.textAlign = 'center';\n        var bbox = this.computeLabelBBox();\n        if (!bbox) {\n            return;\n        }\n        var yDirection = direction === ChartAxisDirection.Y;\n        var _j = calculateLabelTranslation({ yDirection: yDirection, padding: padding, position: position, bbox: bbox }), xTranslation = _j.xTranslation, yTranslation = _j.yTranslation;\n        crossLineLabel.translationX = x + xTranslation;\n        crossLineLabel.translationY = y + yTranslation;\n    };\n    CrossLine.prototype.getZIndex = function (isRange) {\n        if (isRange === void 0) { isRange = false; }\n        if (isRange) {\n            return CrossLine.RANGE_LAYER_ZINDEX;\n        }\n        return CrossLine.LINE_LAYER_ZINDEX;\n    };\n    CrossLine.prototype.getRange = function () {\n        var _a;\n        var _b = this, value = _b.value, range = _b.range, scale = _b.scale;\n        var isContinuous = scale instanceof ContinuousScale;\n        var _c = __read((range !== null && range !== void 0 ? range : [value, undefined]), 2), start = _c[0], end = _c[1];\n        if (!isContinuous && end === undefined) {\n            end = start;\n        }\n        _a = __read([checkDatum(start, isContinuous), checkDatum(end, isContinuous)], 2), start = _a[0], end = _a[1];\n        if (isContinuous && start === end) {\n            end = undefined;\n        }\n        if (start === undefined && end !== undefined) {\n            start = end;\n            end = undefined;\n        }\n        return [start, end];\n    };\n    CrossLine.prototype.computeLabelBBox = function () {\n        return this.crossLineLabel.computeTransformedBBox();\n    };\n    CrossLine.prototype.calculatePadding = function (padding, seriesRect) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        var _l = this, isRange = _l.isRange, startLine = _l.startLine, endLine = _l.endLine;\n        if (!isRange && !startLine && !endLine) {\n            return;\n        }\n        var crossLineLabelBBox = this.computeLabelBBox();\n        var labelX = (_a = crossLineLabelBBox) === null || _a === void 0 ? void 0 : _a.x;\n        var labelY = (_b = crossLineLabelBBox) === null || _b === void 0 ? void 0 : _b.y;\n        if (labelX == undefined || labelY == undefined) {\n            return;\n        }\n        var labelWidth = (_d = (_c = crossLineLabelBBox) === null || _c === void 0 ? void 0 : _c.width, (_d !== null && _d !== void 0 ? _d : 0));\n        var labelHeight = (_f = (_e = crossLineLabelBBox) === null || _e === void 0 ? void 0 : _e.height, (_f !== null && _f !== void 0 ? _f : 0));\n        if (labelX + labelWidth >= seriesRect.x + seriesRect.width) {\n            var paddingRight = labelX + labelWidth - (seriesRect.x + seriesRect.width);\n            padding.right = (_g = padding.right, (_g !== null && _g !== void 0 ? _g : 0)) >= paddingRight ? padding.right : paddingRight;\n        }\n        else if (labelX <= seriesRect.x) {\n            var paddingLeft = seriesRect.x - labelX;\n            padding.left = (_h = padding.left, (_h !== null && _h !== void 0 ? _h : 0)) >= paddingLeft ? padding.left : paddingLeft;\n        }\n        if (labelY + labelHeight >= seriesRect.y + seriesRect.height) {\n            var paddingbottom = labelY + labelHeight - (seriesRect.y + seriesRect.height);\n            padding.bottom = (_j = padding.bottom, (_j !== null && _j !== void 0 ? _j : 0)) >= paddingbottom ? padding.bottom : paddingbottom;\n        }\n        else if (labelY <= seriesRect.y) {\n            var paddingTop = seriesRect.y - labelY;\n            padding.top = (_k = padding.top, (_k !== null && _k !== void 0 ? _k : 0)) >= paddingTop ? padding.top : paddingTop;\n        }\n    };\n    CrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;\n    CrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;\n    CrossLine.className = 'CrossLine';\n    __decorate([\n        Validate(OPT_BOOLEAN)\n    ], CrossLine.prototype, \"enabled\", void 0);\n    __decorate([\n        Validate(OPT_CROSSLINE_TYPE)\n    ], CrossLine.prototype, \"type\", void 0);\n    __decorate([\n        Validate(OPT_ARRAY(2))\n    ], CrossLine.prototype, \"range\", void 0);\n    __decorate([\n        Validate(OPT_COLOR_STRING)\n    ], CrossLine.prototype, \"fill\", void 0);\n    __decorate([\n        Validate(OPT_NUMBER(0, 1))\n    ], CrossLine.prototype, \"fillOpacity\", void 0);\n    __decorate([\n        Validate(OPT_COLOR_STRING)\n    ], CrossLine.prototype, \"stroke\", void 0);\n    __decorate([\n        Validate(OPT_NUMBER())\n    ], CrossLine.prototype, \"strokeWidth\", void 0);\n    __decorate([\n        Validate(OPT_NUMBER(0, 1))\n    ], CrossLine.prototype, \"strokeOpacity\", void 0);\n    __decorate([\n        Validate(OPT_LINE_DASH)\n    ], CrossLine.prototype, \"lineDash\", void 0);\n    return CrossLine;\n}());\nexport { CrossLine };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}