{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nimport { Node, RedrawType, SceneChangeDetection } from './node';\nimport { BBox } from './bbox';\nimport { Path2D } from './path2D';\nimport { compoundAscending, ascendingStringNumberUndefined } from '../util/compare';\nvar Group = /** @class */function (_super) {\n  __extends(Group, _super);\n  function Group(opts) {\n    var _a, _b;\n    var _this = _super.call(this) || this;\n    _this.opts = opts;\n    _this.clipPath = new Path2D();\n    _this.opacity = 1;\n    _this.lastBBox = undefined;\n    var _c = opts || {},\n      zIndex = _c.zIndex,\n      zIndexSubOrder = _c.zIndexSubOrder;\n    _this.isContainerNode = true;\n    if (zIndex !== undefined) {\n      _this.zIndex = zIndex;\n    }\n    if (zIndexSubOrder !== undefined) {\n      _this.zIndexSubOrder = zIndexSubOrder;\n    }\n    if ((_a = _this.opts) === null || _a === void 0 ? void 0 : _a.optimiseDirtyTracking) {\n      _this.visibleChildren = {};\n      _this.dirtyChildren = {};\n    }\n    _this.name = (_b = _this.opts) === null || _b === void 0 ? void 0 : _b.name;\n    return _this;\n  }\n  Group.prototype.opacityChanged = function () {\n    if (this.layer) {\n      this.layer.opacity = this.opacity;\n    }\n  };\n  Group.prototype.zIndexChanged = function () {\n    var _a;\n    if (this.layer) {\n      (_a = this._scene) === null || _a === void 0 ? void 0 : _a.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  };\n  Group.prototype.isLayer = function () {\n    return this.layer != null;\n  };\n  Group.prototype.append = function (nodes) {\n    var e_1, _a;\n    _super.prototype.append.call(this, nodes);\n    if (this.dirtyChildren) {\n      nodes = nodes instanceof Array ? nodes : [nodes];\n      try {\n        for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n          var node = nodes_1_1.value;\n          this.dirtyChildren[node.id] = node;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n  };\n  Group.prototype._setScene = function (scene) {\n    var _a;\n    if (this._scene && this.layer) {\n      this._scene.removeLayer(this.layer);\n      this.layer = undefined;\n    }\n    if (this.layer) {\n      throw new Error('AG Charts - unable to deregister scene rendering layer!');\n    }\n    _super.prototype._setScene.call(this, scene);\n    if (scene && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.layer)) {\n      var _b = this.opts || {},\n        zIndex = _b.zIndex,\n        zIndexSubOrder = _b.zIndexSubOrder,\n        name_1 = _b.name;\n      this.layer = scene.addLayer({\n        zIndex: zIndex,\n        zIndexSubOrder: zIndexSubOrder,\n        name: name_1\n      });\n    }\n  };\n  Group.prototype.visibilityChanged = function () {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  };\n  Group.prototype.removeChild = function (node) {\n    _super.prototype.removeChild.call(this, node);\n    if (this.dirtyChildren && this.visibleChildren) {\n      delete this.dirtyChildren[node.id];\n      delete this.visibleChildren[node.id];\n    }\n    return node;\n  };\n  Group.prototype.markDirty = function (source, type) {\n    if (type === void 0) {\n      type = RedrawType.TRIVIAL;\n    }\n    var parentType = type <= RedrawType.MINOR ? RedrawType.TRIVIAL : type;\n    _super.prototype.markDirty.call(this, source, type, parentType);\n    if (source !== this && this.dirtyChildren) {\n      this.dirtyChildren[source.id] = source;\n    }\n  };\n  Group.prototype.markClean = function (opts) {\n    var e_2, _a;\n    // Ensure we update visibility tracking before blowing away dirty flags.\n    this.syncChildVisibility();\n    var _b = this.dirtyChildren,\n      dirtyChildren = _b === void 0 ? {} : _b;\n    try {\n      for (var _c = __values(Object.keys(dirtyChildren)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var key = _d.value;\n        delete dirtyChildren[key];\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    _super.prototype.markClean.call(this, opts);\n  };\n  // We consider a group to be boundless, thus any point belongs to it.\n  Group.prototype.containsPoint = function (_x, _y) {\n    return true;\n  };\n  Group.prototype.computeBBox = function () {\n    var left = Infinity;\n    var right = -Infinity;\n    var top = Infinity;\n    var bottom = -Infinity;\n    this.computeTransformMatrix();\n    this.children.forEach(function (child) {\n      if (!child.visible) {\n        return;\n      }\n      var bbox = child.computeTransformedBBox();\n      if (!bbox) {\n        return;\n      }\n      var x = bbox.x;\n      var y = bbox.y;\n      if (x < left) {\n        left = x;\n      }\n      if (y < top) {\n        top = y;\n      }\n      if (x + bbox.width > right) {\n        right = x + bbox.width;\n      }\n      if (y + bbox.height > bottom) {\n        bottom = y + bbox.height;\n      }\n    });\n    return new BBox(left, top, right - left, bottom - top);\n  };\n  Group.prototype.computeTransformedBBox = function () {\n    return this.computeBBox();\n  };\n  Group.prototype.render = function (renderCtx) {\n    var _a;\n    if (this.layer && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.optimiseDirtyTracking)) {\n      this.optimisedRender(renderCtx);\n      return;\n    }\n    this.basicRender(renderCtx);\n  };\n  Group.prototype.basicRender = function (renderCtx) {\n    var e_3, _a;\n    var _b = this.opts,\n      _c = (_b === void 0 ? {} : _b).name,\n      name = _c === void 0 ? undefined : _c;\n    var _d = this._debug,\n      _e = (_d === void 0 ? {} : _d).consoleLog,\n      consoleLog = _e === void 0 ? false : _e;\n    var _f = this,\n      dirty = _f.dirty,\n      dirtyZIndex = _f.dirtyZIndex,\n      clipPath = _f.clipPath,\n      layer = _f.layer,\n      children = _f.children;\n    var ctx = renderCtx.ctx,\n      forceRender = renderCtx.forceRender,\n      clipBBox = renderCtx.clipBBox,\n      resized = renderCtx.resized,\n      stats = renderCtx.stats;\n    var isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;\n    var isChildDirty = isDirty || children.some(function (n) {\n      return n.dirty >= RedrawType.TRIVIAL;\n    });\n    if (name && consoleLog) {\n      console.log({\n        name: name,\n        group: this,\n        isDirty: isDirty,\n        isChildDirty: isChildDirty,\n        renderCtx: renderCtx,\n        forceRender: forceRender\n      });\n    }\n    if (layer) {\n      // By default there is no need to force redraw a group which has it's own canvas layer\n      // as the layer is independent of any other layer.\n      forceRender = false;\n      // If bounding-box of a layer changes, force re-render.\n      var currentBBox = this.computeBBox();\n      if (this.lastBBox === undefined || !this.lastBBox.equals(currentBBox)) {\n        forceRender = true;\n        this.lastBBox = currentBBox;\n      }\n    }\n    if (!isDirty && !isChildDirty && !forceRender) {\n      if (name && consoleLog && stats) {\n        var counts = this.nodeCount;\n        console.log({\n          name: name,\n          result: 'skipping',\n          renderCtx: renderCtx,\n          counts: counts,\n          group: this\n        });\n      }\n      if (layer && stats) {\n        stats.layersSkipped++;\n        stats.nodesSkipped += this.nodeCount.count;\n      }\n      _super.prototype.markClean.call(this, {\n        recursive: false\n      });\n      // Nothing to do.\n      return;\n    }\n    var groupVisible = this.visible;\n    if (layer) {\n      // Switch context to the canvas layer we use for this group.\n      ctx = layer.context;\n      ctx.save();\n      ctx.setTransform(renderCtx.ctx.getTransform());\n      forceRender = true;\n      layer.clear();\n      if (clipBBox) {\n        var width = clipBBox.width,\n          height = clipBBox.height,\n          x = clipBBox.x,\n          y = clipBBox.y;\n        if (consoleLog) {\n          console.log({\n            name: name,\n            clipBBox: clipBBox,\n            ctxTransform: ctx.getTransform(),\n            renderCtx: renderCtx,\n            group: this\n          });\n        }\n        clipPath.clear();\n        clipPath.rect(x, y, width, height);\n        clipPath.draw(ctx);\n        ctx.clip();\n      }\n    } else {\n      // Only apply opacity if this isn't a distinct layer - opacity will be applied\n      // at composition time.\n      ctx.globalAlpha *= this.opacity;\n    }\n    // A group can have `scaling`, `rotation`, `translation` properties\n    // that are applied to the canvas context before children are rendered,\n    // so all children can be transformed at once.\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    clipBBox = clipBBox ? this.matrix.inverse().transformBBox(clipBBox) : undefined;\n    if (dirtyZIndex) {\n      this.sortChildren();\n      forceRender = true;\n    }\n    // Reduce churn if renderCtx is identical.\n    var renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n    var childRenderContext = renderContextChanged ? __assign(__assign({}, renderCtx), {\n      ctx: ctx,\n      forceRender: forceRender,\n      clipBBox: clipBBox\n    }) : renderCtx;\n    // Render visible children.\n    var skipped = 0;\n    try {\n      for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n        var child = children_1_1.value;\n        if (!child.visible || !groupVisible) {\n          // Skip invisible children, but make sure their dirty flag is reset.\n          child.markClean();\n          if (stats) skipped += child.nodeCount.count;\n          continue;\n        }\n        if (!forceRender && child.dirty === RedrawType.NONE) {\n          // Skip children that don't need to be redrawn.\n          if (stats) skipped += child.nodeCount.count;\n          continue;\n        }\n        // Render marks this node (and children) as clean - no need to explicitly markClean().\n        ctx.save();\n        child.render(childRenderContext);\n        ctx.restore();\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    if (stats) stats.nodesSkipped += skipped;\n    // Render marks this node as clean - no need to explicitly markClean().\n    _super.prototype.render.call(this, renderCtx);\n    if (layer) {\n      if (stats) stats.layersRendered++;\n      ctx.restore();\n      layer.snapshot();\n    }\n    if (name && consoleLog && stats) {\n      var counts = this.nodeCount;\n      console.log({\n        name: name,\n        result: 'rendered',\n        skipped: skipped,\n        renderCtx: renderCtx,\n        counts: counts,\n        group: this\n      });\n    }\n  };\n  Group.prototype.optimisedRender = function (renderCtx) {\n    var e_4, _a, e_5, _b;\n    var _c = this._debug,\n      _d = (_c === void 0 ? {} : _c).consoleLog,\n      consoleLog = _d === void 0 ? false : _d;\n    var _e = this,\n      name = _e.name,\n      dirty = _e.dirty,\n      dirtyZIndex = _e.dirtyZIndex,\n      clipPath = _e.clipPath,\n      layer = _e.layer,\n      _f = _e.dirtyChildren,\n      dirtyChildren = _f === void 0 ? {} : _f,\n      _g = _e.visibleChildren,\n      visibleChildren = _g === void 0 ? {} : _g,\n      groupVisible = _e.visible;\n    var ctx = renderCtx.ctx,\n      clipBBox = renderCtx.clipBBox,\n      resized = renderCtx.resized,\n      stats = renderCtx.stats;\n    if (!layer) {\n      return;\n    }\n    var isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;\n    var isChildDirty = Object.keys(dirtyChildren).length > 0;\n    if (name && consoleLog) {\n      console.log({\n        name: name,\n        group: this,\n        isDirty: isDirty,\n        isChildDirty: isChildDirty,\n        renderCtx: renderCtx\n      });\n    }\n    if (!isDirty && !isChildDirty) {\n      if (name && consoleLog && stats) {\n        var counts = this.nodeCount;\n        console.log({\n          name: name,\n          result: 'skipping',\n          renderCtx: renderCtx,\n          counts: counts,\n          group: this\n        });\n      }\n      if (stats) {\n        stats.layersSkipped++;\n        stats.nodesSkipped += this.nodeCount.count;\n      }\n      _super.prototype.markClean.call(this, {\n        recursive: false\n      });\n      // Nothing to do.\n      return;\n    }\n    // Switch context to the canvas layer we use for this group.\n    ctx = layer.context;\n    ctx.save();\n    ctx.setTransform(renderCtx.ctx.getTransform());\n    layer.clear();\n    if (clipBBox) {\n      var width = clipBBox.width,\n        height = clipBBox.height,\n        x = clipBBox.x,\n        y = clipBBox.y;\n      if (consoleLog) {\n        console.log({\n          name: name,\n          clipBBox: clipBBox,\n          ctxTransform: ctx.getTransform(),\n          renderCtx: renderCtx,\n          group: this\n        });\n      }\n      clipPath.clear();\n      clipPath.rect(x, y, width, height);\n      clipPath.draw(ctx);\n      ctx.clip();\n    }\n    this.syncChildVisibility();\n    // A group can have `scaling`, `rotation`, `translation` properties\n    // that are applied to the canvas context before children are rendered,\n    // so all children can be transformed at once.\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    clipBBox = clipBBox ? this.matrix.inverse().transformBBox(clipBBox) : undefined;\n    if (dirtyZIndex) {\n      this.sortChildren();\n    }\n    // Reduce churn if renderCtx is identical.\n    var renderContextChanged = renderCtx.forceRender !== true || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n    var childRenderContext = renderContextChanged ? __assign(__assign({}, renderCtx), {\n      ctx: ctx,\n      forceRender: true,\n      clipBBox: clipBBox\n    }) : renderCtx;\n    if (consoleLog) {\n      console.log({\n        name: name,\n        visibleChildren: visibleChildren,\n        dirtyChildren: dirtyChildren\n      });\n    }\n    var skipped = 0;\n    if (groupVisible) {\n      try {\n        for (var _h = __values(Object.values(visibleChildren)), _j = _h.next(); !_j.done; _j = _h.next()) {\n          var child = _j.value;\n          ctx.save();\n          child.render(childRenderContext);\n          ctx.restore();\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_j && !_j.done && (_a = _h.return)) _a.call(_h);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    }\n    this.markClean({\n      recursive: false\n    });\n    try {\n      for (var _k = __values(Object.values(dirtyChildren)), _l = _k.next(); !_l.done; _l = _k.next()) {\n        var child = _l.value;\n        child.markClean();\n        delete dirtyChildren[child.id];\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_l && !_l.done && (_b = _k.return)) _b.call(_k);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    if (stats) stats.nodesSkipped += skipped;\n    if (stats) stats.layersRendered++;\n    ctx.restore();\n    layer.snapshot();\n    if (name && consoleLog && stats) {\n      var counts = this.nodeCount;\n      console.log({\n        name: name,\n        result: 'rendered',\n        skipped: skipped,\n        renderCtx: renderCtx,\n        counts: counts,\n        group: this\n      });\n    }\n  };\n  Group.prototype.syncChildVisibility = function () {\n    var e_6, _a;\n    var _b = this,\n      dirtyChildren = _b.dirtyChildren,\n      visibleChildren = _b.visibleChildren;\n    if (!dirtyChildren || !visibleChildren) {\n      return;\n    }\n    try {\n      for (var _c = __values(Object.values(dirtyChildren)), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var child = _d.value;\n        if (!child.visible && visibleChildren[child.id]) {\n          delete visibleChildren[child.id];\n        } else if (child.visible && !visibleChildren[child.id]) {\n          visibleChildren[child.id] = child;\n        }\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  };\n  Group.prototype.sortChildren = function () {\n    this.dirtyZIndex = false;\n    this.children.sort(function (a, b) {\n      var _a, _b;\n      return compoundAscending(__spread([a.zIndex], (_a = a.zIndexSubOrder, _a !== null && _a !== void 0 ? _a : [undefined, undefined]), [a.serialNumber]), __spread([b.zIndex], (_b = b.zIndexSubOrder, _b !== null && _b !== void 0 ? _b : [undefined, undefined]), [b.serialNumber]), ascendingStringNumberUndefined);\n    });\n  };\n  Group.className = 'Group';\n  __decorate([SceneChangeDetection({\n    convertor: function (v) {\n      return Math.min(1, Math.max(0, v));\n    },\n    changeCb: function (o) {\n      return o.opacityChanged();\n    }\n  })], Group.prototype, \"opacity\", void 0);\n  return Group;\n}(Node);\nexport { Group };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","ar","e","push","error","__spread","concat","Node","RedrawType","SceneChangeDetection","BBox","Path2D","compoundAscending","ascendingStringNumberUndefined","Group","_super","opts","_a","_b","_this","clipPath","opacity","lastBBox","undefined","_c","zIndex","zIndexSubOrder","isContainerNode","optimiseDirtyTracking","visibleChildren","dirtyChildren","name","opacityChanged","layer","zIndexChanged","_scene","moveLayer","isLayer","append","nodes","e_1","nodes_1","nodes_1_1","node","id","e_1_1","return","_setScene","scene","removeLayer","Error","name_1","addLayer","visibilityChanged","enabled","visible","removeChild","markDirty","source","type","TRIVIAL","parentType","MINOR","markClean","e_2","syncChildVisibility","keys","_d","e_2_1","containsPoint","_x","_y","computeBBox","left","Infinity","right","top","bottom","computeTransformMatrix","children","forEach","child","bbox","computeTransformedBBox","x","y","width","height","render","renderCtx","optimisedRender","basicRender","e_3","_debug","_e","consoleLog","_f","dirty","dirtyZIndex","ctx","forceRender","clipBBox","resized","stats","isDirty","isChildDirty","some","console","log","group","currentBBox","equals","counts","nodeCount","result","layersSkipped","nodesSkipped","count","recursive","groupVisible","context","save","setTransform","getTransform","clear","ctxTransform","rect","draw","clip","globalAlpha","matrix","toContext","inverse","transformBBox","sortChildren","renderContextChanged","childRenderContext","skipped","children_1","children_1_1","NONE","restore","e_3_1","layersRendered","snapshot","e_4","e_5","_g","_h","values","_j","e_4_1","_k","_l","e_5_1","e_6","e_6_1","sort","a","serialNumber","className","convertor","v","Math","min","max","changeCb"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/scene/group.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { Node, RedrawType, SceneChangeDetection } from './node';\nimport { BBox } from './bbox';\nimport { Path2D } from './path2D';\nimport { compoundAscending, ascendingStringNumberUndefined } from '../util/compare';\nvar Group = /** @class */ (function (_super) {\n    __extends(Group, _super);\n    function Group(opts) {\n        var _a, _b;\n        var _this = _super.call(this) || this;\n        _this.opts = opts;\n        _this.clipPath = new Path2D();\n        _this.opacity = 1;\n        _this.lastBBox = undefined;\n        var _c = opts || {}, zIndex = _c.zIndex, zIndexSubOrder = _c.zIndexSubOrder;\n        _this.isContainerNode = true;\n        if (zIndex !== undefined) {\n            _this.zIndex = zIndex;\n        }\n        if (zIndexSubOrder !== undefined) {\n            _this.zIndexSubOrder = zIndexSubOrder;\n        }\n        if ((_a = _this.opts) === null || _a === void 0 ? void 0 : _a.optimiseDirtyTracking) {\n            _this.visibleChildren = {};\n            _this.dirtyChildren = {};\n        }\n        _this.name = (_b = _this.opts) === null || _b === void 0 ? void 0 : _b.name;\n        return _this;\n    }\n    Group.prototype.opacityChanged = function () {\n        if (this.layer) {\n            this.layer.opacity = this.opacity;\n        }\n    };\n    Group.prototype.zIndexChanged = function () {\n        var _a;\n        if (this.layer) {\n            (_a = this._scene) === null || _a === void 0 ? void 0 : _a.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n        }\n    };\n    Group.prototype.isLayer = function () {\n        return this.layer != null;\n    };\n    Group.prototype.append = function (nodes) {\n        var e_1, _a;\n        _super.prototype.append.call(this, nodes);\n        if (this.dirtyChildren) {\n            nodes = nodes instanceof Array ? nodes : [nodes];\n            try {\n                for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n                    var node = nodes_1_1.value;\n                    this.dirtyChildren[node.id] = node;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n    };\n    Group.prototype._setScene = function (scene) {\n        var _a;\n        if (this._scene && this.layer) {\n            this._scene.removeLayer(this.layer);\n            this.layer = undefined;\n        }\n        if (this.layer) {\n            throw new Error('AG Charts - unable to deregister scene rendering layer!');\n        }\n        _super.prototype._setScene.call(this, scene);\n        if (scene && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.layer)) {\n            var _b = this.opts || {}, zIndex = _b.zIndex, zIndexSubOrder = _b.zIndexSubOrder, name_1 = _b.name;\n            this.layer = scene.addLayer({ zIndex: zIndex, zIndexSubOrder: zIndexSubOrder, name: name_1 });\n        }\n    };\n    Group.prototype.visibilityChanged = function () {\n        if (this.layer) {\n            this.layer.enabled = this.visible;\n        }\n    };\n    Group.prototype.removeChild = function (node) {\n        _super.prototype.removeChild.call(this, node);\n        if (this.dirtyChildren && this.visibleChildren) {\n            delete this.dirtyChildren[node.id];\n            delete this.visibleChildren[node.id];\n        }\n        return node;\n    };\n    Group.prototype.markDirty = function (source, type) {\n        if (type === void 0) { type = RedrawType.TRIVIAL; }\n        var parentType = type <= RedrawType.MINOR ? RedrawType.TRIVIAL : type;\n        _super.prototype.markDirty.call(this, source, type, parentType);\n        if (source !== this && this.dirtyChildren) {\n            this.dirtyChildren[source.id] = source;\n        }\n    };\n    Group.prototype.markClean = function (opts) {\n        var e_2, _a;\n        // Ensure we update visibility tracking before blowing away dirty flags.\n        this.syncChildVisibility();\n        var _b = this.dirtyChildren, dirtyChildren = _b === void 0 ? {} : _b;\n        try {\n            for (var _c = __values(Object.keys(dirtyChildren)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var key = _d.value;\n                delete dirtyChildren[key];\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        _super.prototype.markClean.call(this, opts);\n    };\n    // We consider a group to be boundless, thus any point belongs to it.\n    Group.prototype.containsPoint = function (_x, _y) {\n        return true;\n    };\n    Group.prototype.computeBBox = function () {\n        var left = Infinity;\n        var right = -Infinity;\n        var top = Infinity;\n        var bottom = -Infinity;\n        this.computeTransformMatrix();\n        this.children.forEach(function (child) {\n            if (!child.visible) {\n                return;\n            }\n            var bbox = child.computeTransformedBBox();\n            if (!bbox) {\n                return;\n            }\n            var x = bbox.x;\n            var y = bbox.y;\n            if (x < left) {\n                left = x;\n            }\n            if (y < top) {\n                top = y;\n            }\n            if (x + bbox.width > right) {\n                right = x + bbox.width;\n            }\n            if (y + bbox.height > bottom) {\n                bottom = y + bbox.height;\n            }\n        });\n        return new BBox(left, top, right - left, bottom - top);\n    };\n    Group.prototype.computeTransformedBBox = function () {\n        return this.computeBBox();\n    };\n    Group.prototype.render = function (renderCtx) {\n        var _a;\n        if (this.layer && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.optimiseDirtyTracking)) {\n            this.optimisedRender(renderCtx);\n            return;\n        }\n        this.basicRender(renderCtx);\n    };\n    Group.prototype.basicRender = function (renderCtx) {\n        var e_3, _a;\n        var _b = this.opts, _c = (_b === void 0 ? {} : _b).name, name = _c === void 0 ? undefined : _c;\n        var _d = this._debug, _e = (_d === void 0 ? {} : _d).consoleLog, consoleLog = _e === void 0 ? false : _e;\n        var _f = this, dirty = _f.dirty, dirtyZIndex = _f.dirtyZIndex, clipPath = _f.clipPath, layer = _f.layer, children = _f.children;\n        var ctx = renderCtx.ctx, forceRender = renderCtx.forceRender, clipBBox = renderCtx.clipBBox, resized = renderCtx.resized, stats = renderCtx.stats;\n        var isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;\n        var isChildDirty = isDirty || children.some(function (n) { return n.dirty >= RedrawType.TRIVIAL; });\n        if (name && consoleLog) {\n            console.log({ name: name, group: this, isDirty: isDirty, isChildDirty: isChildDirty, renderCtx: renderCtx, forceRender: forceRender });\n        }\n        if (layer) {\n            // By default there is no need to force redraw a group which has it's own canvas layer\n            // as the layer is independent of any other layer.\n            forceRender = false;\n            // If bounding-box of a layer changes, force re-render.\n            var currentBBox = this.computeBBox();\n            if (this.lastBBox === undefined || !this.lastBBox.equals(currentBBox)) {\n                forceRender = true;\n                this.lastBBox = currentBBox;\n            }\n        }\n        if (!isDirty && !isChildDirty && !forceRender) {\n            if (name && consoleLog && stats) {\n                var counts = this.nodeCount;\n                console.log({ name: name, result: 'skipping', renderCtx: renderCtx, counts: counts, group: this });\n            }\n            if (layer && stats) {\n                stats.layersSkipped++;\n                stats.nodesSkipped += this.nodeCount.count;\n            }\n            _super.prototype.markClean.call(this, { recursive: false });\n            // Nothing to do.\n            return;\n        }\n        var groupVisible = this.visible;\n        if (layer) {\n            // Switch context to the canvas layer we use for this group.\n            ctx = layer.context;\n            ctx.save();\n            ctx.setTransform(renderCtx.ctx.getTransform());\n            forceRender = true;\n            layer.clear();\n            if (clipBBox) {\n                var width = clipBBox.width, height = clipBBox.height, x = clipBBox.x, y = clipBBox.y;\n                if (consoleLog) {\n                    console.log({ name: name, clipBBox: clipBBox, ctxTransform: ctx.getTransform(), renderCtx: renderCtx, group: this });\n                }\n                clipPath.clear();\n                clipPath.rect(x, y, width, height);\n                clipPath.draw(ctx);\n                ctx.clip();\n            }\n        }\n        else {\n            // Only apply opacity if this isn't a distinct layer - opacity will be applied\n            // at composition time.\n            ctx.globalAlpha *= this.opacity;\n        }\n        // A group can have `scaling`, `rotation`, `translation` properties\n        // that are applied to the canvas context before children are rendered,\n        // so all children can be transformed at once.\n        this.computeTransformMatrix();\n        this.matrix.toContext(ctx);\n        clipBBox = clipBBox ? this.matrix.inverse().transformBBox(clipBBox) : undefined;\n        if (dirtyZIndex) {\n            this.sortChildren();\n            forceRender = true;\n        }\n        // Reduce churn if renderCtx is identical.\n        var renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n        var childRenderContext = renderContextChanged ? __assign(__assign({}, renderCtx), { ctx: ctx, forceRender: forceRender, clipBBox: clipBBox }) : renderCtx;\n        // Render visible children.\n        var skipped = 0;\n        try {\n            for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n                var child = children_1_1.value;\n                if (!child.visible || !groupVisible) {\n                    // Skip invisible children, but make sure their dirty flag is reset.\n                    child.markClean();\n                    if (stats)\n                        skipped += child.nodeCount.count;\n                    continue;\n                }\n                if (!forceRender && child.dirty === RedrawType.NONE) {\n                    // Skip children that don't need to be redrawn.\n                    if (stats)\n                        skipped += child.nodeCount.count;\n                    continue;\n                }\n                // Render marks this node (and children) as clean - no need to explicitly markClean().\n                ctx.save();\n                child.render(childRenderContext);\n                ctx.restore();\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        if (stats)\n            stats.nodesSkipped += skipped;\n        // Render marks this node as clean - no need to explicitly markClean().\n        _super.prototype.render.call(this, renderCtx);\n        if (layer) {\n            if (stats)\n                stats.layersRendered++;\n            ctx.restore();\n            layer.snapshot();\n        }\n        if (name && consoleLog && stats) {\n            var counts = this.nodeCount;\n            console.log({ name: name, result: 'rendered', skipped: skipped, renderCtx: renderCtx, counts: counts, group: this });\n        }\n    };\n    Group.prototype.optimisedRender = function (renderCtx) {\n        var e_4, _a, e_5, _b;\n        var _c = this._debug, _d = (_c === void 0 ? {} : _c).consoleLog, consoleLog = _d === void 0 ? false : _d;\n        var _e = this, name = _e.name, dirty = _e.dirty, dirtyZIndex = _e.dirtyZIndex, clipPath = _e.clipPath, layer = _e.layer, _f = _e.dirtyChildren, dirtyChildren = _f === void 0 ? {} : _f, _g = _e.visibleChildren, visibleChildren = _g === void 0 ? {} : _g, groupVisible = _e.visible;\n        var ctx = renderCtx.ctx, clipBBox = renderCtx.clipBBox, resized = renderCtx.resized, stats = renderCtx.stats;\n        if (!layer) {\n            return;\n        }\n        var isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;\n        var isChildDirty = Object.keys(dirtyChildren).length > 0;\n        if (name && consoleLog) {\n            console.log({ name: name, group: this, isDirty: isDirty, isChildDirty: isChildDirty, renderCtx: renderCtx });\n        }\n        if (!isDirty && !isChildDirty) {\n            if (name && consoleLog && stats) {\n                var counts = this.nodeCount;\n                console.log({ name: name, result: 'skipping', renderCtx: renderCtx, counts: counts, group: this });\n            }\n            if (stats) {\n                stats.layersSkipped++;\n                stats.nodesSkipped += this.nodeCount.count;\n            }\n            _super.prototype.markClean.call(this, { recursive: false });\n            // Nothing to do.\n            return;\n        }\n        // Switch context to the canvas layer we use for this group.\n        ctx = layer.context;\n        ctx.save();\n        ctx.setTransform(renderCtx.ctx.getTransform());\n        layer.clear();\n        if (clipBBox) {\n            var width = clipBBox.width, height = clipBBox.height, x = clipBBox.x, y = clipBBox.y;\n            if (consoleLog) {\n                console.log({ name: name, clipBBox: clipBBox, ctxTransform: ctx.getTransform(), renderCtx: renderCtx, group: this });\n            }\n            clipPath.clear();\n            clipPath.rect(x, y, width, height);\n            clipPath.draw(ctx);\n            ctx.clip();\n        }\n        this.syncChildVisibility();\n        // A group can have `scaling`, `rotation`, `translation` properties\n        // that are applied to the canvas context before children are rendered,\n        // so all children can be transformed at once.\n        this.computeTransformMatrix();\n        this.matrix.toContext(ctx);\n        clipBBox = clipBBox ? this.matrix.inverse().transformBBox(clipBBox) : undefined;\n        if (dirtyZIndex) {\n            this.sortChildren();\n        }\n        // Reduce churn if renderCtx is identical.\n        var renderContextChanged = renderCtx.forceRender !== true || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n        var childRenderContext = renderContextChanged\n            ? __assign(__assign({}, renderCtx), { ctx: ctx, forceRender: true, clipBBox: clipBBox }) : renderCtx;\n        if (consoleLog) {\n            console.log({ name: name, visibleChildren: visibleChildren, dirtyChildren: dirtyChildren });\n        }\n        var skipped = 0;\n        if (groupVisible) {\n            try {\n                for (var _h = __values(Object.values(visibleChildren)), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var child = _j.value;\n                    ctx.save();\n                    child.render(childRenderContext);\n                    ctx.restore();\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (_j && !_j.done && (_a = _h.return)) _a.call(_h);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n        }\n        this.markClean({ recursive: false });\n        try {\n            for (var _k = __values(Object.values(dirtyChildren)), _l = _k.next(); !_l.done; _l = _k.next()) {\n                var child = _l.value;\n                child.markClean();\n                delete dirtyChildren[child.id];\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (_l && !_l.done && (_b = _k.return)) _b.call(_k);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        if (stats)\n            stats.nodesSkipped += skipped;\n        if (stats)\n            stats.layersRendered++;\n        ctx.restore();\n        layer.snapshot();\n        if (name && consoleLog && stats) {\n            var counts = this.nodeCount;\n            console.log({ name: name, result: 'rendered', skipped: skipped, renderCtx: renderCtx, counts: counts, group: this });\n        }\n    };\n    Group.prototype.syncChildVisibility = function () {\n        var e_6, _a;\n        var _b = this, dirtyChildren = _b.dirtyChildren, visibleChildren = _b.visibleChildren;\n        if (!dirtyChildren || !visibleChildren) {\n            return;\n        }\n        try {\n            for (var _c = __values(Object.values(dirtyChildren)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var child = _d.value;\n                if (!child.visible && visibleChildren[child.id]) {\n                    delete visibleChildren[child.id];\n                }\n                else if (child.visible && !visibleChildren[child.id]) {\n                    visibleChildren[child.id] = child;\n                }\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n    };\n    Group.prototype.sortChildren = function () {\n        this.dirtyZIndex = false;\n        this.children.sort(function (a, b) {\n            var _a, _b;\n            return compoundAscending(__spread([a.zIndex], (_a = a.zIndexSubOrder, (_a !== null && _a !== void 0 ? _a : [undefined, undefined])), [a.serialNumber]), __spread([b.zIndex], (_b = b.zIndexSubOrder, (_b !== null && _b !== void 0 ? _b : [undefined, undefined])), [b.serialNumber]), ascendingStringNumberUndefined);\n        });\n    };\n    Group.className = 'Group';\n    __decorate([\n        SceneChangeDetection({\n            convertor: function (v) { return Math.min(1, Math.max(0, v)); },\n            changeCb: function (o) { return o.opacityChanged(); },\n        })\n    ], Group.prototype, \"opacity\", void 0);\n    return Group;\n}(Node));\nexport { Group };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}