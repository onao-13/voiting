{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.typed-array.find-last.js\");\nrequire(\"core-js/modules/es.typed-array.find-last-index.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nexports.__esModule = true;\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar Model_1 = require(\"../model/Model\");\nvar DataDiffer_1 = require(\"./DataDiffer\");\nvar dataProvider_1 = require(\"./helper/dataProvider\");\nvar dimensionHelper_1 = require(\"./helper/dimensionHelper\");\nvar DataDimensionInfo_1 = require(\"./DataDimensionInfo\");\nvar types_1 = require(\"../util/types\");\nvar model_1 = require(\"../util/model\");\nvar innerStore_1 = require(\"../util/innerStore\");\nvar dataValueHelper_1 = require(\"./helper/dataValueHelper\");\nvar Source_1 = require(\"./Source\");\nvar mathFloor = Math.floor;\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1;\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\nvar defaultDimValueGetters;\nvar prepareInvertedIndex;\nvar getIndicesCtor;\nvar prepareStorage;\nvar getRawIndexWithoutIndices;\nvar getRawIndexWithIndices;\nvar getId;\nvar getIdNameFromStore;\nvar makeIdFromName;\nvar normalizeDimensions;\nvar validateDimensions;\nvar cloneListForMapAndSample;\nvar getInitialExtent;\nvar setItemDataAndSeriesIndex;\nvar transferProperties;\nvar List = function () {\n  function List(dimensions, hostModel) {\n    this.type = 'list';\n    this._count = 0;\n    this._rawCount = 0;\n    this._storage = {};\n    this._storageArr = [];\n    this._nameList = [];\n    this._idList = [];\n    this._visual = {};\n    this._layout = {};\n    this._itemVisuals = [];\n    this._itemLayouts = [];\n    this._graphicEls = [];\n    this._rawExtent = {};\n    this._extent = {};\n    this._approximateExtent = {};\n    this._calculationInfo = {};\n    this.hasItemOption = true;\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    this.getRawIndex = getRawIndexWithoutIndices;\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new DataDimensionInfo_1[\"default\"]({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof DataDimensionInfo_1[\"default\"]) ? new DataDimensionInfo_1[\"default\"](dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      dimensionInfo.index = i;\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n        this._nameOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n        this._idOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n    }\n    this.dimensions = dimensionNames;\n    this._dimensionInfos = dimensionInfos;\n    this.hostModel = hostModel;\n    this._dimensionsSummary = dimensionHelper_1.summarizeDimensions(this);\n    this._invertedIndicesMap = invertedIndicesMap;\n    this.userOutput = this._dimensionsSummary.userOutput;\n  }\n  List.prototype.getDimension = function (dim) {\n    if (typeof dim === 'number' || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n      dim = this.dimensions[dim];\n    }\n    return dim;\n  };\n  List.prototype.getDimensionInfo = function (dim) {\n    return this._dimensionInfos[this.getDimension(dim)];\n  };\n  List.prototype.getDimensionsOnCoord = function () {\n    return this._dimensionsSummary.dataDimsOnCoord.slice();\n  };\n  List.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimensionsSummary;\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n  List.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimensionsSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  List.prototype.initData = function (data, nameList, dimValueGetter) {\n    var notProvider = Source_1.isSourceInstance(data) || zrUtil.isArrayLike(data);\n    var provider = notProvider ? new dataProvider_1.DefaultDataProvider(data, this.dimensions.length) : data;\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(notProvider || zrUtil.isFunction(provider.getItem) && zrUtil.isFunction(provider.count), 'Inavlid data provider.');\n    }\n    this._rawData = provider;\n    var sourceFormat = provider.getSource().sourceFormat;\n    this._storage = {};\n    this._indices = null;\n    this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY || !!provider.fillStorage;\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n    if (!dimValueGetter) {\n      this.hasItemOption = false;\n    }\n    this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat];\n    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n    this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;\n    this._rawExtent = {};\n    this._initDataFromProvider(0, provider.count());\n    if (provider.pure) {\n      this.hasItemOption = false;\n    }\n  };\n  List.prototype.getProvider = function () {\n    return this._rawData;\n  };\n  List.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n    var rawData = this._rawData;\n    var start = this.count();\n    rawData.appendData(data);\n    var end = rawData.count();\n    if (!rawData.persistent) {\n      end += start;\n    }\n    this._initDataFromProvider(start, end, true);\n  };\n  List.prototype.appendValues = function (values, names) {\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, names ? names.length : 0);\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n      prepareStorage(storage, this._dimensionInfos[dim], end, true);\n    }\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var emptyDataItem = [];\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start;\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);\n        storageArr[dimIdx][idx] = val;\n        var dimRawExtent = rawExtentArr[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n      if (names) {\n        this._nameList[idx] = names[sourceIdx];\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n  List.prototype._initDataFromProvider = function (start, end, append) {\n    if (start >= end) {\n      return;\n    }\n    var rawData = this._rawData;\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var dimensionInfoMap = this._dimensionInfos;\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var rawExtent = this._rawExtent;\n    var sourceFormat = rawData.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL;\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n      prepareStorage(storage, dimensionInfoMap[dim], end, append);\n    }\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n    if (rawData.fillStorage) {\n      rawData.fillStorage(start, end, storageArr, rawExtentArr);\n    } else {\n      var dataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        dataItem = rawData.getItem(idx, dataItem);\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dim = dimensions[dimIdx];\n          var dimStorage = storageArr[dimIdx];\n          var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtentArr[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n        if (isFormatOriginal && !rawData.pure && dataItem) {\n          var itemName = dataItem.name;\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = model_1.convertOptionIdName(itemName, null);\n          }\n          var itemId = dataItem.id;\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = model_1.convertOptionIdName(itemId, null);\n          }\n        }\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n    if (!rawData.persistent && rawData.clean) {\n      rawData.clean();\n    }\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n  List.prototype.count = function () {\n    return this._count;\n  };\n  List.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count;\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this);\n      newIndices = new Ctor(this.count());\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n    return newIndices;\n  };\n  List.prototype.getByDimIdx = function (dimIdx, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n    var dimStore = this._storageArr[dimIdx];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  List.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  List.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  List.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    if (!zrUtil.isArray(dimensions)) {\n      idx = dimensions;\n      dimensions = this.dimensions;\n    }\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n      values.push(this.get(dimensions[i], idx));\n    }\n    return values;\n  };\n  List.prototype.hasValue = function (idx) {\n    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  List.prototype.getDataExtent = function (dim) {\n    dim = this.getDimension(dim);\n    var dimData = this._storage[dim];\n    var initialExtent = getInitialExtent();\n    if (!dimData) {\n      return initialExtent;\n    }\n    var currEnd = this.count();\n    var useRaw = !this._indices;\n    var dimExtent;\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n    dimExtent = this._extent[dim];\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  List.prototype.getApproximateExtent = function (dim) {\n    dim = this.getDimension(dim);\n    return this._approximateExtent[dim] || this.getDataExtent(dim);\n  };\n  List.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n  List.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n  List.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  List.prototype.getSum = function (dim) {\n    var dimData = this._storage[dim];\n    var sum = 0;\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n    return sum;\n  };\n  List.prototype.getMedian = function (dim) {\n    var dimDataArray = [];\n    this.each(dim, function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    });\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count();\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  List.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n    var rawIndex = invertedIndices[value];\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n    return rawIndex;\n  };\n  List.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  List.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n    if (!this._indices) {\n      return rawIndex;\n    }\n    var indices = this._indices;\n    var rawDataIndex = indices[rawIndex];\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n    var left = 0;\n    var right = this._count - 1;\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -1;\n  };\n  List.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var nearestIndices = [];\n    if (!dimData) {\n      return nearestIndices;\n    }\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0;\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n      if (dist <= maxDistance) {\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n  List.prototype.getRawDataItem = function (idx) {\n    if (!this._rawData.persistent) {\n      var val = [];\n      for (var i = 0; i < this.dimensions.length; i++) {\n        var dim = this.dimensions[i];\n        val.push(this.get(dim, idx));\n      }\n      return val;\n    } else {\n      return this._rawData.getItem(this.getRawIndex(idx));\n    }\n  };\n  List.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);\n    }\n    if (name == null) {\n      name = '';\n    }\n    return name;\n  };\n  List.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n  List.prototype.each = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n    if (!this._count) {\n      return;\n    }\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n    var dimSize = dimNames.length;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var storageArr = this._storageArr;\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i);\n      switch (dimSize) {\n        case 0:\n          cb.call(fCtx, i);\n          break;\n        case 1:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);\n          break;\n        case 2:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);\n          break;\n        default:\n          var k = 0;\n          var value = [];\n          for (; k < dimSize; k++) {\n            value[k] = storageArr[dimIndices[k]][rawIdx];\n          }\n          value[k] = i;\n          cb.apply(fCtx, value);\n      }\n    }\n  };\n  List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n    if (!this._count) {\n      return;\n    }\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n    var count = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dimNames.length;\n    var offset = 0;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var dim0 = dimIndices[0];\n    var storageArr = this._storageArr;\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = this.getRawIndex(i);\n      if (dimSize === 0) {\n        keep = cb.call(fCtx, i);\n      } else if (dimSize === 1) {\n        var val = storageArr[dim0][rawIdx];\n        keep = cb.call(fCtx, val, i);\n      } else {\n        var k = 0;\n        for (; k < dimSize; k++) {\n          value[k] = storageArr[dimIndices[k]][rawIdx];\n        }\n        value[k] = i;\n        keep = cb.apply(fCtx, value);\n      }\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    }\n    if (offset < count) {\n      this._indices = newIndices;\n    }\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n  List.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n    var len = this._count;\n    if (!len) {\n      return;\n    }\n    var dimensions = [];\n    for (var dim in range) {\n      if (range.hasOwnProperty(dim)) {\n        dimensions.push(dim);\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimensions);\n    }\n    var dimSize = dimensions.length;\n    if (!dimSize) {\n      return;\n    }\n    var originalCount = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dimensions[0];\n    var dimIndices = map(dimensions, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storageArr = this._storageArr;\n    var quickFinished = false;\n    if (!this._indices) {\n      var idx = 0;\n      if (dimSize === 1) {\n        var dimStorage = storageArr[dimIndices[0]];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storageArr[dimIndices[0]];\n        var dimStorage2 = storageArr[dimIndices[1]];\n        var min2 = range[dimensions[1]][0];\n        var max2 = range[dimensions[1]][1];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i];\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      }\n    }\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = this.getRawIndex(i);\n          var val = storageArr[dimIndices[0]][rawIndex];\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = this.getRawIndex(i);\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dimensions[k];\n            var val = storageArr[dimIndices[k]][rawIndex];\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n          if (keep) {\n            newIndices[offset++] = this.getRawIndex(i);\n          }\n        }\n      }\n    }\n    if (offset < originalCount) {\n      this._indices = newIndices;\n    }\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n  List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    ctx = ctx || ctxCompat || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n  List.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n    var list = cloneListForMapAndSample(this, dimNames);\n    var storage = list._storage;\n    list._indices = this._indices;\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    var tmpRetValue = [];\n    var dimSize = dimNames.length;\n    var dataCount = this.count();\n    var values = [];\n    var rawExtent = list._rawExtent;\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n        values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);\n      }\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(fCtx, values);\n      if (retValue != null) {\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n        var rawIndex = this.getRawIndex(dataIndex);\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dimNames[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = storage[dim];\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n    return list;\n  };\n  List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this, [dimension]);\n    var targetStorage = list._storage;\n    var frameValues = [];\n    var frameSize = mathFloor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = list._rawExtent[dimension];\n    var newIndices = new (getIndicesCtor(this))(len);\n    var offset = 0;\n    for (var i = 0; i < len; i += frameSize) {\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n      dimStore[sampleFrameIdx] = value;\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n      newIndices[offset++] = sampleFrameIdx;\n    }\n    list._count = offset;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n  List.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this, []);\n    var targetStorage = list._storage;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var newIndices = new (getIndicesCtor(this))(len);\n    var sampledIndex = 0;\n    var frameSize = mathFloor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    newIndices[sampledIndex++] = currentRawIndex;\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          continue;\n        }\n        avgY += y;\n      }\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          continue;\n        }\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex;\n        }\n      }\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex;\n    }\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    list._count = sampledIndex;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n  List.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model_1[\"default\"](dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  List.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer_1[\"default\"](otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  List.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n  List.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  List.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n    if (val == null) {\n      return this.getVisual(key);\n    }\n    return val;\n  };\n  List.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  List.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n    var val = itemVisual[key];\n    if (val == null) {\n      val = this.getVisual(key);\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n      itemVisual[key] = val;\n    }\n    return val;\n  };\n  List.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  List.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n  List.prototype.setLayout = function (key, val) {\n    if (isObject(key)) {\n      for (var name_1 in key) {\n        if (key.hasOwnProperty(name_1)) {\n          this.setLayout(name_1, key[name_1]);\n        }\n      }\n      return;\n    }\n    this._layout[key] = val;\n  };\n  List.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  List.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  List.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  List.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  List.prototype.setItemGraphicEl = function (idx, el) {\n    var hostModel = this.hostModel;\n    if (el) {\n      var ecData = innerStore_1.getECData(el);\n      ecData.dataIndex = idx;\n      ecData.dataType = this.dataType;\n      ecData.seriesIndex = hostModel && hostModel.seriesIndex;\n      if (el.type === 'group') {\n        el.traverse(setItemDataAndSeriesIndex, el);\n      }\n    }\n    this._graphicEls[idx] = el;\n  };\n  List.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n  List.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  List.prototype.cloneShallow = function (list) {\n    if (!list) {\n      var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);\n      list = new List(dimensionInfoList, this.hostModel);\n    }\n    list._storage = this._storage;\n    list._storageArr = this._storageArr;\n    transferProperties(list, this);\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        list._indices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          list._indices[i] = this._indices[i];\n        }\n      } else {\n        list._indices = new Ctor(this._indices);\n      }\n    } else {\n      list._indices = null;\n    }\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return list;\n  };\n  List.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n    if (typeof originalMethod !== 'function') {\n      return;\n    }\n    this.__wrappedMethods = this.__wrappedMethods || [];\n    this.__wrappedMethods.push(methodName);\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  };\n  List.internalField = function () {\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataValueHelper_1.parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, dimName, dataIndex, dimIndex) {\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        if (!this._rawData.pure && model_1.isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n        return dataValueHelper_1.parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);\n      },\n      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {\n      return dataValueHelper_1.parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);\n    }\n    prepareInvertedIndex = function (list) {\n      var invertedIndicesMap = list._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = list._dimensionInfos[dim];\n        var ordinalMeta = dimInfo.ordinalMeta;\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n          for (var i = 0; i < list._count; i++) {\n            invertedIndices[list.get(dim, i)] = i;\n          }\n        }\n      });\n    };\n    getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {\n      var val;\n      var chunk = list._storageArr[dimIdx];\n      if (chunk) {\n        val = chunk[rawIndex];\n        if (ordinalMeta && ordinalMeta.categories.length) {\n          val = ordinalMeta.categories[val];\n        }\n      }\n      return model_1.convertOptionIdName(val, null);\n    };\n    getIndicesCtor = function (list) {\n      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n    };\n    prepareStorage = function (storage, dimInfo, end, append) {\n      var DataCtor = dataCtors[dimInfo.type];\n      var dim = dimInfo.name;\n      if (append) {\n        var oldStore = storage[dim];\n        var oldLen = oldStore && oldStore.length;\n        if (!(oldLen === end)) {\n          var newStore = new DataCtor(end);\n          for (var j = 0; j < oldLen; j++) {\n            newStore[j] = oldStore[j];\n          }\n          storage[dim] = newStore;\n        }\n      } else {\n        storage[dim] = new DataCtor(end);\n      }\n    };\n    getRawIndexWithoutIndices = function (idx) {\n      return idx;\n    };\n    getRawIndexWithIndices = function (idx) {\n      if (idx < this._count && idx >= 0) {\n        return this._indices[idx];\n      }\n      return -1;\n    };\n    getId = function (list, rawIndex) {\n      var id = list._idList[rawIndex];\n      if (id == null && list._idDimIdx != null) {\n        id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);\n      }\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n      return id;\n    };\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n      return dimensions;\n    };\n    validateDimensions = function (list, dims) {\n      for (var i = 0; i < dims.length; i++) {\n        if (!list._dimensionInfos[dims[i]]) {\n          console.error('Unkown dimension ' + dims[i]);\n        }\n      }\n    };\n    cloneListForMapAndSample = function (original, excludeDimensions) {\n      var allDimensions = original.dimensions;\n      var list = new List(map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n      transferProperties(list, original);\n      var storage = list._storage = {};\n      var originalStorage = original._storage;\n      var storageArr = list._storageArr = [];\n      for (var i = 0; i < allDimensions.length; i++) {\n        var dim = allDimensions[i];\n        if (originalStorage[dim]) {\n          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n            storage[dim] = cloneChunk(originalStorage[dim]);\n            list._rawExtent[dim] = getInitialExtent();\n            list._extent[dim] = null;\n          } else {\n            storage[dim] = originalStorage[dim];\n          }\n          storageArr.push(storage[dim]);\n        }\n      }\n      return list;\n    };\n    function cloneChunk(originalChunk) {\n      var Ctor = originalChunk.constructor;\n      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n    }\n    getInitialExtent = function () {\n      return [Infinity, -Infinity];\n    };\n    setItemDataAndSeriesIndex = function (child) {\n      var childECData = innerStore_1.getECData(child);\n      var thisECData = innerStore_1.getECData(this);\n      childECData.seriesIndex = thisECData.seriesIndex;\n      childECData.dataIndex = thisECData.dataIndex;\n      childECData.dataType = thisECData.dataType;\n    };\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n    makeIdFromName = function (list, idx) {\n      var nameList = list._nameList;\n      var idList = list._idList;\n      var nameDimIdx = list._nameDimIdx;\n      var idDimIdx = list._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);\n      }\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);\n      }\n      if (id == null && name != null) {\n        var nameRepeatCount = list._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n        idList[idx] = id;\n      }\n    };\n  }();\n  return List;\n}();\nexports[\"default\"] = List;","map":{"version":3,"names":["exports","__esModule","zrUtil","require","Model_1","DataDiffer_1","dataProvider_1","dimensionHelper_1","DataDimensionInfo_1","types_1","model_1","innerStore_1","dataValueHelper_1","Source_1","mathFloor","Math","floor","isObject","map","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","defaultDimValueGetters","prepareInvertedIndex","getIndicesCtor","prepareStorage","getRawIndexWithoutIndices","getRawIndexWithIndices","getId","getIdNameFromStore","makeIdFromName","normalizeDimensions","validateDimensions","cloneListForMapAndSample","getInitialExtent","setItemDataAndSeriesIndex","transferProperties","List","dimensions","hostModel","type","_count","_rawCount","_storage","_storageArr","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawExtent","_extent","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","getRawIndex","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimInfoInput","dimensionInfo","isString","name","dimensionName","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","itemName","_nameDimIdx","_nameOrdinalMeta","ordinalMeta","itemId","_idDimIdx","_idOrdinalMeta","_dimensionInfos","_dimensionsSummary","summarizeDimensions","_invertedIndicesMap","userOutput","prototype","getDimension","dim","isNaN","hasOwnProperty","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","slice","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","mapDimensionsAll","initData","data","nameList","dimValueGetter","notProvider","isSourceInstance","isArrayLike","provider","DefaultDataProvider","process","env","NODE_ENV","assert","isFunction","getItem","count","_rawData","sourceFormat","getSource","_indices","_dontMakeIdFromName","SOURCE_FORMAT_TYPED_ARRAY","fillStorage","_nameRepeatCount","defaultDimValueGetter","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","storage","dimLen","rawExtent","max","rawExtentArr","storageArr","emptyDataItem","sourceIdx","dimIdx","val","dimRawExtent","append","dimensionInfoMap","idList","isFormatOriginal","SOURCE_FORMAT_ORIGINAL","dataItem","dimStorage","convertOptionIdName","id","clean","getIndices","newIndices","indices","Ctor","constructor","thisCount","buffer","getByDimIdx","NaN","dimStore","get","getByRawIndex","rawIdx","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","min","value","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","extend","getSum","sum","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","rawIndexOf","invertedIndices","Error","rawIndex","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getRawDataItem","cb","ctx","ctxCompat","_this","fCtx","dimNames","dimSize","dimIndices","dimName","call","k","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","dimStorage2","min2","max2","val2","dimk","mapArray","result","arguments","list","tmpRetValue","dataCount","dimIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","sampleFrameIdx","lttbDownSample","valueDimension","sampledIndex","currentRawIndex","maxArea","area","nextRawIndex","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","kvObj","getItemVisual","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","setItemVisual","clearAllVisual","setLayout","name_1","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","setItemGraphicEl","el","ecData","getECData","dataType","seriesIndex","traverse","getItemGraphicEl","eachItemGraphicEl","context","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","internalField","getDimValueSimply","objectRows","parseDataValue","keyedColumns","original","isDataItemOption","typedArray","dimInfo","categories","chunk","DataCtor","oldStore","oldLen","newStore","j","console","error","excludeDimensions","allDimensions","originalStorage","indexOf","cloneChunk","originalChunk","child","childECData","thisECData","target","source","propName","clone","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/echarts/lib/data/List.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model_1 = require(\"../model/Model\");\n\nvar DataDiffer_1 = require(\"./DataDiffer\");\n\nvar dataProvider_1 = require(\"./helper/dataProvider\");\n\nvar dimensionHelper_1 = require(\"./helper/dimensionHelper\");\n\nvar DataDimensionInfo_1 = require(\"./DataDimensionInfo\");\n\nvar types_1 = require(\"../util/types\");\n\nvar model_1 = require(\"../util/model\");\n\nvar innerStore_1 = require(\"../util/innerStore\");\n\nvar dataValueHelper_1 = require(\"./helper/dataValueHelper\");\n\nvar Source_1 = require(\"./Source\");\n\nvar mathFloor = Math.floor;\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1;\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\nvar defaultDimValueGetters;\nvar prepareInvertedIndex;\nvar getIndicesCtor;\nvar prepareStorage;\nvar getRawIndexWithoutIndices;\nvar getRawIndexWithIndices;\nvar getId;\nvar getIdNameFromStore;\nvar makeIdFromName;\nvar normalizeDimensions;\nvar validateDimensions;\nvar cloneListForMapAndSample;\nvar getInitialExtent;\nvar setItemDataAndSeriesIndex;\nvar transferProperties;\n\nvar List = function () {\n  function List(dimensions, hostModel) {\n    this.type = 'list';\n    this._count = 0;\n    this._rawCount = 0;\n    this._storage = {};\n    this._storageArr = [];\n    this._nameList = [];\n    this._idList = [];\n    this._visual = {};\n    this._layout = {};\n    this._itemVisuals = [];\n    this._itemLayouts = [];\n    this._graphicEls = [];\n    this._rawExtent = {};\n    this._extent = {};\n    this._approximateExtent = {};\n    this._calculationInfo = {};\n    this.hasItemOption = true;\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    this.getRawIndex = getRawIndexWithoutIndices;\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new DataDimensionInfo_1[\"default\"]({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof DataDimensionInfo_1[\"default\"]) ? new DataDimensionInfo_1[\"default\"](dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      dimensionInfo.index = i;\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n        this._nameOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n        this._idOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimensionInfos = dimensionInfos;\n    this.hostModel = hostModel;\n    this._dimensionsSummary = dimensionHelper_1.summarizeDimensions(this);\n    this._invertedIndicesMap = invertedIndicesMap;\n    this.userOutput = this._dimensionsSummary.userOutput;\n  }\n\n  List.prototype.getDimension = function (dim) {\n    if (typeof dim === 'number' || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n      dim = this.dimensions[dim];\n    }\n\n    return dim;\n  };\n\n  List.prototype.getDimensionInfo = function (dim) {\n    return this._dimensionInfos[this.getDimension(dim)];\n  };\n\n  List.prototype.getDimensionsOnCoord = function () {\n    return this._dimensionsSummary.dataDimsOnCoord.slice();\n  };\n\n  List.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimensionsSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  List.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimensionsSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  List.prototype.initData = function (data, nameList, dimValueGetter) {\n    var notProvider = Source_1.isSourceInstance(data) || zrUtil.isArrayLike(data);\n    var provider = notProvider ? new dataProvider_1.DefaultDataProvider(data, this.dimensions.length) : data;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(notProvider || zrUtil.isFunction(provider.getItem) && zrUtil.isFunction(provider.count), 'Inavlid data provider.');\n    }\n\n    this._rawData = provider;\n    var sourceFormat = provider.getSource().sourceFormat;\n    this._storage = {};\n    this._indices = null;\n    this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY || !!provider.fillStorage;\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    if (!dimValueGetter) {\n      this.hasItemOption = false;\n    }\n\n    this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat];\n    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n    this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;\n    this._rawExtent = {};\n\n    this._initDataFromProvider(0, provider.count());\n\n    if (provider.pure) {\n      this.hasItemOption = false;\n    }\n  };\n\n  List.prototype.getProvider = function () {\n    return this._rawData;\n  };\n\n  List.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var rawData = this._rawData;\n    var start = this.count();\n    rawData.appendData(data);\n    var end = rawData.count();\n\n    if (!rawData.persistent) {\n      end += start;\n    }\n\n    this._initDataFromProvider(start, end, true);\n  };\n\n  List.prototype.appendValues = function (values, names) {\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, names ? names.length : 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, this._dimensionInfos[dim], end, true);\n    }\n\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start;\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n\n        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);\n\n        storageArr[dimIdx][idx] = val;\n        var dimRawExtent = rawExtentArr[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n\n      if (names) {\n        this._nameList[idx] = names[sourceIdx];\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype._initDataFromProvider = function (start, end, append) {\n    if (start >= end) {\n      return;\n    }\n\n    var rawData = this._rawData;\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var dimensionInfoMap = this._dimensionInfos;\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var rawExtent = this._rawExtent;\n    var sourceFormat = rawData.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL;\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, dimensionInfoMap[dim], end, append);\n    }\n\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n\n    if (rawData.fillStorage) {\n      rawData.fillStorage(start, end, storageArr, rawExtentArr);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        dataItem = rawData.getItem(idx, dataItem);\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dim = dimensions[dimIdx];\n          var dimStorage = storageArr[dimIdx];\n\n          var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtentArr[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n\n        if (isFormatOriginal && !rawData.pure && dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = model_1.convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = model_1.convertOptionIdName(itemId, null);\n          }\n        }\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    if (!rawData.persistent && rawData.clean) {\n      rawData.clean();\n    }\n\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype.count = function () {\n    return this._count;\n  };\n\n  List.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count;\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n\n  List.prototype.getByDimIdx = function (dimIdx, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storageArr[dimIdx];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  List.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  List.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n\n  List.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n\n    if (!zrUtil.isArray(dimensions)) {\n      idx = dimensions;\n      dimensions = this.dimensions;\n    }\n\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n      values.push(this.get(dimensions[i], idx));\n    }\n\n    return values;\n  };\n\n  List.prototype.hasValue = function (idx) {\n    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  List.prototype.getDataExtent = function (dim) {\n    dim = this.getDimension(dim);\n    var dimData = this._storage[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    }\n\n    var currEnd = this.count();\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n\n  List.prototype.getApproximateExtent = function (dim) {\n    dim = this.getDimension(dim);\n    return this._approximateExtent[dim] || this.getDataExtent(dim);\n  };\n\n  List.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  List.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  List.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n\n  List.prototype.getSum = function (dim) {\n    var dimData = this._storage[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n\n  List.prototype.getMedian = function (dim) {\n    var dimDataArray = [];\n    this.each(dim, function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    });\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count();\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n\n  List.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n\n  List.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  List.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    }\n\n    var indices = this._indices;\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n\n  List.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  List.prototype.getRawDataItem = function (idx) {\n    if (!this._rawData.persistent) {\n      var val = [];\n\n      for (var i = 0; i < this.dimensions.length; i++) {\n        var dim = this.dimensions[i];\n        val.push(this.get(dim, idx));\n      }\n\n      return val;\n    } else {\n      return this._rawData.getItem(this.getRawIndex(idx));\n    }\n  };\n\n  List.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  List.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  List.prototype.each = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var dimSize = dimNames.length;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var storageArr = this._storageArr;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i);\n\n      switch (dimSize) {\n        case 0:\n          cb.call(fCtx, i);\n          break;\n\n        case 1:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = storageArr[dimIndices[k]][rawIdx];\n          }\n\n          value[k] = i;\n          cb.apply(fCtx, value);\n      }\n    }\n  };\n\n  List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var count = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dimNames.length;\n    var offset = 0;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var dim0 = dimIndices[0];\n    var storageArr = this._storageArr;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = this.getRawIndex(i);\n\n      if (dimSize === 0) {\n        keep = cb.call(fCtx, i);\n      } else if (dimSize === 1) {\n        var val = storageArr[dim0][rawIdx];\n        keep = cb.call(fCtx, val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = storageArr[dimIndices[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(fCtx, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    }\n\n    if (offset < count) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n\n  List.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var len = this._count;\n\n    if (!len) {\n      return;\n    }\n\n    var dimensions = [];\n\n    for (var dim in range) {\n      if (range.hasOwnProperty(dim)) {\n        dimensions.push(dim);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimensions);\n    }\n\n    var dimSize = dimensions.length;\n\n    if (!dimSize) {\n      return;\n    }\n\n    var originalCount = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dimensions[0];\n    var dimIndices = map(dimensions, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storageArr = this._storageArr;\n    var quickFinished = false;\n\n    if (!this._indices) {\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storageArr[dimIndices[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storageArr[dimIndices[0]];\n        var dimStorage2 = storageArr[dimIndices[1]];\n        var min2 = range[dimensions[1]][0];\n        var max2 = range[dimensions[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i];\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = this.getRawIndex(i);\n          var val = storageArr[dimIndices[0]][rawIndex];\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = this.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dimensions[k];\n            var val = storageArr[dimIndices[k]][rawIndex];\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = this.getRawIndex(i);\n          }\n        }\n      }\n    }\n\n    if (offset < originalCount) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n\n  List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    ctx = ctx || ctxCompat || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  List.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var list = cloneListForMapAndSample(this, dimNames);\n    var storage = list._storage;\n    list._indices = this._indices;\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    var tmpRetValue = [];\n    var dimSize = dimNames.length;\n    var dataCount = this.count();\n    var values = [];\n    var rawExtent = list._rawExtent;\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n        values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(fCtx, values);\n\n      if (retValue != null) {\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        var rawIndex = this.getRawIndex(dataIndex);\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dimNames[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = storage[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n\n    return list;\n  };\n\n  List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this, [dimension]);\n    var targetStorage = list._storage;\n    var frameValues = [];\n    var frameSize = mathFloor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = list._rawExtent[dimension];\n    var newIndices = new (getIndicesCtor(this))(len);\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    list._count = offset;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n\n  List.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this, []);\n    var targetStorage = list._storage;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var newIndices = new (getIndicesCtor(this))(len);\n    var sampledIndex = 0;\n    var frameSize = mathFloor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex;\n        }\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex;\n    }\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    list._count = sampledIndex;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n\n  List.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model_1[\"default\"](dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n\n  List.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer_1[\"default\"](otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n\n  List.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  List.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n\n  List.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n\n  List.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n\n  List.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key);\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  };\n\n  List.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n\n  List.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  List.prototype.setLayout = function (key, val) {\n    if (isObject(key)) {\n      for (var name_1 in key) {\n        if (key.hasOwnProperty(name_1)) {\n          this.setLayout(name_1, key[name_1]);\n        }\n      }\n\n      return;\n    }\n\n    this._layout[key] = val;\n  };\n\n  List.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n\n  List.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n\n  List.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n\n  List.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n\n  List.prototype.setItemGraphicEl = function (idx, el) {\n    var hostModel = this.hostModel;\n\n    if (el) {\n      var ecData = innerStore_1.getECData(el);\n      ecData.dataIndex = idx;\n      ecData.dataType = this.dataType;\n      ecData.seriesIndex = hostModel && hostModel.seriesIndex;\n\n      if (el.type === 'group') {\n        el.traverse(setItemDataAndSeriesIndex, el);\n      }\n    }\n\n    this._graphicEls[idx] = el;\n  };\n\n  List.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  List.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n\n  List.prototype.cloneShallow = function (list) {\n    if (!list) {\n      var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);\n      list = new List(dimensionInfoList, this.hostModel);\n    }\n\n    list._storage = this._storage;\n    list._storageArr = this._storageArr;\n    transferProperties(list, this);\n\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        list._indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          list._indices[i] = this._indices[i];\n        }\n      } else {\n        list._indices = new Ctor(this._indices);\n      }\n    } else {\n      list._indices = null;\n    }\n\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return list;\n  };\n\n  List.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (typeof originalMethod !== 'function') {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  };\n\n  List.internalField = function () {\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataValueHelper_1.parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, dimName, dataIndex, dimIndex) {\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\n        if (!this._rawData.pure && model_1.isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        return dataValueHelper_1.parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);\n      },\n      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n\n    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {\n      return dataValueHelper_1.parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);\n    }\n\n    prepareInvertedIndex = function (list) {\n      var invertedIndicesMap = list._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = list._dimensionInfos[dim];\n        var ordinalMeta = dimInfo.ordinalMeta;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < list._count; i++) {\n            invertedIndices[list.get(dim, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {\n      var val;\n      var chunk = list._storageArr[dimIdx];\n\n      if (chunk) {\n        val = chunk[rawIndex];\n\n        if (ordinalMeta && ordinalMeta.categories.length) {\n          val = ordinalMeta.categories[val];\n        }\n      }\n\n      return model_1.convertOptionIdName(val, null);\n    };\n\n    getIndicesCtor = function (list) {\n      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n    };\n\n    prepareStorage = function (storage, dimInfo, end, append) {\n      var DataCtor = dataCtors[dimInfo.type];\n      var dim = dimInfo.name;\n\n      if (append) {\n        var oldStore = storage[dim];\n        var oldLen = oldStore && oldStore.length;\n\n        if (!(oldLen === end)) {\n          var newStore = new DataCtor(end);\n\n          for (var j = 0; j < oldLen; j++) {\n            newStore[j] = oldStore[j];\n          }\n\n          storage[dim] = newStore;\n        }\n      } else {\n        storage[dim] = new DataCtor(end);\n      }\n    };\n\n    getRawIndexWithoutIndices = function (idx) {\n      return idx;\n    };\n\n    getRawIndexWithIndices = function (idx) {\n      if (idx < this._count && idx >= 0) {\n        return this._indices[idx];\n      }\n\n      return -1;\n    };\n\n    getId = function (list, rawIndex) {\n      var id = list._idList[rawIndex];\n\n      if (id == null && list._idDimIdx != null) {\n        id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n\n    validateDimensions = function (list, dims) {\n      for (var i = 0; i < dims.length; i++) {\n        if (!list._dimensionInfos[dims[i]]) {\n          console.error('Unkown dimension ' + dims[i]);\n        }\n      }\n    };\n\n    cloneListForMapAndSample = function (original, excludeDimensions) {\n      var allDimensions = original.dimensions;\n      var list = new List(map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n      transferProperties(list, original);\n      var storage = list._storage = {};\n      var originalStorage = original._storage;\n      var storageArr = list._storageArr = [];\n\n      for (var i = 0; i < allDimensions.length; i++) {\n        var dim = allDimensions[i];\n\n        if (originalStorage[dim]) {\n          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n            storage[dim] = cloneChunk(originalStorage[dim]);\n            list._rawExtent[dim] = getInitialExtent();\n            list._extent[dim] = null;\n          } else {\n            storage[dim] = originalStorage[dim];\n          }\n\n          storageArr.push(storage[dim]);\n        }\n      }\n\n      return list;\n    };\n\n    function cloneChunk(originalChunk) {\n      var Ctor = originalChunk.constructor;\n      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n    }\n\n    getInitialExtent = function () {\n      return [Infinity, -Infinity];\n    };\n\n    setItemDataAndSeriesIndex = function (child) {\n      var childECData = innerStore_1.getECData(child);\n      var thisECData = innerStore_1.getECData(this);\n      childECData.seriesIndex = thisECData.seriesIndex;\n      childECData.dataIndex = thisECData.dataIndex;\n      childECData.dataType = thisECData.dataType;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (list, idx) {\n      var nameList = list._nameList;\n      var idList = list._idList;\n      var nameDimIdx = list._nameDimIdx;\n      var idDimIdx = list._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = list._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return List;\n}();\n\nexports[\"default\"] = List;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}