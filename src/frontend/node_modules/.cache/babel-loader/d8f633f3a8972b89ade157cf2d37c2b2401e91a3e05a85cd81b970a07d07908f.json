{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { BBox } from './bbox';\n/**\n * As of Jan 8, 2019, Firefox still doesn't implement\n * `getTransform(): DOMMatrix;`\n * `setTransform(transform?: DOMMatrix2DInit)`\n * in the `CanvasRenderingContext2D`.\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\n * IE11 and Edge 44 also don't have the support.\n * Thus this class, to keep track of the current transform and\n * combine transformations.\n * Standards:\n * https://html.spec.whatwg.org/dev/canvas.html\n * https://www.w3.org/TR/geometry-1/\n */\nvar Matrix = /** @class */function () {\n  function Matrix(elements) {\n    if (elements === void 0) {\n      elements = [1, 0, 0, 1, 0, 0];\n    }\n    this.elements = elements;\n  }\n  Matrix.prototype.setElements = function (elements) {\n    var e = this.elements;\n    // `this.elements = elements.slice()` is 4-5 times slower\n    // (in Chrome 71 and FF 64) than manually copying elements,\n    // since slicing allocates new memory.\n    // The performance of passing parameters individually\n    // vs as an array is about the same in both browsers, so we\n    // go with a single (array of elements) parameter, because\n    // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\n    // calls give us roughly the same performance, versus\n    // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\n    // where the spread operator causes a 20-30x performance drop\n    // (30x when compiled to ES5's `.apply(this, elements)`\n    //  20x when used natively).\n    e[0] = elements[0];\n    e[1] = elements[1];\n    e[2] = elements[2];\n    e[3] = elements[3];\n    e[4] = elements[4];\n    e[5] = elements[5];\n    return this;\n  };\n  Matrix.prototype.setIdentityElements = function () {\n    var e = this.elements;\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 1;\n    e[4] = 0;\n    e[5] = 0;\n    return this;\n  };\n  Object.defineProperty(Matrix.prototype, \"identity\", {\n    get: function () {\n      var e = this.elements;\n      return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"a\", {\n    get: function () {\n      return this.elements[0];\n    },\n    set: function (value) {\n      this.elements[0] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"b\", {\n    get: function () {\n      return this.elements[1];\n    },\n    set: function (value) {\n      this.elements[1] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"c\", {\n    get: function () {\n      return this.elements[2];\n    },\n    set: function (value) {\n      this.elements[2] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"d\", {\n    get: function () {\n      return this.elements[3];\n    },\n    set: function (value) {\n      this.elements[3] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"e\", {\n    get: function () {\n      return this.elements[4];\n    },\n    set: function (value) {\n      this.elements[4] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Matrix.prototype, \"f\", {\n    get: function () {\n      return this.elements[5];\n    },\n    set: function (value) {\n      this.elements[5] = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  Matrix.prototype.AxB = function (A, B, C) {\n    var a = A[0] * B[0] + A[2] * B[1],\n      b = A[1] * B[0] + A[3] * B[1],\n      c = A[0] * B[2] + A[2] * B[3],\n      d = A[1] * B[2] + A[3] * B[3],\n      e = A[0] * B[4] + A[2] * B[5] + A[4],\n      f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C || A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  };\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  Matrix.prototype.multiplySelf = function (other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  };\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  Matrix.prototype.multiply = function (other) {\n    var elements = new Array(6);\n    this.AxB(this.elements, other.elements, elements);\n    return new Matrix(elements);\n  };\n  Matrix.prototype.preMultiplySelf = function (other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  };\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  Matrix.prototype.inverse = function () {\n    var _a = __read(this.elements, 6),\n      a = _a[0],\n      b = _a[1],\n      c = _a[2],\n      d = _a[3],\n      e = _a[4],\n      f = _a[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  };\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n  Matrix.prototype.inverseTo = function (other) {\n    var _a = __read(this.elements, 6),\n      a = _a[0],\n      b = _a[1],\n      c = _a[2],\n      d = _a[3],\n      e = _a[4],\n      f = _a[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  };\n  Matrix.prototype.invertSelf = function () {\n    var el = this.elements;\n    var a = el[0],\n      b = el[1],\n      c = el[2],\n      d = el[3],\n      e = el[4],\n      f = el[5];\n    var rD = 1 / (a * d - b * c); // reciprocal of determinant\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  };\n  Matrix.prototype.clone = function () {\n    return new Matrix(this.elements.slice());\n  };\n  Matrix.prototype.transformPoint = function (x, y) {\n    var e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  };\n  Matrix.prototype.transformBBox = function (bbox, radius, target) {\n    if (radius === void 0) {\n      radius = 0;\n    }\n    var elements = this.elements;\n    var xx = elements[0];\n    var xy = elements[1];\n    var yx = elements[2];\n    var yy = elements[3];\n    var h_w = bbox.width * 0.5;\n    var h_h = bbox.height * 0.5;\n    var cx = bbox.x + h_w;\n    var cy = bbox.y + h_h;\n    var w, h;\n    if (radius) {\n      h_w -= radius;\n      h_h -= radius;\n      var sx = Math.sqrt(xx * xx + yx * yx);\n      var sy = Math.sqrt(xy * xy + yy * yy);\n      w = Math.abs(h_w * xx) + Math.abs(h_h * yx) + Math.abs(sx * radius);\n      h = Math.abs(h_w * xy) + Math.abs(h_h * yy) + Math.abs(sy * radius);\n    } else {\n      w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n      h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    }\n    if (!target) {\n      target = new BBox(0, 0, 0, 0);\n    }\n    target.x = cx * xx + cy * yx + elements[4] - w;\n    target.y = cx * xy + cy * yy + elements[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  };\n  Matrix.prototype.toContext = function (ctx) {\n    // It's fair to say that matrix multiplications are not cheap.\n    // However, updating path definitions on every frame isn't either, so\n    // it may be cheaper to just translate paths. It's also fair to\n    // say, that most paths will have to be re-rendered anyway, say\n    // rectangle paths in a bar chart, where an animation would happen when\n    // the data set changes and existing bars are morphed into new ones.\n    // Or a pie chart, where old sectors are also morphed into new ones.\n    // Same for the line chart. The only plausible case where translating\n    // existing paths would be enough, is the scatter chart, where marker\n    // icons, typically circles, stay the same size. But if circle radii\n    // are bound to some data points, even circle paths would have to be\n    // updated. And thus it makes sense to optimize for fewer matrix\n    // transforms, where transform matrices of paths are mostly identity\n    // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\n    // are used to define a path at specific coordinates. And only groups\n    // are used to collectively apply a transform to a set of nodes.\n    // If the matrix is mostly identity (95% of the time),\n    // the `if (this.isIdentity)` check can make this call 3-4 times\n    // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\n    if (this.identity) {\n      return;\n    }\n    var e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  };\n  Matrix.flyweight = function (elements) {\n    if (elements) {\n      if (elements instanceof Matrix) {\n        Matrix.matrix.setElements(elements.elements);\n      } else {\n        Matrix.matrix.setElements(elements);\n      }\n    } else {\n      Matrix.matrix.setIdentityElements();\n    }\n    return Matrix.matrix;\n  };\n  Matrix.updateTransformMatrix = function (matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    // Assume that centers of scaling and rotation are at the origin.\n    var _j = __read([0, 0], 2),\n      bbcx = _j[0],\n      bbcy = _j[1];\n    var sx = scalingX;\n    var sy = scalingY;\n    var scx;\n    var scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = ((_a = opts) === null || _a === void 0 ? void 0 : _a.scalingCenterX) == null ? bbcx : (_b = opts) === null || _b === void 0 ? void 0 : _b.scalingCenterX;\n      scy = ((_c = opts) === null || _c === void 0 ? void 0 : _c.scalingCenterY) == null ? bbcy : (_d = opts) === null || _d === void 0 ? void 0 : _d.scalingCenterY;\n    }\n    var r = rotation;\n    var cos = Math.cos(r);\n    var sin = Math.sin(r);\n    var rcx;\n    var rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = ((_e = opts) === null || _e === void 0 ? void 0 : _e.rotationCenterX) == null ? bbcx : (_f = opts) === null || _f === void 0 ? void 0 : _f.rotationCenterX;\n      rcy = ((_g = opts) === null || _g === void 0 ? void 0 : _g.rotationCenterY) == null ? bbcy : (_h = opts) === null || _h === void 0 ? void 0 : _h.rotationCenterY;\n    }\n    var tx = translationX;\n    var ty = translationY;\n    // The transform matrix `M` is a result of the following transformations:\n    // 1) translate the center of scaling to the origin\n    // 2) scale\n    // 3) translate back\n    // 4) translate the center of rotation to the origin\n    // 5) rotate\n    // 6) translate back\n    // 7) translate\n    //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n    //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n    // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n    //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n    // Translation after steps 1-4 above:\n    var tx4 = scx * (1 - sx) - rcx;\n    var ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx4 - sin * ty4 + rcx + tx, sin * tx4 + cos * ty4 + rcy + ty]);\n    return matrix;\n  };\n  Matrix.matrix = new Matrix();\n  return Matrix;\n}();\nexport { Matrix };","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","BBox","Matrix","elements","prototype","setElements","setIdentityElements","Object","defineProperty","get","enumerable","configurable","set","AxB","A","B","C","a","b","c","d","f","multiplySelf","other","multiply","Array","preMultiplySelf","inverse","_a","rD","inverseTo","invertSelf","el","clone","slice","transformPoint","x","y","transformBBox","bbox","radius","target","xx","xy","yx","yy","h_w","width","h_h","height","cx","cy","w","h","sx","Math","sqrt","sy","abs","toContext","ctx","identity","transform","flyweight","matrix","updateTransformMatrix","scalingX","scalingY","rotation","translationX","translationY","opts","_b","_c","_d","_e","_f","_g","_h","_j","bbcx","bbcy","scx","scy","scalingCenterX","scalingCenterY","cos","sin","rcx","rcy","rotationCenterX","rotationCenterY","tx","ty","tx4","ty4"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/scene/matrix.js"],"sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { BBox } from './bbox';\n/**\n * As of Jan 8, 2019, Firefox still doesn't implement\n * `getTransform(): DOMMatrix;`\n * `setTransform(transform?: DOMMatrix2DInit)`\n * in the `CanvasRenderingContext2D`.\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\n * IE11 and Edge 44 also don't have the support.\n * Thus this class, to keep track of the current transform and\n * combine transformations.\n * Standards:\n * https://html.spec.whatwg.org/dev/canvas.html\n * https://www.w3.org/TR/geometry-1/\n */\nvar Matrix = /** @class */ (function () {\n    function Matrix(elements) {\n        if (elements === void 0) { elements = [1, 0, 0, 1, 0, 0]; }\n        this.elements = elements;\n    }\n    Matrix.prototype.setElements = function (elements) {\n        var e = this.elements;\n        // `this.elements = elements.slice()` is 4-5 times slower\n        // (in Chrome 71 and FF 64) than manually copying elements,\n        // since slicing allocates new memory.\n        // The performance of passing parameters individually\n        // vs as an array is about the same in both browsers, so we\n        // go with a single (array of elements) parameter, because\n        // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\n        // calls give us roughly the same performance, versus\n        // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\n        // where the spread operator causes a 20-30x performance drop\n        // (30x when compiled to ES5's `.apply(this, elements)`\n        //  20x when used natively).\n        e[0] = elements[0];\n        e[1] = elements[1];\n        e[2] = elements[2];\n        e[3] = elements[3];\n        e[4] = elements[4];\n        e[5] = elements[5];\n        return this;\n    };\n    Matrix.prototype.setIdentityElements = function () {\n        var e = this.elements;\n        e[0] = 1;\n        e[1] = 0;\n        e[2] = 0;\n        e[3] = 1;\n        e[4] = 0;\n        e[5] = 0;\n        return this;\n    };\n    Object.defineProperty(Matrix.prototype, \"identity\", {\n        get: function () {\n            var e = this.elements;\n            return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"a\", {\n        get: function () {\n            return this.elements[0];\n        },\n        set: function (value) {\n            this.elements[0] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"b\", {\n        get: function () {\n            return this.elements[1];\n        },\n        set: function (value) {\n            this.elements[1] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"c\", {\n        get: function () {\n            return this.elements[2];\n        },\n        set: function (value) {\n            this.elements[2] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"d\", {\n        get: function () {\n            return this.elements[3];\n        },\n        set: function (value) {\n            this.elements[3] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"e\", {\n        get: function () {\n            return this.elements[4];\n        },\n        set: function (value) {\n            this.elements[4] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Matrix.prototype, \"f\", {\n        get: function () {\n            return this.elements[5];\n        },\n        set: function (value) {\n            this.elements[5] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Performs the AxB matrix multiplication and saves the result\n     * to `C`, if given, or to `A` otherwise.\n     */\n    Matrix.prototype.AxB = function (A, B, C) {\n        var a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n        C = C || A;\n        C[0] = a;\n        C[1] = b;\n        C[2] = c;\n        C[3] = d;\n        C[4] = e;\n        C[5] = f;\n    };\n    /**\n     * The `other` matrix gets post-multiplied to the current matrix.\n     * Returns the current matrix.\n     * @param other\n     */\n    Matrix.prototype.multiplySelf = function (other) {\n        this.AxB(this.elements, other.elements);\n        return this;\n    };\n    /**\n     * The `other` matrix gets post-multiplied to the current matrix.\n     * Returns a new matrix.\n     * @param other\n     */\n    Matrix.prototype.multiply = function (other) {\n        var elements = new Array(6);\n        this.AxB(this.elements, other.elements, elements);\n        return new Matrix(elements);\n    };\n    Matrix.prototype.preMultiplySelf = function (other) {\n        this.AxB(other.elements, this.elements, this.elements);\n        return this;\n    };\n    /**\n     * Returns the inverse of this matrix as a new matrix.\n     */\n    Matrix.prototype.inverse = function () {\n        var _a = __read(this.elements, 6), a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4], f = _a[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    };\n    /**\n     * Save the inverse of this matrix to the given matrix.\n     */\n    Matrix.prototype.inverseTo = function (other) {\n        var _a = __read(this.elements, 6), a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4], f = _a[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n        return this;\n    };\n    Matrix.prototype.invertSelf = function () {\n        var el = this.elements;\n        var a = el[0], b = el[1], c = el[2], d = el[3], e = el[4], f = el[5];\n        var rD = 1 / (a * d - b * c); // reciprocal of determinant\n        a *= rD;\n        b *= rD;\n        c *= rD;\n        d *= rD;\n        el[0] = d;\n        el[1] = -b;\n        el[2] = -c;\n        el[3] = a;\n        el[4] = c * f - d * e;\n        el[5] = b * e - a * f;\n        return this;\n    };\n    Matrix.prototype.clone = function () {\n        return new Matrix(this.elements.slice());\n    };\n    Matrix.prototype.transformPoint = function (x, y) {\n        var e = this.elements;\n        return {\n            x: x * e[0] + y * e[2] + e[4],\n            y: x * e[1] + y * e[3] + e[5],\n        };\n    };\n    Matrix.prototype.transformBBox = function (bbox, radius, target) {\n        if (radius === void 0) { radius = 0; }\n        var elements = this.elements;\n        var xx = elements[0];\n        var xy = elements[1];\n        var yx = elements[2];\n        var yy = elements[3];\n        var h_w = bbox.width * 0.5;\n        var h_h = bbox.height * 0.5;\n        var cx = bbox.x + h_w;\n        var cy = bbox.y + h_h;\n        var w, h;\n        if (radius) {\n            h_w -= radius;\n            h_h -= radius;\n            var sx = Math.sqrt(xx * xx + yx * yx);\n            var sy = Math.sqrt(xy * xy + yy * yy);\n            w = Math.abs(h_w * xx) + Math.abs(h_h * yx) + Math.abs(sx * radius);\n            h = Math.abs(h_w * xy) + Math.abs(h_h * yy) + Math.abs(sy * radius);\n        }\n        else {\n            w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n            h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n        }\n        if (!target) {\n            target = new BBox(0, 0, 0, 0);\n        }\n        target.x = cx * xx + cy * yx + elements[4] - w;\n        target.y = cx * xy + cy * yy + elements[5] - h;\n        target.width = w + w;\n        target.height = h + h;\n        return target;\n    };\n    Matrix.prototype.toContext = function (ctx) {\n        // It's fair to say that matrix multiplications are not cheap.\n        // However, updating path definitions on every frame isn't either, so\n        // it may be cheaper to just translate paths. It's also fair to\n        // say, that most paths will have to be re-rendered anyway, say\n        // rectangle paths in a bar chart, where an animation would happen when\n        // the data set changes and existing bars are morphed into new ones.\n        // Or a pie chart, where old sectors are also morphed into new ones.\n        // Same for the line chart. The only plausible case where translating\n        // existing paths would be enough, is the scatter chart, where marker\n        // icons, typically circles, stay the same size. But if circle radii\n        // are bound to some data points, even circle paths would have to be\n        // updated. And thus it makes sense to optimize for fewer matrix\n        // transforms, where transform matrices of paths are mostly identity\n        // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\n        // are used to define a path at specific coordinates. And only groups\n        // are used to collectively apply a transform to a set of nodes.\n        // If the matrix is mostly identity (95% of the time),\n        // the `if (this.isIdentity)` check can make this call 3-4 times\n        // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\n        if (this.identity) {\n            return;\n        }\n        var e = this.elements;\n        ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n    };\n    Matrix.flyweight = function (elements) {\n        if (elements) {\n            if (elements instanceof Matrix) {\n                Matrix.matrix.setElements(elements.elements);\n            }\n            else {\n                Matrix.matrix.setElements(elements);\n            }\n        }\n        else {\n            Matrix.matrix.setIdentityElements();\n        }\n        return Matrix.matrix;\n    };\n    Matrix.updateTransformMatrix = function (matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        // Assume that centers of scaling and rotation are at the origin.\n        var _j = __read([0, 0], 2), bbcx = _j[0], bbcy = _j[1];\n        var sx = scalingX;\n        var sy = scalingY;\n        var scx;\n        var scy;\n        if (sx === 1 && sy === 1) {\n            scx = 0;\n            scy = 0;\n        }\n        else {\n            scx = ((_a = opts) === null || _a === void 0 ? void 0 : _a.scalingCenterX) == null ? bbcx : (_b = opts) === null || _b === void 0 ? void 0 : _b.scalingCenterX;\n            scy = ((_c = opts) === null || _c === void 0 ? void 0 : _c.scalingCenterY) == null ? bbcy : (_d = opts) === null || _d === void 0 ? void 0 : _d.scalingCenterY;\n        }\n        var r = rotation;\n        var cos = Math.cos(r);\n        var sin = Math.sin(r);\n        var rcx;\n        var rcy;\n        if (r === 0) {\n            rcx = 0;\n            rcy = 0;\n        }\n        else {\n            rcx = ((_e = opts) === null || _e === void 0 ? void 0 : _e.rotationCenterX) == null ? bbcx : (_f = opts) === null || _f === void 0 ? void 0 : _f.rotationCenterX;\n            rcy = ((_g = opts) === null || _g === void 0 ? void 0 : _g.rotationCenterY) == null ? bbcy : (_h = opts) === null || _h === void 0 ? void 0 : _h.rotationCenterY;\n        }\n        var tx = translationX;\n        var ty = translationY;\n        // The transform matrix `M` is a result of the following transformations:\n        // 1) translate the center of scaling to the origin\n        // 2) scale\n        // 3) translate back\n        // 4) translate the center of rotation to the origin\n        // 5) rotate\n        // 6) translate back\n        // 7) translate\n        //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n        //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n        // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n        //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n        // Translation after steps 1-4 above:\n        var tx4 = scx * (1 - sx) - rcx;\n        var ty4 = scy * (1 - sy) - rcy;\n        matrix.setElements([\n            cos * sx,\n            sin * sx,\n            -sin * sy,\n            cos * sy,\n            cos * tx4 - sin * ty4 + rcx + tx,\n            sin * tx4 + cos * ty4 + rcy + ty,\n        ]);\n        return matrix;\n    };\n    Matrix.matrix = new Matrix();\n    return Matrix;\n}());\nexport { Matrix };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}