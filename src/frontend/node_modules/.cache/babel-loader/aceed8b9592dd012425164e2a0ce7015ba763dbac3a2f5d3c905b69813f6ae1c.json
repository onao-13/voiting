{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nexports.__esModule = true;\nvar Group_1 = require(\"../graphic/Group\");\nvar Image_1 = require(\"../graphic/Image\");\nvar Circle_1 = require(\"../graphic/shape/Circle\");\nvar Rect_1 = require(\"../graphic/shape/Rect\");\nvar Ellipse_1 = require(\"../graphic/shape/Ellipse\");\nvar Line_1 = require(\"../graphic/shape/Line\");\nvar Path_1 = require(\"../graphic/Path\");\nvar Polygon_1 = require(\"../graphic/shape/Polygon\");\nvar Polyline_1 = require(\"../graphic/shape/Polyline\");\nvar matrix = require(\"../core/matrix\");\nvar path_1 = require(\"./path\");\nvar util_1 = require(\"../core/util\");\nvar LinearGradient_1 = require(\"../graphic/LinearGradient\");\nvar TSpan_1 = require(\"../graphic/TSpan\");\nvar DILIMITER_REG = /[\\s,]+/;\nfunction parseXML(svg) {\n  if (util_1.isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  }\n  var svgNode = svg;\n  if (svgNode.nodeType === 9) {\n    svgNode = svgNode.firstChild;\n  }\n  while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n    svgNode = svgNode.nextSibling;\n  }\n  return svgNode;\n}\nexports.parseXML = parseXML;\nvar nodeParsers;\nvar SVGParser = function () {\n  function SVGParser() {\n    this._defs = {};\n    this._root = null;\n    this._isDefine = false;\n    this._isText = false;\n  }\n  SVGParser.prototype.parse = function (xml, opt) {\n    opt = opt || {};\n    var svg = parseXML(xml);\n    if (!svg) {\n      throw new Error('Illegal svg');\n    }\n    var root = new Group_1[\"default\"]();\n    this._root = root;\n    var viewBox = svg.getAttribute('viewBox') || '';\n    var width = parseFloat(svg.getAttribute('width') || opt.width);\n    var height = parseFloat(svg.getAttribute('height') || opt.height);\n    isNaN(width) && (width = null);\n    isNaN(height) && (height = null);\n    parseAttributes(svg, root, null, true);\n    var child = svg.firstChild;\n    while (child) {\n      this._parseNode(child, root);\n      child = child.nextSibling;\n    }\n    var viewBoxRect;\n    var viewBoxTransform;\n    if (viewBox) {\n      var viewBoxArr = util_1.trim(viewBox).split(DILIMITER_REG);\n      if (viewBoxArr.length >= 4) {\n        viewBoxRect = {\n          x: parseFloat(viewBoxArr[0] || 0),\n          y: parseFloat(viewBoxArr[1] || 0),\n          width: parseFloat(viewBoxArr[2]),\n          height: parseFloat(viewBoxArr[3])\n        };\n      }\n    }\n    if (viewBoxRect && width != null && height != null) {\n      viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n      if (!opt.ignoreViewBox) {\n        var elRoot = root;\n        root = new Group_1[\"default\"]();\n        root.add(elRoot);\n        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n        elRoot.x = viewBoxTransform.x;\n        elRoot.y = viewBoxTransform.y;\n      }\n    }\n    if (!opt.ignoreRootClip && width != null && height != null) {\n      root.setClipPath(new Rect_1[\"default\"]({\n        shape: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      }));\n    }\n    return {\n      root: root,\n      width: width,\n      height: height,\n      viewBoxRect: viewBoxRect,\n      viewBoxTransform: viewBoxTransform\n    };\n  };\n  SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n    var nodeName = xmlNode.nodeName.toLowerCase();\n    if (nodeName === 'defs') {\n      this._isDefine = true;\n    } else if (nodeName === 'text') {\n      this._isText = true;\n    }\n    var el;\n    if (this._isDefine) {\n      var parser = defineParsers[nodeName];\n      if (parser) {\n        var def = parser.call(this, xmlNode);\n        var id = xmlNode.getAttribute('id');\n        if (id) {\n          this._defs[id] = def;\n        }\n      }\n    } else {\n      var parser = nodeParsers[nodeName];\n      if (parser) {\n        el = parser.call(this, xmlNode, parentGroup);\n        parentGroup.add(el);\n      }\n    }\n    if (el) {\n      var child = xmlNode.firstChild;\n      while (child) {\n        if (child.nodeType === 1) {\n          this._parseNode(child, el);\n        }\n        if (child.nodeType === 3 && this._isText) {\n          this._parseText(child, el);\n        }\n        child = child.nextSibling;\n      }\n    }\n    if (nodeName === 'defs') {\n      this._isDefine = false;\n    } else if (nodeName === 'text') {\n      this._isText = false;\n    }\n  };\n  SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n    if (xmlNode.nodeType === 1) {\n      var dx = xmlNode.getAttribute('dx') || 0;\n      var dy = xmlNode.getAttribute('dy') || 0;\n      this._textX += parseFloat(dx);\n      this._textY += parseFloat(dy);\n    }\n    var text = new TSpan_1[\"default\"]({\n      style: {\n        text: xmlNode.textContent\n      },\n      x: this._textX || 0,\n      y: this._textY || 0\n    });\n    inheritStyle(parentGroup, text);\n    parseAttributes(xmlNode, text, this._defs);\n    var textStyle = text.style;\n    var fontSize = textStyle.fontSize;\n    if (fontSize && fontSize < 9) {\n      textStyle.fontSize = 9;\n      text.scaleX *= fontSize / 9;\n      text.scaleY *= fontSize / 9;\n    }\n    var font = (textStyle.fontSize || textStyle.fontFamily) && [textStyle.fontStyle, textStyle.fontWeight, (textStyle.fontSize || 12) + 'px', textStyle.fontFamily || 'sans-serif'].join(' ');\n    textStyle.font = font;\n    var rect = text.getBoundingRect();\n    this._textX += rect.width;\n    parentGroup.add(text);\n    return text;\n  };\n  SVGParser.internalField = function () {\n    nodeParsers = {\n      'g': function (xmlNode, parentGroup) {\n        var g = new Group_1[\"default\"]();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'rect': function (xmlNode, parentGroup) {\n        var rect = new Rect_1[\"default\"]();\n        inheritStyle(parentGroup, rect);\n        parseAttributes(xmlNode, rect, this._defs);\n        rect.setShape({\n          x: parseFloat(xmlNode.getAttribute('x') || '0'),\n          y: parseFloat(xmlNode.getAttribute('y') || '0'),\n          width: parseFloat(xmlNode.getAttribute('width') || '0'),\n          height: parseFloat(xmlNode.getAttribute('height') || '0')\n        });\n        return rect;\n      },\n      'circle': function (xmlNode, parentGroup) {\n        var circle = new Circle_1[\"default\"]();\n        inheritStyle(parentGroup, circle);\n        parseAttributes(xmlNode, circle, this._defs);\n        circle.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          r: parseFloat(xmlNode.getAttribute('r') || '0')\n        });\n        return circle;\n      },\n      'line': function (xmlNode, parentGroup) {\n        var line = new Line_1[\"default\"]();\n        inheritStyle(parentGroup, line);\n        parseAttributes(xmlNode, line, this._defs);\n        line.setShape({\n          x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n          y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n          x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n          y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n        });\n        return line;\n      },\n      'ellipse': function (xmlNode, parentGroup) {\n        var ellipse = new Ellipse_1[\"default\"]();\n        inheritStyle(parentGroup, ellipse);\n        parseAttributes(xmlNode, ellipse, this._defs);\n        ellipse.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n          ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n        });\n        return ellipse;\n      },\n      'polygon': function (xmlNode, parentGroup) {\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n        var polygon = new Polygon_1[\"default\"]({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        inheritStyle(parentGroup, polygon);\n        parseAttributes(xmlNode, polygon, this._defs);\n        return polygon;\n      },\n      'polyline': function (xmlNode, parentGroup) {\n        var path = new Path_1[\"default\"]();\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n        var polyline = new Polyline_1[\"default\"]({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        return polyline;\n      },\n      'image': function (xmlNode, parentGroup) {\n        var img = new Image_1[\"default\"]();\n        inheritStyle(parentGroup, img);\n        parseAttributes(xmlNode, img, this._defs);\n        img.setStyle({\n          image: xmlNode.getAttribute('xlink:href'),\n          x: +xmlNode.getAttribute('x'),\n          y: +xmlNode.getAttribute('y'),\n          width: +xmlNode.getAttribute('width'),\n          height: +xmlNode.getAttribute('height')\n        });\n        return img;\n      },\n      'text': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x') || '0';\n        var y = xmlNode.getAttribute('y') || '0';\n        var dx = xmlNode.getAttribute('dx') || '0';\n        var dy = xmlNode.getAttribute('dy') || '0';\n        this._textX = parseFloat(x) + parseFloat(dx);\n        this._textY = parseFloat(y) + parseFloat(dy);\n        var g = new Group_1[\"default\"]();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'tspan': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x');\n        var y = xmlNode.getAttribute('y');\n        if (x != null) {\n          this._textX = parseFloat(x);\n        }\n        if (y != null) {\n          this._textY = parseFloat(y);\n        }\n        var dx = xmlNode.getAttribute('dx') || 0;\n        var dy = xmlNode.getAttribute('dy') || 0;\n        var g = new Group_1[\"default\"]();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        this._textX += dx;\n        this._textY += dy;\n        return g;\n      },\n      'path': function (xmlNode, parentGroup) {\n        var d = xmlNode.getAttribute('d') || '';\n        var path = path_1.createFromString(d);\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        return path;\n      }\n    };\n  }();\n  return SVGParser;\n}();\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n    var gradient = new LinearGradient_1[\"default\"](x1, y1, x2, y2);\n    _parseGradientColorStops(xmlNode, gradient);\n    return gradient;\n  }\n};\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offsetStr = stop.getAttribute('offset');\n      var offset = void 0;\n      if (offsetStr.indexOf('%') > 0) {\n        offset = parseInt(offsetStr, 10) / 100;\n      } else if (offsetStr) {\n        offset = parseFloat(offsetStr);\n      } else {\n        offset = 0;\n      }\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.colorStops.push({\n        offset: offset,\n        color: stopColor\n      });\n    }\n    stop = stop.nextSibling;\n  }\n}\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n    util_1.defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\nfunction parsePoints(pointsString) {\n  var list = util_1.trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n  return points;\n}\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var disp = el;\n  var zrStyle = disp.__inheritedStyle || {};\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    util_1.extend(zrStyle, parseStyleAttribute(xmlNode));\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n  disp.style = disp.style || {};\n  zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n  util_1.each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n  });\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n  util_1.each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n  });\n  if (zrStyle.lineDash) {\n    disp.style.lineDash = util_1.map(util_1.trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n      return parseFloat(str);\n    });\n  }\n  disp.__inheritedStyle = zrStyle;\n}\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\nfunction getPaint(str, defs) {\n  var urlMatch = defs && str && str.match(urlRegex);\n  if (urlMatch) {\n    var url = util_1.trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n  return str;\n}\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var transformOps_1 = [];\n    var m = null;\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps_1.push(type, value);\n      return '';\n    });\n    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n      var value = transformOps_1[i];\n      var type = transformOps_1[i - 1];\n      var valueArr = void 0;\n      m = m || matrix.create();\n      switch (type) {\n        case 'translate':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n          break;\n        case 'scale':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n          break;\n        case 'rotate':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(valueArr[0]));\n          break;\n        case 'skew':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n        case 'matrix':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(valueArr[0]);\n          m[1] = parseFloat(valueArr[1]);\n          m[2] = parseFloat(valueArr[2]);\n          m[3] = parseFloat(valueArr[3]);\n          m[4] = parseFloat(valueArr[4]);\n          m[5] = parseFloat(valueArr[5]);\n          break;\n      }\n    }\n    node.setLocalTransform(m);\n  }\n}\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n  if (!style) {\n    return result;\n  }\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n  return result;\n}\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY);\n  return {\n    scale: scale,\n    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n  };\n}\nexports.makeViewBoxTransform = makeViewBoxTransform;\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\nexports.parseSVG = parseSVG;","map":{"version":3,"names":["exports","__esModule","Group_1","require","Image_1","Circle_1","Rect_1","Ellipse_1","Line_1","Path_1","Polygon_1","Polyline_1","matrix","path_1","util_1","LinearGradient_1","TSpan_1","DILIMITER_REG","parseXML","svg","isString","parser","DOMParser","parseFromString","svgNode","nodeType","firstChild","nodeName","toLowerCase","nextSibling","nodeParsers","SVGParser","_defs","_root","_isDefine","_isText","prototype","parse","xml","opt","Error","root","viewBox","getAttribute","width","parseFloat","height","isNaN","parseAttributes","child","_parseNode","viewBoxRect","viewBoxTransform","viewBoxArr","trim","split","length","x","y","makeViewBoxTransform","ignoreViewBox","elRoot","add","scaleX","scaleY","scale","ignoreRootClip","setClipPath","shape","xmlNode","parentGroup","el","defineParsers","def","call","id","_parseText","dx","dy","_textX","_textY","text","style","textContent","inheritStyle","textStyle","fontSize","font","fontFamily","fontStyle","fontWeight","join","rect","getBoundingRect","internalField","g","setShape","circle","cx","cy","r","line","x1","y1","x2","y2","ellipse","rx","ry","pointsStr","pointsArr","parsePoints","polygon","points","path","polyline","img","setStyle","image","d","createFromString","parseInt","gradient","_parseGradientColorStops","stop","offsetStr","offset","indexOf","stopColor","colorStops","push","color","parent","__inheritedStyle","defaults","pointsString","list","i","attributesMap","defs","onlyInlineStyle","disp","zrStyle","parseTransformAttribute","extend","parseStyleAttribute","svgAttrName","hasOwnProperty","attrValue","fill","getPaint","stroke","each","propName","textBaseline","textAlign","lineDash","map","str","urlRegex","urlMatch","match","url","transformRegex","node","transform","replace","transformOps_1","m","type","value","valueArr","create","translate","rotate","console","warn","setLocalTransform","styleRegex","result","styleList","lastIndex","styleRegResult","exec","Math","min","parseSVG"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/zrender/lib/tool/parseSVG.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar Group_1 = require(\"../graphic/Group\");\nvar Image_1 = require(\"../graphic/Image\");\nvar Circle_1 = require(\"../graphic/shape/Circle\");\nvar Rect_1 = require(\"../graphic/shape/Rect\");\nvar Ellipse_1 = require(\"../graphic/shape/Ellipse\");\nvar Line_1 = require(\"../graphic/shape/Line\");\nvar Path_1 = require(\"../graphic/Path\");\nvar Polygon_1 = require(\"../graphic/shape/Polygon\");\nvar Polyline_1 = require(\"../graphic/shape/Polyline\");\nvar matrix = require(\"../core/matrix\");\nvar path_1 = require(\"./path\");\nvar util_1 = require(\"../core/util\");\nvar LinearGradient_1 = require(\"../graphic/LinearGradient\");\nvar TSpan_1 = require(\"../graphic/TSpan\");\nvar DILIMITER_REG = /[\\s,]+/;\nfunction parseXML(svg) {\n    if (util_1.isString(svg)) {\n        var parser = new DOMParser();\n        svg = parser.parseFromString(svg, 'text/xml');\n    }\n    var svgNode = svg;\n    if (svgNode.nodeType === 9) {\n        svgNode = svgNode.firstChild;\n    }\n    while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n        svgNode = svgNode.nextSibling;\n    }\n    return svgNode;\n}\nexports.parseXML = parseXML;\nvar nodeParsers;\nvar SVGParser = (function () {\n    function SVGParser() {\n        this._defs = {};\n        this._root = null;\n        this._isDefine = false;\n        this._isText = false;\n    }\n    SVGParser.prototype.parse = function (xml, opt) {\n        opt = opt || {};\n        var svg = parseXML(xml);\n        if (!svg) {\n            throw new Error('Illegal svg');\n        }\n        var root = new Group_1[\"default\"]();\n        this._root = root;\n        var viewBox = svg.getAttribute('viewBox') || '';\n        var width = parseFloat((svg.getAttribute('width') || opt.width));\n        var height = parseFloat((svg.getAttribute('height') || opt.height));\n        isNaN(width) && (width = null);\n        isNaN(height) && (height = null);\n        parseAttributes(svg, root, null, true);\n        var child = svg.firstChild;\n        while (child) {\n            this._parseNode(child, root);\n            child = child.nextSibling;\n        }\n        var viewBoxRect;\n        var viewBoxTransform;\n        if (viewBox) {\n            var viewBoxArr = util_1.trim(viewBox).split(DILIMITER_REG);\n            if (viewBoxArr.length >= 4) {\n                viewBoxRect = {\n                    x: parseFloat((viewBoxArr[0] || 0)),\n                    y: parseFloat((viewBoxArr[1] || 0)),\n                    width: parseFloat(viewBoxArr[2]),\n                    height: parseFloat(viewBoxArr[3])\n                };\n            }\n        }\n        if (viewBoxRect && width != null && height != null) {\n            viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n            if (!opt.ignoreViewBox) {\n                var elRoot = root;\n                root = new Group_1[\"default\"]();\n                root.add(elRoot);\n                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n                elRoot.x = viewBoxTransform.x;\n                elRoot.y = viewBoxTransform.y;\n            }\n        }\n        if (!opt.ignoreRootClip && width != null && height != null) {\n            root.setClipPath(new Rect_1[\"default\"]({\n                shape: { x: 0, y: 0, width: width, height: height }\n            }));\n        }\n        return {\n            root: root,\n            width: width,\n            height: height,\n            viewBoxRect: viewBoxRect,\n            viewBoxTransform: viewBoxTransform\n        };\n    };\n    SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n        var nodeName = xmlNode.nodeName.toLowerCase();\n        if (nodeName === 'defs') {\n            this._isDefine = true;\n        }\n        else if (nodeName === 'text') {\n            this._isText = true;\n        }\n        var el;\n        if (this._isDefine) {\n            var parser = defineParsers[nodeName];\n            if (parser) {\n                var def = parser.call(this, xmlNode);\n                var id = xmlNode.getAttribute('id');\n                if (id) {\n                    this._defs[id] = def;\n                }\n            }\n        }\n        else {\n            var parser = nodeParsers[nodeName];\n            if (parser) {\n                el = parser.call(this, xmlNode, parentGroup);\n                parentGroup.add(el);\n            }\n        }\n        if (el) {\n            var child = xmlNode.firstChild;\n            while (child) {\n                if (child.nodeType === 1) {\n                    this._parseNode(child, el);\n                }\n                if (child.nodeType === 3 && this._isText) {\n                    this._parseText(child, el);\n                }\n                child = child.nextSibling;\n            }\n        }\n        if (nodeName === 'defs') {\n            this._isDefine = false;\n        }\n        else if (nodeName === 'text') {\n            this._isText = false;\n        }\n    };\n    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n        if (xmlNode.nodeType === 1) {\n            var dx = xmlNode.getAttribute('dx') || 0;\n            var dy = xmlNode.getAttribute('dy') || 0;\n            this._textX += parseFloat(dx);\n            this._textY += parseFloat(dy);\n        }\n        var text = new TSpan_1[\"default\"]({\n            style: {\n                text: xmlNode.textContent\n            },\n            x: this._textX || 0,\n            y: this._textY || 0\n        });\n        inheritStyle(parentGroup, text);\n        parseAttributes(xmlNode, text, this._defs);\n        var textStyle = text.style;\n        var fontSize = textStyle.fontSize;\n        if (fontSize && fontSize < 9) {\n            textStyle.fontSize = 9;\n            text.scaleX *= fontSize / 9;\n            text.scaleY *= fontSize / 9;\n        }\n        var font = (textStyle.fontSize || textStyle.fontFamily) && [\n            textStyle.fontStyle,\n            textStyle.fontWeight,\n            (textStyle.fontSize || 12) + 'px',\n            textStyle.fontFamily || 'sans-serif'\n        ].join(' ');\n        textStyle.font = font;\n        var rect = text.getBoundingRect();\n        this._textX += rect.width;\n        parentGroup.add(text);\n        return text;\n    };\n    SVGParser.internalField = (function () {\n        nodeParsers = {\n            'g': function (xmlNode, parentGroup) {\n                var g = new Group_1[\"default\"]();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'rect': function (xmlNode, parentGroup) {\n                var rect = new Rect_1[\"default\"]();\n                inheritStyle(parentGroup, rect);\n                parseAttributes(xmlNode, rect, this._defs);\n                rect.setShape({\n                    x: parseFloat(xmlNode.getAttribute('x') || '0'),\n                    y: parseFloat(xmlNode.getAttribute('y') || '0'),\n                    width: parseFloat(xmlNode.getAttribute('width') || '0'),\n                    height: parseFloat(xmlNode.getAttribute('height') || '0')\n                });\n                return rect;\n            },\n            'circle': function (xmlNode, parentGroup) {\n                var circle = new Circle_1[\"default\"]();\n                inheritStyle(parentGroup, circle);\n                parseAttributes(xmlNode, circle, this._defs);\n                circle.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    r: parseFloat(xmlNode.getAttribute('r') || '0')\n                });\n                return circle;\n            },\n            'line': function (xmlNode, parentGroup) {\n                var line = new Line_1[\"default\"]();\n                inheritStyle(parentGroup, line);\n                parseAttributes(xmlNode, line, this._defs);\n                line.setShape({\n                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n                });\n                return line;\n            },\n            'ellipse': function (xmlNode, parentGroup) {\n                var ellipse = new Ellipse_1[\"default\"]();\n                inheritStyle(parentGroup, ellipse);\n                parseAttributes(xmlNode, ellipse, this._defs);\n                ellipse.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n                });\n                return ellipse;\n            },\n            'polygon': function (xmlNode, parentGroup) {\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polygon = new Polygon_1[\"default\"]({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                inheritStyle(parentGroup, polygon);\n                parseAttributes(xmlNode, polygon, this._defs);\n                return polygon;\n            },\n            'polyline': function (xmlNode, parentGroup) {\n                var path = new Path_1[\"default\"]();\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polyline = new Polyline_1[\"default\"]({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                return polyline;\n            },\n            'image': function (xmlNode, parentGroup) {\n                var img = new Image_1[\"default\"]();\n                inheritStyle(parentGroup, img);\n                parseAttributes(xmlNode, img, this._defs);\n                img.setStyle({\n                    image: xmlNode.getAttribute('xlink:href'),\n                    x: +xmlNode.getAttribute('x'),\n                    y: +xmlNode.getAttribute('y'),\n                    width: +xmlNode.getAttribute('width'),\n                    height: +xmlNode.getAttribute('height')\n                });\n                return img;\n            },\n            'text': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x') || '0';\n                var y = xmlNode.getAttribute('y') || '0';\n                var dx = xmlNode.getAttribute('dx') || '0';\n                var dy = xmlNode.getAttribute('dy') || '0';\n                this._textX = parseFloat(x) + parseFloat(dx);\n                this._textY = parseFloat(y) + parseFloat(dy);\n                var g = new Group_1[\"default\"]();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'tspan': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x');\n                var y = xmlNode.getAttribute('y');\n                if (x != null) {\n                    this._textX = parseFloat(x);\n                }\n                if (y != null) {\n                    this._textY = parseFloat(y);\n                }\n                var dx = xmlNode.getAttribute('dx') || 0;\n                var dy = xmlNode.getAttribute('dy') || 0;\n                var g = new Group_1[\"default\"]();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                this._textX += dx;\n                this._textY += dy;\n                return g;\n            },\n            'path': function (xmlNode, parentGroup) {\n                var d = xmlNode.getAttribute('d') || '';\n                var path = path_1.createFromString(d);\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                return path;\n            }\n        };\n    })();\n    return SVGParser;\n}());\nvar defineParsers = {\n    'lineargradient': function (xmlNode) {\n        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n        var gradient = new LinearGradient_1[\"default\"](x1, y1, x2, y2);\n        _parseGradientColorStops(xmlNode, gradient);\n        return gradient;\n    }\n};\nfunction _parseGradientColorStops(xmlNode, gradient) {\n    var stop = xmlNode.firstChild;\n    while (stop) {\n        if (stop.nodeType === 1) {\n            var offsetStr = stop.getAttribute('offset');\n            var offset = void 0;\n            if (offsetStr.indexOf('%') > 0) {\n                offset = parseInt(offsetStr, 10) / 100;\n            }\n            else if (offsetStr) {\n                offset = parseFloat(offsetStr);\n            }\n            else {\n                offset = 0;\n            }\n            var stopColor = stop.getAttribute('stop-color') || '#000000';\n            gradient.colorStops.push({\n                offset: offset,\n                color: stopColor\n            });\n        }\n        stop = stop.nextSibling;\n    }\n}\nfunction inheritStyle(parent, child) {\n    if (parent && parent.__inheritedStyle) {\n        if (!child.__inheritedStyle) {\n            child.__inheritedStyle = {};\n        }\n        util_1.defaults(child.__inheritedStyle, parent.__inheritedStyle);\n    }\n}\nfunction parsePoints(pointsString) {\n    var list = util_1.trim(pointsString).split(DILIMITER_REG);\n    var points = [];\n    for (var i = 0; i < list.length; i += 2) {\n        var x = parseFloat(list[i]);\n        var y = parseFloat(list[i + 1]);\n        points.push([x, y]);\n    }\n    return points;\n}\nvar attributesMap = {\n    'fill': 'fill',\n    'stroke': 'stroke',\n    'stroke-width': 'lineWidth',\n    'opacity': 'opacity',\n    'fill-opacity': 'fillOpacity',\n    'stroke-opacity': 'strokeOpacity',\n    'stroke-dasharray': 'lineDash',\n    'stroke-dashoffset': 'lineDashOffset',\n    'stroke-linecap': 'lineCap',\n    'stroke-linejoin': 'lineJoin',\n    'stroke-miterlimit': 'miterLimit',\n    'font-family': 'fontFamily',\n    'font-size': 'fontSize',\n    'font-style': 'fontStyle',\n    'font-weight': 'fontWeight',\n    'text-align': 'textAlign',\n    'alignment-baseline': 'textBaseline'\n};\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n    var disp = el;\n    var zrStyle = disp.__inheritedStyle || {};\n    if (xmlNode.nodeType === 1) {\n        parseTransformAttribute(xmlNode, el);\n        util_1.extend(zrStyle, parseStyleAttribute(xmlNode));\n        if (!onlyInlineStyle) {\n            for (var svgAttrName in attributesMap) {\n                if (attributesMap.hasOwnProperty(svgAttrName)) {\n                    var attrValue = xmlNode.getAttribute(svgAttrName);\n                    if (attrValue != null) {\n                        zrStyle[attributesMap[svgAttrName]] = attrValue;\n                    }\n                }\n            }\n        }\n    }\n    disp.style = disp.style || {};\n    zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n    zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n    util_1.each([\n        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n    });\n    if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n        zrStyle.textBaseline = 'alphabetic';\n    }\n    if (zrStyle.textBaseline === 'alphabetic') {\n        zrStyle.textBaseline = 'bottom';\n    }\n    if (zrStyle.textAlign === 'start') {\n        zrStyle.textAlign = 'left';\n    }\n    if (zrStyle.textAlign === 'end') {\n        zrStyle.textAlign = 'right';\n    }\n    util_1.each(['lineDashOffset', 'lineCap', 'lineJoin',\n        'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n    });\n    if (zrStyle.lineDash) {\n        disp.style.lineDash = util_1.map(util_1.trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n            return parseFloat(str);\n        });\n    }\n    disp.__inheritedStyle = zrStyle;\n}\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\nfunction getPaint(str, defs) {\n    var urlMatch = defs && str && str.match(urlRegex);\n    if (urlMatch) {\n        var url = util_1.trim(urlMatch[1]);\n        var def = defs[url];\n        return def;\n    }\n    return str;\n}\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\nfunction parseTransformAttribute(xmlNode, node) {\n    var transform = xmlNode.getAttribute('transform');\n    if (transform) {\n        transform = transform.replace(/,/g, ' ');\n        var transformOps_1 = [];\n        var m = null;\n        transform.replace(transformRegex, function (str, type, value) {\n            transformOps_1.push(type, value);\n            return '';\n        });\n        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n            var value = transformOps_1[i];\n            var type = transformOps_1[i - 1];\n            var valueArr = void 0;\n            m = m || matrix.create();\n            switch (type) {\n                case 'translate':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n                    break;\n                case 'scale':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n                    break;\n                case 'rotate':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    matrix.rotate(m, m, parseFloat(valueArr[0]));\n                    break;\n                case 'skew':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    console.warn('Skew transform is not supported yet');\n                    break;\n                case 'matrix':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    m[0] = parseFloat(valueArr[0]);\n                    m[1] = parseFloat(valueArr[1]);\n                    m[2] = parseFloat(valueArr[2]);\n                    m[3] = parseFloat(valueArr[3]);\n                    m[4] = parseFloat(valueArr[4]);\n                    m[5] = parseFloat(valueArr[5]);\n                    break;\n            }\n        }\n        node.setLocalTransform(m);\n    }\n}\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\nfunction parseStyleAttribute(xmlNode) {\n    var style = xmlNode.getAttribute('style');\n    var result = {};\n    if (!style) {\n        return result;\n    }\n    var styleList = {};\n    styleRegex.lastIndex = 0;\n    var styleRegResult;\n    while ((styleRegResult = styleRegex.exec(style)) != null) {\n        styleList[styleRegResult[1]] = styleRegResult[2];\n    }\n    for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n            result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n        }\n    }\n    return result;\n}\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n    var scaleX = width / viewBoxRect.width;\n    var scaleY = height / viewBoxRect.height;\n    var scale = Math.min(scaleX, scaleY);\n    return {\n        scale: scale,\n        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n    };\n}\nexports.makeViewBoxTransform = makeViewBoxTransform;\nfunction parseSVG(xml, opt) {\n    var parser = new SVGParser();\n    return parser.parse(xml, opt);\n}\nexports.parseSVG = parseSVG;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}