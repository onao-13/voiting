{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { Group } from '../scene/group';\nimport { Selection } from '../scene/selection';\nimport { MarkerLabel } from './markerLabel';\nimport { getFont } from '../scene/shape/text';\nimport { getMarker } from './marker/util';\nimport { createId } from '../util/id';\nimport { RedrawType } from '../scene/node';\nimport { HdpiCanvas } from '../canvas/hdpiCanvas';\nimport { BOOLEAN, FUNCTION, NUMBER, OPT_BOOLEAN, OPT_FONT_STYLE, OPT_FONT_WEIGHT, OPT_FUNCTION, OPT_NUMBER, POSITION, COLOR_STRING, STRING, Validate } from '../util/validation';\nimport { Layers } from './layers';\nexport var LegendOrientation;\n(function (LegendOrientation) {\n  LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n  LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation || (LegendOrientation = {}));\nexport var LegendPosition;\n(function (LegendPosition) {\n  LegendPosition[\"Top\"] = \"top\";\n  LegendPosition[\"Right\"] = \"right\";\n  LegendPosition[\"Bottom\"] = \"bottom\";\n  LegendPosition[\"Left\"] = \"left\";\n})(LegendPosition || (LegendPosition = {}));\nvar LegendLabel = /** @class */function () {\n  function LegendLabel() {\n    this.maxLength = undefined;\n    this.color = 'black';\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n    this.formatter = undefined;\n  }\n  LegendLabel.prototype.getFont = function () {\n    return getFont(this.fontSize, this.fontFamily, this.fontStyle, this.fontWeight);\n  };\n  __decorate([Validate(OPT_NUMBER(0))], LegendLabel.prototype, \"maxLength\", void 0);\n  __decorate([Validate(COLOR_STRING)], LegendLabel.prototype, \"color\", void 0);\n  __decorate([Validate(OPT_FONT_STYLE)], LegendLabel.prototype, \"fontStyle\", void 0);\n  __decorate([Validate(OPT_FONT_WEIGHT)], LegendLabel.prototype, \"fontWeight\", void 0);\n  __decorate([Validate(NUMBER(0))], LegendLabel.prototype, \"fontSize\", void 0);\n  __decorate([Validate(STRING)], LegendLabel.prototype, \"fontFamily\", void 0);\n  __decorate([Validate(OPT_FUNCTION)], LegendLabel.prototype, \"formatter\", void 0);\n  return LegendLabel;\n}();\nexport { LegendLabel };\nvar LegendMarker = /** @class */function () {\n  function LegendMarker() {\n    this.size = 15;\n    /**\n     * If the marker type is set, the legend will always use that marker type for all its items,\n     * regardless of the type that comes from the `data`.\n     */\n    this._shape = undefined;\n    /**\n     * Padding between the marker and the label within each legend item.\n     */\n    this.padding = 8;\n    this.strokeWidth = 1;\n  }\n  Object.defineProperty(LegendMarker.prototype, \"shape\", {\n    get: function () {\n      return this._shape;\n    },\n    set: function (value) {\n      var _a;\n      this._shape = value;\n      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.onMarkerShapeChange();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  __decorate([Validate(NUMBER(0))], LegendMarker.prototype, \"size\", void 0);\n  __decorate([Validate(NUMBER(0))], LegendMarker.prototype, \"padding\", void 0);\n  __decorate([Validate(NUMBER(0))], LegendMarker.prototype, \"strokeWidth\", void 0);\n  return LegendMarker;\n}();\nexport { LegendMarker };\nvar LegendItem = /** @class */function () {\n  function LegendItem() {\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    /** Used to constrain the width of legend items. */\n    this.maxWidth = undefined;\n    /**\n     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\n     * padding between legend items.\n     */\n    this.paddingX = 16;\n    /**\n     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\n     * padding between legend items.\n     */\n    this.paddingY = 8;\n  }\n  __decorate([Validate(OPT_NUMBER(0))], LegendItem.prototype, \"maxWidth\", void 0);\n  __decorate([Validate(NUMBER(0))], LegendItem.prototype, \"paddingX\", void 0);\n  __decorate([Validate(NUMBER(0))], LegendItem.prototype, \"paddingY\", void 0);\n  return LegendItem;\n}();\nexport { LegendItem };\nvar NO_OP_LISTENER = function () {\n  // Default listener that does nothing.\n};\nvar LegendListeners = /** @class */function () {\n  function LegendListeners() {\n    this.legendItemClick = NO_OP_LISTENER;\n  }\n  __decorate([Validate(FUNCTION)], LegendListeners.prototype, \"legendItemClick\", void 0);\n  return LegendListeners;\n}();\nexport { LegendListeners };\nvar Legend = /** @class */function () {\n  function Legend() {\n    this.id = createId(this);\n    this.group = new Group({\n      name: 'legend',\n      layer: true,\n      zIndex: Layers.LEGEND_ZINDEX\n    });\n    this.itemSelection = Selection.select(this.group).selectAll();\n    this.oldSize = [0, 0];\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.truncatedItems = new Set();\n    this._data = [];\n    this._enabled = true;\n    this.orientation = LegendOrientation.Vertical;\n    this._position = LegendPosition.Right;\n    /** Reverse the display order of legend items if `true`. */\n    this.reverseOrder = undefined;\n    /**\n     * Spacing between the legend and the edge of the chart's element.\n     */\n    this.spacing = 20;\n    this.characterWidths = new Map();\n    this.size = [0, 0];\n    this.item.marker.parent = this;\n  }\n  Object.defineProperty(Legend.prototype, \"data\", {\n    get: function () {\n      return this._data;\n    },\n    set: function (value) {\n      this._data = value;\n      this.group.visible = value.length > 0 && this.enabled;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Legend.prototype, \"enabled\", {\n    get: function () {\n      return this._enabled;\n    },\n    set: function (value) {\n      this._enabled = value;\n      this.group.visible = value && this.data.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Legend.prototype, \"position\", {\n    get: function () {\n      return this._position;\n    },\n    set: function (value) {\n      this._position = value;\n      switch (value) {\n        case 'right':\n        case 'left':\n          this.orientation = LegendOrientation.Vertical;\n          break;\n        case 'bottom':\n        case 'top':\n          this.orientation = LegendOrientation.Horizontal;\n          break;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Legend.prototype.onMarkerShapeChange = function () {\n    this.itemSelection = this.itemSelection.setData([]);\n    this.itemSelection.exit.remove();\n    this.group.markDirty(this.group, RedrawType.MINOR);\n  };\n  Legend.prototype.getCharacterWidths = function (font) {\n    var characterWidths = this.characterWidths;\n    if (characterWidths.has(font)) {\n      return characterWidths.get(font);\n    }\n    var cw = {\n      '...': HdpiCanvas.getTextSize('...', font).width\n    };\n    characterWidths.set(font, cw);\n    return cw;\n  };\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  Legend.prototype.performLayout = function (width, height) {\n    var _this = this;\n    var _a = this.item,\n      paddingX = _a.paddingX,\n      paddingY = _a.paddingY,\n      label = _a.label,\n      maxWidth = _a.maxWidth,\n      _b = _a.marker,\n      markerSize = _b.size,\n      markerPadding = _b.padding,\n      markerShape = _b.shape,\n      _c = _a.label,\n      _d = _c.maxLength,\n      maxLength = _d === void 0 ? Infinity : _d,\n      fontStyle = _c.fontStyle,\n      fontWeight = _c.fontWeight,\n      fontSize = _c.fontSize,\n      fontFamily = _c.fontFamily;\n    var data = __spread(this.data);\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    var updateSelection = this.itemSelection.setData(data, function (_, datum) {\n      var Marker = getMarker(markerShape || datum.marker.shape);\n      return datum.id + '-' + datum.itemId + '-' + Marker.name;\n    });\n    updateSelection.exit.remove();\n    var enterSelection = updateSelection.enter.append(MarkerLabel).each(function (node, datum) {\n      var Marker = getMarker(markerShape || datum.marker.shape);\n      node.marker = new Marker();\n    });\n    var itemSelection = this.itemSelection = updateSelection.merge(enterSelection);\n    var itemCount = itemSelection.size;\n    // Update properties that affect the size of the legend items and measure them.\n    var bboxes = [];\n    var font = label.getFont();\n    var ellipsis = \"...\";\n    var itemMaxWidthPercentage = 0.8;\n    var maxItemWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : width * itemMaxWidthPercentage;\n    itemSelection.each(function (markerLabel, datum) {\n      var e_1, _a;\n      var _b;\n      var text = (_b = datum.label.text, _b !== null && _b !== void 0 ? _b : '<unknown>');\n      markerLabel.markerSize = markerSize;\n      markerLabel.spacing = markerPadding;\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      var textChars = text.split('');\n      var addEllipsis = false;\n      if (text.length > maxLength) {\n        text = \"\" + text.substring(0, maxLength);\n        addEllipsis = true;\n      }\n      var labelWidth = markerSize + markerPadding + HdpiCanvas.getTextSize(text, font).width;\n      if (labelWidth > maxItemWidth) {\n        var truncatedText = '';\n        var characterWidths = _this.getCharacterWidths(font);\n        var cumCharSize = characterWidths[ellipsis];\n        try {\n          for (var textChars_1 = __values(textChars), textChars_1_1 = textChars_1.next(); !textChars_1_1.done; textChars_1_1 = textChars_1.next()) {\n            var char = textChars_1_1.value;\n            if (!characterWidths[char]) {\n              characterWidths[char] = HdpiCanvas.getTextSize(char, font).width;\n            }\n            cumCharSize += characterWidths[char];\n            if (cumCharSize > maxItemWidth) {\n              break;\n            }\n            truncatedText += char;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (textChars_1_1 && !textChars_1_1.done && (_a = textChars_1.return)) _a.call(textChars_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n        text = truncatedText;\n        addEllipsis = true;\n      }\n      var id = datum.itemId || datum.id;\n      if (addEllipsis) {\n        text += ellipsis;\n        _this.truncatedItems.add(id);\n      } else {\n        _this.truncatedItems.delete(id);\n      }\n      markerLabel.text = text;\n      bboxes.push(markerLabel.computeBBox());\n    });\n    var itemHeight = bboxes.length && bboxes[0].height;\n    var rowCount = 0;\n    var columnWidth = 0;\n    var paddedItemsWidth = 0;\n    var paddedItemsHeight = 0;\n    width = Math.max(1, width);\n    height = Math.max(1, height);\n    switch (this.orientation) {\n      case LegendOrientation.Horizontal:\n        if (!(isFinite(width) && width > 0)) {\n          return false;\n        }\n        rowCount = 0;\n        var columnCount = 0;\n        // Split legend items into columns until the width is suitable.\n        do {\n          var itemsWidth = 0;\n          columnCount = 0;\n          columnWidth = 0;\n          rowCount++;\n          var i = 0;\n          while (i < itemCount) {\n            var bbox = bboxes[i];\n            if (bbox.width > columnWidth) {\n              columnWidth = bbox.width;\n            }\n            i++;\n            if (i % rowCount === 0) {\n              itemsWidth += columnWidth;\n              columnWidth = 0;\n              columnCount++;\n            }\n          }\n          if (i % rowCount !== 0) {\n            itemsWidth += columnWidth;\n            columnCount++;\n          }\n          paddedItemsWidth = itemsWidth + (columnCount - 1) * paddingX;\n        } while (paddedItemsWidth > width && columnCount > 1);\n        paddedItemsHeight = itemHeight * rowCount + (rowCount - 1) * paddingY;\n        break;\n      case LegendOrientation.Vertical:\n        if (!(isFinite(height) && height > 0)) {\n          return false;\n        }\n        rowCount = itemCount * 2;\n        // Split legend items into columns until the height is suitable.\n        do {\n          rowCount = (rowCount >> 1) + rowCount % 2;\n          columnWidth = 0;\n          var itemsWidth = 0;\n          var itemsHeight = 0;\n          var columnCount_1 = 0;\n          var i = 0;\n          while (i < itemCount) {\n            var bbox = bboxes[i];\n            if (!columnCount_1) {\n              itemsHeight += bbox.height;\n            }\n            if (bbox.width > columnWidth) {\n              columnWidth = bbox.width;\n            }\n            i++;\n            if (i % rowCount === 0) {\n              itemsWidth += columnWidth;\n              columnWidth = 0;\n              columnCount_1++;\n            }\n          }\n          if (i % rowCount !== 0) {\n            itemsWidth += columnWidth;\n            columnCount_1++;\n          }\n          paddedItemsWidth = itemsWidth + (columnCount_1 - 1) * paddingX;\n          paddedItemsHeight = itemsHeight + (rowCount - 1) * paddingY;\n        } while (paddedItemsHeight > height && rowCount > 1);\n        break;\n    }\n    // Top-left corner of the first legend item.\n    var startX = (width - paddedItemsWidth) / 2;\n    var startY = (height - paddedItemsHeight) / 2;\n    var x = 0;\n    var y = 0;\n    columnWidth = 0;\n    // Position legend items using the layout computed above.\n    itemSelection.each(function (markerLabel, _, i) {\n      // Round off for pixel grid alignment to work properly.\n      markerLabel.translationX = Math.floor(startX + x);\n      markerLabel.translationY = Math.floor(startY + y);\n      var bbox = bboxes[i];\n      if (bbox.width > columnWidth) {\n        columnWidth = bbox.width;\n      }\n      if ((i + 1) % rowCount === 0) {\n        x += columnWidth + paddingX;\n        y = 0;\n        columnWidth = 0;\n      } else {\n        y += bbox.height + paddingY;\n      }\n    });\n    // Update legend item properties that don't affect the layout.\n    this.update();\n    var size = this.size;\n    var oldSize = this.oldSize;\n    size[0] = paddedItemsWidth;\n    size[1] = paddedItemsHeight;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n  };\n  Legend.prototype.update = function () {\n    var _a = this.item,\n      strokeWidth = _a.marker.strokeWidth,\n      color = _a.label.color;\n    this.itemSelection.each(function (markerLabel, datum) {\n      var marker = datum.marker;\n      markerLabel.markerFill = marker.fill;\n      markerLabel.markerStroke = marker.stroke;\n      markerLabel.markerStrokeWidth = strokeWidth;\n      markerLabel.markerFillOpacity = marker.fillOpacity;\n      markerLabel.markerStrokeOpacity = marker.strokeOpacity;\n      markerLabel.opacity = datum.enabled ? 1 : 0.5;\n      markerLabel.color = color;\n    });\n  };\n  Legend.prototype.getDatumForPoint = function (x, y) {\n    var node = this.group.pickNode(x, y);\n    if (node && node.parent) {\n      return node.parent.datum;\n    }\n  };\n  Legend.className = 'Legend';\n  __decorate([Validate(BOOLEAN)], Legend.prototype, \"_enabled\", void 0);\n  __decorate([Validate(POSITION)], Legend.prototype, \"_position\", void 0);\n  __decorate([Validate(OPT_BOOLEAN)], Legend.prototype, \"reverseOrder\", void 0);\n  __decorate([Validate(NUMBER(0))], Legend.prototype, \"spacing\", void 0);\n  return Legend;\n}();\nexport { Legend };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__read","o","n","m","Symbol","iterator","call","ar","e","next","done","push","value","error","__spread","concat","__values","s","TypeError","Group","Selection","MarkerLabel","getFont","getMarker","createId","RedrawType","HdpiCanvas","BOOLEAN","FUNCTION","NUMBER","OPT_BOOLEAN","OPT_FONT_STYLE","OPT_FONT_WEIGHT","OPT_FUNCTION","OPT_NUMBER","POSITION","COLOR_STRING","STRING","Validate","Layers","LegendOrientation","LegendPosition","LegendLabel","maxLength","undefined","color","fontStyle","fontWeight","fontSize","fontFamily","formatter","prototype","LegendMarker","size","_shape","padding","strokeWidth","get","set","_a","parent","onMarkerShapeChange","enumerable","configurable","LegendItem","marker","label","maxWidth","paddingX","paddingY","NO_OP_LISTENER","LegendListeners","legendItemClick","Legend","id","group","name","layer","zIndex","LEGEND_ZINDEX","itemSelection","select","selectAll","oldSize","item","listeners","truncatedItems","Set","_data","_enabled","orientation","Vertical","_position","Right","reverseOrder","spacing","characterWidths","Map","visible","enabled","data","Horizontal","setData","exit","remove","markDirty","MINOR","getCharacterWidths","font","has","cw","getTextSize","width","performLayout","height","_this","_b","markerSize","markerPadding","markerShape","shape","_c","_d","Infinity","reverse","updateSelection","_","datum","Marker","itemId","enterSelection","enter","append","each","node","merge","itemCount","bboxes","ellipsis","itemMaxWidthPercentage","maxItemWidth","markerLabel","e_1","text","textChars","split","addEllipsis","substring","labelWidth","truncatedText","cumCharSize","textChars_1","textChars_1_1","char","e_1_1","return","add","delete","computeBBox","itemHeight","rowCount","columnWidth","paddedItemsWidth","paddedItemsHeight","Math","max","isFinite","columnCount","itemsWidth","bbox","itemsHeight","columnCount_1","startX","startY","x","y","translationX","floor","translationY","update","markerFill","fill","markerStroke","stroke","markerStrokeWidth","markerFillOpacity","fillOpacity","markerStrokeOpacity","strokeOpacity","opacity","getDatumForPoint","pickNode","className"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/chart/legend.js"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { Group } from '../scene/group';\nimport { Selection } from '../scene/selection';\nimport { MarkerLabel } from './markerLabel';\nimport { getFont } from '../scene/shape/text';\nimport { getMarker } from './marker/util';\nimport { createId } from '../util/id';\nimport { RedrawType } from '../scene/node';\nimport { HdpiCanvas } from '../canvas/hdpiCanvas';\nimport { BOOLEAN, FUNCTION, NUMBER, OPT_BOOLEAN, OPT_FONT_STYLE, OPT_FONT_WEIGHT, OPT_FUNCTION, OPT_NUMBER, POSITION, COLOR_STRING, STRING, Validate, } from '../util/validation';\nimport { Layers } from './layers';\nexport var LegendOrientation;\n(function (LegendOrientation) {\n    LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n    LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation || (LegendOrientation = {}));\nexport var LegendPosition;\n(function (LegendPosition) {\n    LegendPosition[\"Top\"] = \"top\";\n    LegendPosition[\"Right\"] = \"right\";\n    LegendPosition[\"Bottom\"] = \"bottom\";\n    LegendPosition[\"Left\"] = \"left\";\n})(LegendPosition || (LegendPosition = {}));\nvar LegendLabel = /** @class */ (function () {\n    function LegendLabel() {\n        this.maxLength = undefined;\n        this.color = 'black';\n        this.fontStyle = undefined;\n        this.fontWeight = undefined;\n        this.fontSize = 12;\n        this.fontFamily = 'Verdana, sans-serif';\n        this.formatter = undefined;\n    }\n    LegendLabel.prototype.getFont = function () {\n        return getFont(this.fontSize, this.fontFamily, this.fontStyle, this.fontWeight);\n    };\n    __decorate([\n        Validate(OPT_NUMBER(0))\n    ], LegendLabel.prototype, \"maxLength\", void 0);\n    __decorate([\n        Validate(COLOR_STRING)\n    ], LegendLabel.prototype, \"color\", void 0);\n    __decorate([\n        Validate(OPT_FONT_STYLE)\n    ], LegendLabel.prototype, \"fontStyle\", void 0);\n    __decorate([\n        Validate(OPT_FONT_WEIGHT)\n    ], LegendLabel.prototype, \"fontWeight\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], LegendLabel.prototype, \"fontSize\", void 0);\n    __decorate([\n        Validate(STRING)\n    ], LegendLabel.prototype, \"fontFamily\", void 0);\n    __decorate([\n        Validate(OPT_FUNCTION)\n    ], LegendLabel.prototype, \"formatter\", void 0);\n    return LegendLabel;\n}());\nexport { LegendLabel };\nvar LegendMarker = /** @class */ (function () {\n    function LegendMarker() {\n        this.size = 15;\n        /**\n         * If the marker type is set, the legend will always use that marker type for all its items,\n         * regardless of the type that comes from the `data`.\n         */\n        this._shape = undefined;\n        /**\n         * Padding between the marker and the label within each legend item.\n         */\n        this.padding = 8;\n        this.strokeWidth = 1;\n    }\n    Object.defineProperty(LegendMarker.prototype, \"shape\", {\n        get: function () {\n            return this._shape;\n        },\n        set: function (value) {\n            var _a;\n            this._shape = value;\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.onMarkerShapeChange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate([\n        Validate(NUMBER(0))\n    ], LegendMarker.prototype, \"size\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], LegendMarker.prototype, \"padding\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], LegendMarker.prototype, \"strokeWidth\", void 0);\n    return LegendMarker;\n}());\nexport { LegendMarker };\nvar LegendItem = /** @class */ (function () {\n    function LegendItem() {\n        this.marker = new LegendMarker();\n        this.label = new LegendLabel();\n        /** Used to constrain the width of legend items. */\n        this.maxWidth = undefined;\n        /**\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\n         * padding between legend items.\n         */\n        this.paddingX = 16;\n        /**\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\n         * padding between legend items.\n         */\n        this.paddingY = 8;\n    }\n    __decorate([\n        Validate(OPT_NUMBER(0))\n    ], LegendItem.prototype, \"maxWidth\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], LegendItem.prototype, \"paddingX\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], LegendItem.prototype, \"paddingY\", void 0);\n    return LegendItem;\n}());\nexport { LegendItem };\nvar NO_OP_LISTENER = function () {\n    // Default listener that does nothing.\n};\nvar LegendListeners = /** @class */ (function () {\n    function LegendListeners() {\n        this.legendItemClick = NO_OP_LISTENER;\n    }\n    __decorate([\n        Validate(FUNCTION)\n    ], LegendListeners.prototype, \"legendItemClick\", void 0);\n    return LegendListeners;\n}());\nexport { LegendListeners };\nvar Legend = /** @class */ (function () {\n    function Legend() {\n        this.id = createId(this);\n        this.group = new Group({ name: 'legend', layer: true, zIndex: Layers.LEGEND_ZINDEX });\n        this.itemSelection = Selection.select(this.group).selectAll();\n        this.oldSize = [0, 0];\n        this.item = new LegendItem();\n        this.listeners = new LegendListeners();\n        this.truncatedItems = new Set();\n        this._data = [];\n        this._enabled = true;\n        this.orientation = LegendOrientation.Vertical;\n        this._position = LegendPosition.Right;\n        /** Reverse the display order of legend items if `true`. */\n        this.reverseOrder = undefined;\n        /**\n         * Spacing between the legend and the edge of the chart's element.\n         */\n        this.spacing = 20;\n        this.characterWidths = new Map();\n        this.size = [0, 0];\n        this.item.marker.parent = this;\n    }\n    Object.defineProperty(Legend.prototype, \"data\", {\n        get: function () {\n            return this._data;\n        },\n        set: function (value) {\n            this._data = value;\n            this.group.visible = value.length > 0 && this.enabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        set: function (value) {\n            this._enabled = value;\n            this.group.visible = value && this.data.length > 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Legend.prototype, \"position\", {\n        get: function () {\n            return this._position;\n        },\n        set: function (value) {\n            this._position = value;\n            switch (value) {\n                case 'right':\n                case 'left':\n                    this.orientation = LegendOrientation.Vertical;\n                    break;\n                case 'bottom':\n                case 'top':\n                    this.orientation = LegendOrientation.Horizontal;\n                    break;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Legend.prototype.onMarkerShapeChange = function () {\n        this.itemSelection = this.itemSelection.setData([]);\n        this.itemSelection.exit.remove();\n        this.group.markDirty(this.group, RedrawType.MINOR);\n    };\n    Legend.prototype.getCharacterWidths = function (font) {\n        var characterWidths = this.characterWidths;\n        if (characterWidths.has(font)) {\n            return characterWidths.get(font);\n        }\n        var cw = {\n            '...': HdpiCanvas.getTextSize('...', font).width,\n        };\n        characterWidths.set(font, cw);\n        return cw;\n    };\n    /**\n     * The method is given the desired size of the legend, which only serves as a hint.\n     * The vertically oriented legend will take as much horizontal space as needed, but will\n     * respect the height constraints, and the horizontal legend will take as much vertical\n     * space as needed in an attempt not to exceed the given width.\n     * After the layout is done, the {@link size} will contain the actual size of the legend.\n     * If the actual size is not the same as the previous actual size, the legend will fire\n     * the 'layoutChange' event to communicate that another layout is needed, and the above\n     * process should be repeated.\n     * @param width\n     * @param height\n     */\n    Legend.prototype.performLayout = function (width, height) {\n        var _this = this;\n        var _a = this.item, paddingX = _a.paddingX, paddingY = _a.paddingY, label = _a.label, maxWidth = _a.maxWidth, _b = _a.marker, markerSize = _b.size, markerPadding = _b.padding, markerShape = _b.shape, _c = _a.label, _d = _c.maxLength, maxLength = _d === void 0 ? Infinity : _d, fontStyle = _c.fontStyle, fontWeight = _c.fontWeight, fontSize = _c.fontSize, fontFamily = _c.fontFamily;\n        var data = __spread(this.data);\n        if (this.reverseOrder) {\n            data.reverse();\n        }\n        var updateSelection = this.itemSelection.setData(data, function (_, datum) {\n            var Marker = getMarker(markerShape || datum.marker.shape);\n            return datum.id + '-' + datum.itemId + '-' + Marker.name;\n        });\n        updateSelection.exit.remove();\n        var enterSelection = updateSelection.enter.append(MarkerLabel).each(function (node, datum) {\n            var Marker = getMarker(markerShape || datum.marker.shape);\n            node.marker = new Marker();\n        });\n        var itemSelection = (this.itemSelection = updateSelection.merge(enterSelection));\n        var itemCount = itemSelection.size;\n        // Update properties that affect the size of the legend items and measure them.\n        var bboxes = [];\n        var font = label.getFont();\n        var ellipsis = \"...\";\n        var itemMaxWidthPercentage = 0.8;\n        var maxItemWidth = (maxWidth !== null && maxWidth !== void 0 ? maxWidth : width * itemMaxWidthPercentage);\n        itemSelection.each(function (markerLabel, datum) {\n            var e_1, _a;\n            var _b;\n            var text = (_b = datum.label.text, (_b !== null && _b !== void 0 ? _b : '<unknown>'));\n            markerLabel.markerSize = markerSize;\n            markerLabel.spacing = markerPadding;\n            markerLabel.fontStyle = fontStyle;\n            markerLabel.fontWeight = fontWeight;\n            markerLabel.fontSize = fontSize;\n            markerLabel.fontFamily = fontFamily;\n            var textChars = text.split('');\n            var addEllipsis = false;\n            if (text.length > maxLength) {\n                text = \"\" + text.substring(0, maxLength);\n                addEllipsis = true;\n            }\n            var labelWidth = markerSize + markerPadding + HdpiCanvas.getTextSize(text, font).width;\n            if (labelWidth > maxItemWidth) {\n                var truncatedText = '';\n                var characterWidths = _this.getCharacterWidths(font);\n                var cumCharSize = characterWidths[ellipsis];\n                try {\n                    for (var textChars_1 = __values(textChars), textChars_1_1 = textChars_1.next(); !textChars_1_1.done; textChars_1_1 = textChars_1.next()) {\n                        var char = textChars_1_1.value;\n                        if (!characterWidths[char]) {\n                            characterWidths[char] = HdpiCanvas.getTextSize(char, font).width;\n                        }\n                        cumCharSize += characterWidths[char];\n                        if (cumCharSize > maxItemWidth) {\n                            break;\n                        }\n                        truncatedText += char;\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (textChars_1_1 && !textChars_1_1.done && (_a = textChars_1.return)) _a.call(textChars_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                text = truncatedText;\n                addEllipsis = true;\n            }\n            var id = datum.itemId || datum.id;\n            if (addEllipsis) {\n                text += ellipsis;\n                _this.truncatedItems.add(id);\n            }\n            else {\n                _this.truncatedItems.delete(id);\n            }\n            markerLabel.text = text;\n            bboxes.push(markerLabel.computeBBox());\n        });\n        var itemHeight = bboxes.length && bboxes[0].height;\n        var rowCount = 0;\n        var columnWidth = 0;\n        var paddedItemsWidth = 0;\n        var paddedItemsHeight = 0;\n        width = Math.max(1, width);\n        height = Math.max(1, height);\n        switch (this.orientation) {\n            case LegendOrientation.Horizontal:\n                if (!(isFinite(width) && width > 0)) {\n                    return false;\n                }\n                rowCount = 0;\n                var columnCount = 0;\n                // Split legend items into columns until the width is suitable.\n                do {\n                    var itemsWidth = 0;\n                    columnCount = 0;\n                    columnWidth = 0;\n                    rowCount++;\n                    var i = 0;\n                    while (i < itemCount) {\n                        var bbox = bboxes[i];\n                        if (bbox.width > columnWidth) {\n                            columnWidth = bbox.width;\n                        }\n                        i++;\n                        if (i % rowCount === 0) {\n                            itemsWidth += columnWidth;\n                            columnWidth = 0;\n                            columnCount++;\n                        }\n                    }\n                    if (i % rowCount !== 0) {\n                        itemsWidth += columnWidth;\n                        columnCount++;\n                    }\n                    paddedItemsWidth = itemsWidth + (columnCount - 1) * paddingX;\n                } while (paddedItemsWidth > width && columnCount > 1);\n                paddedItemsHeight = itemHeight * rowCount + (rowCount - 1) * paddingY;\n                break;\n            case LegendOrientation.Vertical:\n                if (!(isFinite(height) && height > 0)) {\n                    return false;\n                }\n                rowCount = itemCount * 2;\n                // Split legend items into columns until the height is suitable.\n                do {\n                    rowCount = (rowCount >> 1) + (rowCount % 2);\n                    columnWidth = 0;\n                    var itemsWidth = 0;\n                    var itemsHeight = 0;\n                    var columnCount_1 = 0;\n                    var i = 0;\n                    while (i < itemCount) {\n                        var bbox = bboxes[i];\n                        if (!columnCount_1) {\n                            itemsHeight += bbox.height;\n                        }\n                        if (bbox.width > columnWidth) {\n                            columnWidth = bbox.width;\n                        }\n                        i++;\n                        if (i % rowCount === 0) {\n                            itemsWidth += columnWidth;\n                            columnWidth = 0;\n                            columnCount_1++;\n                        }\n                    }\n                    if (i % rowCount !== 0) {\n                        itemsWidth += columnWidth;\n                        columnCount_1++;\n                    }\n                    paddedItemsWidth = itemsWidth + (columnCount_1 - 1) * paddingX;\n                    paddedItemsHeight = itemsHeight + (rowCount - 1) * paddingY;\n                } while (paddedItemsHeight > height && rowCount > 1);\n                break;\n        }\n        // Top-left corner of the first legend item.\n        var startX = (width - paddedItemsWidth) / 2;\n        var startY = (height - paddedItemsHeight) / 2;\n        var x = 0;\n        var y = 0;\n        columnWidth = 0;\n        // Position legend items using the layout computed above.\n        itemSelection.each(function (markerLabel, _, i) {\n            // Round off for pixel grid alignment to work properly.\n            markerLabel.translationX = Math.floor(startX + x);\n            markerLabel.translationY = Math.floor(startY + y);\n            var bbox = bboxes[i];\n            if (bbox.width > columnWidth) {\n                columnWidth = bbox.width;\n            }\n            if ((i + 1) % rowCount === 0) {\n                x += columnWidth + paddingX;\n                y = 0;\n                columnWidth = 0;\n            }\n            else {\n                y += bbox.height + paddingY;\n            }\n        });\n        // Update legend item properties that don't affect the layout.\n        this.update();\n        var size = this.size;\n        var oldSize = this.oldSize;\n        size[0] = paddedItemsWidth;\n        size[1] = paddedItemsHeight;\n        if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n            oldSize[0] = size[0];\n            oldSize[1] = size[1];\n        }\n    };\n    Legend.prototype.update = function () {\n        var _a = this.item, strokeWidth = _a.marker.strokeWidth, color = _a.label.color;\n        this.itemSelection.each(function (markerLabel, datum) {\n            var marker = datum.marker;\n            markerLabel.markerFill = marker.fill;\n            markerLabel.markerStroke = marker.stroke;\n            markerLabel.markerStrokeWidth = strokeWidth;\n            markerLabel.markerFillOpacity = marker.fillOpacity;\n            markerLabel.markerStrokeOpacity = marker.strokeOpacity;\n            markerLabel.opacity = datum.enabled ? 1 : 0.5;\n            markerLabel.color = color;\n        });\n    };\n    Legend.prototype.getDatumForPoint = function (x, y) {\n        var node = this.group.pickNode(x, y);\n        if (node && node.parent) {\n            return node.parent.datum;\n        }\n    };\n    Legend.className = 'Legend';\n    __decorate([\n        Validate(BOOLEAN)\n    ], Legend.prototype, \"_enabled\", void 0);\n    __decorate([\n        Validate(POSITION)\n    ], Legend.prototype, \"_position\", void 0);\n    __decorate([\n        Validate(OPT_BOOLEAN)\n    ], Legend.prototype, \"reverseOrder\", void 0);\n    __decorate([\n        Validate(NUMBER(0))\n    ], Legend.prototype, \"spacing\", void 0);\n    return Legend;\n}());\nexport { Legend };\n"],"mappings":";AAAA,IAAIA,UAAU,GAAI,IAAI,IAAI,IAAI,CAACA,UAAU,IAAK,UAAUC,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE;EACnF,IAAIC,CAAC,GAAGC,SAAS,CAACC,MAAM;IAAEC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGH,MAAM,GAAGE,IAAI,KAAK,IAAI,GAAGA,IAAI,GAAGK,MAAM,CAACC,wBAAwB,CAACR,MAAM,EAAEC,GAAG,CAAC,GAAGC,IAAI;IAAEO,CAAC;EAC5H,IAAI,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOA,OAAO,CAACC,QAAQ,KAAK,UAAU,EAAEL,CAAC,GAAGI,OAAO,CAACC,QAAQ,CAACZ,UAAU,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,CAAC,CAAC,KAC1H,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAM,GAAG,CAAC,EAAEO,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE,IAAIH,CAAC,GAAGV,UAAU,CAACa,CAAC,CAAC,EAAEN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACH,CAAC,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAGM,CAAC,CAACT,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,GAAGG,CAAC,CAACT,MAAM,EAAEC,GAAG,CAAC,KAAKK,CAAC;EACjJ,OAAOH,CAAC,GAAG,CAAC,IAAIG,CAAC,IAAIC,MAAM,CAACM,cAAc,CAACb,MAAM,EAAEC,GAAG,EAAEK,CAAC,CAAC,EAAEA,CAAC;AACjE,CAAC;AACD,IAAIQ,MAAM,GAAI,IAAI,IAAI,IAAI,CAACA,MAAM,IAAK,UAAUC,CAAC,EAAEC,CAAC,EAAE;EAClD,IAAIC,CAAC,GAAG,OAAOC,MAAM,KAAK,UAAU,IAAIH,CAAC,CAACG,MAAM,CAACC,QAAQ,CAAC;EAC1D,IAAI,CAACF,CAAC,EAAE,OAAOF,CAAC;EAChB,IAAIH,CAAC,GAAGK,CAAC,CAACG,IAAI,CAACL,CAAC,CAAC;IAAET,CAAC;IAAEe,EAAE,GAAG,EAAE;IAAEC,CAAC;EAChC,IAAI;IACA,OAAO,CAACN,CAAC,KAAK,KAAK,CAAC,IAAIA,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,CAACV,CAAC,GAAGM,CAAC,CAACW,IAAI,EAAE,EAAEC,IAAI,EAAEH,EAAE,CAACI,IAAI,CAACnB,CAAC,CAACoB,KAAK,CAAC;EAC9E,CAAC,CACD,OAAOC,KAAK,EAAE;IAAEL,CAAC,GAAG;MAAEK,KAAK,EAAEA;IAAM,CAAC;EAAE,CAAC,SAC/B;IACJ,IAAI;MACA,IAAIrB,CAAC,IAAI,CAACA,CAAC,CAACkB,IAAI,KAAKP,CAAC,GAAGL,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAEK,CAAC,CAACG,IAAI,CAACR,CAAC,CAAC;IACpD,CAAC,SACO;MAAE,IAAIU,CAAC,EAAE,MAAMA,CAAC,CAACK,KAAK;IAAE;EACpC;EACA,OAAON,EAAE;AACb,CAAC;AACD,IAAIO,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,YAAY;EAClD,KAAK,IAAIP,EAAE,GAAG,EAAE,EAAET,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,SAAS,CAACC,MAAM,EAAEO,CAAC,EAAE,EAAES,EAAE,GAAGA,EAAE,CAACQ,MAAM,CAACf,MAAM,CAACV,SAAS,CAACQ,CAAC,CAAC,CAAC,CAAC;EACxF,OAAOS,EAAE;AACb,CAAC;AACD,IAAIS,QAAQ,GAAI,IAAI,IAAI,IAAI,CAACA,QAAQ,IAAK,UAASf,CAAC,EAAE;EAClD,IAAIgB,CAAC,GAAG,OAAOb,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,QAAQ;IAAEF,CAAC,GAAGc,CAAC,IAAIhB,CAAC,CAACgB,CAAC,CAAC;IAAEnB,CAAC,GAAG,CAAC;EAC7E,IAAIK,CAAC,EAAE,OAAOA,CAAC,CAACG,IAAI,CAACL,CAAC,CAAC;EACvB,IAAIA,CAAC,IAAI,OAAOA,CAAC,CAACV,MAAM,KAAK,QAAQ,EAAE,OAAO;IAC1CkB,IAAI,EAAE,YAAY;MACd,IAAIR,CAAC,IAAIH,CAAC,IAAIG,CAAC,CAACV,MAAM,EAAEU,CAAC,GAAG,KAAK,CAAC;MAClC,OAAO;QAAEW,KAAK,EAAEX,CAAC,IAAIA,CAAC,CAACH,CAAC,EAAE,CAAC;QAAEY,IAAI,EAAE,CAACT;MAAE,CAAC;IAC3C;EACJ,CAAC;EACD,MAAM,IAAIiB,SAAS,CAACD,CAAC,GAAG,yBAAyB,GAAG,iCAAiC,CAAC;AAC1F,CAAC;AACD,SAASE,KAAK,QAAQ,gBAAgB;AACtC,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAASC,OAAO,QAAQ,qBAAqB;AAC7C,SAASC,SAAS,QAAQ,eAAe;AACzC,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,UAAU,QAAQ,eAAe;AAC1C,SAASC,UAAU,QAAQ,sBAAsB;AACjD,SAASC,OAAO,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,WAAW,EAAEC,cAAc,EAAEC,eAAe,EAAEC,YAAY,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,MAAM,EAAEC,QAAQ,QAAS,oBAAoB;AACjL,SAASC,MAAM,QAAQ,UAAU;AACjC,OAAO,IAAIC,iBAAiB;AAC5B,CAAC,UAAUA,iBAAiB,EAAE;EAC1BA,iBAAiB,CAACA,iBAAiB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EACjEA,iBAAiB,CAACA,iBAAiB,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;AACzE,CAAC,EAAEA,iBAAiB,KAAKA,iBAAiB,GAAG,CAAC,CAAC,CAAC,CAAC;AACjD,OAAO,IAAIC,cAAc;AACzB,CAAC,UAAUA,cAAc,EAAE;EACvBA,cAAc,CAAC,KAAK,CAAC,GAAG,KAAK;EAC7BA,cAAc,CAAC,OAAO,CAAC,GAAG,OAAO;EACjCA,cAAc,CAAC,QAAQ,CAAC,GAAG,QAAQ;EACnCA,cAAc,CAAC,MAAM,CAAC,GAAG,MAAM;AACnC,CAAC,EAAEA,cAAc,KAAKA,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;AAC3C,IAAIC,WAAW,GAAG,aAAe,YAAY;EACzC,SAASA,WAAW,GAAG;IACnB,IAAI,CAACC,SAAS,GAAGC,SAAS;IAC1B,IAAI,CAACC,KAAK,GAAG,OAAO;IACpB,IAAI,CAACC,SAAS,GAAGF,SAAS;IAC1B,IAAI,CAACG,UAAU,GAAGH,SAAS;IAC3B,IAAI,CAACI,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,UAAU,GAAG,qBAAqB;IACvC,IAAI,CAACC,SAAS,GAAGN,SAAS;EAC9B;EACAF,WAAW,CAACS,SAAS,CAAC7B,OAAO,GAAG,YAAY;IACxC,OAAOA,OAAO,CAAC,IAAI,CAAC0B,QAAQ,EAAE,IAAI,CAACC,UAAU,EAAE,IAAI,CAACH,SAAS,EAAE,IAAI,CAACC,UAAU,CAAC;EACnF,CAAC;EACD/D,UAAU,CAAC,CACPsD,QAAQ,CAACJ,UAAU,CAAC,CAAC,CAAC,CAAC,CAC1B,EAAEQ,WAAW,CAACS,SAAS,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;EAC9CnE,UAAU,CAAC,CACPsD,QAAQ,CAACF,YAAY,CAAC,CACzB,EAAEM,WAAW,CAACS,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;EAC1CnE,UAAU,CAAC,CACPsD,QAAQ,CAACP,cAAc,CAAC,CAC3B,EAAEW,WAAW,CAACS,SAAS,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;EAC9CnE,UAAU,CAAC,CACPsD,QAAQ,CAACN,eAAe,CAAC,CAC5B,EAAEU,WAAW,CAACS,SAAS,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;EAC/CnE,UAAU,CAAC,CACPsD,QAAQ,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC,CACtB,EAAEa,WAAW,CAACS,SAAS,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;EAC7CnE,UAAU,CAAC,CACPsD,QAAQ,CAACD,MAAM,CAAC,CACnB,EAAEK,WAAW,CAACS,SAAS,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;EAC/CnE,UAAU,CAAC,CACPsD,QAAQ,CAACL,YAAY,CAAC,CACzB,EAAES,WAAW,CAACS,SAAS,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;EAC9C,OAAOT,WAAW;AACtB,CAAC,EAAG;AACJ,SAASA,WAAW;AACpB,IAAIU,YAAY,GAAG,aAAe,YAAY;EAC1C,SAASA,YAAY,GAAG;IACpB,IAAI,CAACC,IAAI,GAAG,EAAE;IACd;AACR;AACA;AACA;IACQ,IAAI,CAACC,MAAM,GAAGV,SAAS;IACvB;AACR;AACA;IACQ,IAAI,CAACW,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,WAAW,GAAG,CAAC;EACxB;EACA/D,MAAM,CAACM,cAAc,CAACqD,YAAY,CAACD,SAAS,EAAE,OAAO,EAAE;IACnDM,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAACH,MAAM;IACtB,CAAC;IACDI,GAAG,EAAE,UAAU9C,KAAK,EAAE;MAClB,IAAI+C,EAAE;MACN,IAAI,CAACL,MAAM,GAAG1C,KAAK;MACnB,CAAC+C,EAAE,GAAG,IAAI,CAACC,MAAM,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,mBAAmB,EAAE;IACpF,CAAC;IACDC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF/E,UAAU,CAAC,CACPsD,QAAQ,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC,CACtB,EAAEuB,YAAY,CAACD,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;EAC1CnE,UAAU,CAAC,CACPsD,QAAQ,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC,CACtB,EAAEuB,YAAY,CAACD,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;EAC7CnE,UAAU,CAAC,CACPsD,QAAQ,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC,CACtB,EAAEuB,YAAY,CAACD,SAAS,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;EACjD,OAAOC,YAAY;AACvB,CAAC,EAAG;AACJ,SAASA,YAAY;AACrB,IAAIY,UAAU,GAAG,aAAe,YAAY;EACxC,SAASA,UAAU,GAAG;IAClB,IAAI,CAACC,MAAM,GAAG,IAAIb,YAAY,EAAE;IAChC,IAAI,CAACc,KAAK,GAAG,IAAIxB,WAAW,EAAE;IAC9B;IACA,IAAI,CAACyB,QAAQ,GAAGvB,SAAS;IACzB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACwB,QAAQ,GAAG,EAAE;IAClB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,CAAC;EACrB;EACArF,UAAU,CAAC,CACPsD,QAAQ,CAACJ,UAAU,CAAC,CAAC,CAAC,CAAC,CAC1B,EAAE8B,UAAU,CAACb,SAAS,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;EAC5CnE,UAAU,CAAC,CACPsD,QAAQ,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC,CACtB,EAAEmC,UAAU,CAACb,SAAS,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;EAC5CnE,UAAU,CAAC,CACPsD,QAAQ,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC,CACtB,EAAEmC,UAAU,CAACb,SAAS,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;EAC5C,OAAOa,UAAU;AACrB,CAAC,EAAG;AACJ,SAASA,UAAU;AACnB,IAAIM,cAAc,GAAG,YAAY;EAC7B;AAAA,CACH;AACD,IAAIC,eAAe,GAAG,aAAe,YAAY;EAC7C,SAASA,eAAe,GAAG;IACvB,IAAI,CAACC,eAAe,GAAGF,cAAc;EACzC;EACAtF,UAAU,CAAC,CACPsD,QAAQ,CAACV,QAAQ,CAAC,CACrB,EAAE2C,eAAe,CAACpB,SAAS,EAAE,iBAAiB,EAAE,KAAK,CAAC,CAAC;EACxD,OAAOoB,eAAe;AAC1B,CAAC,EAAG;AACJ,SAASA,eAAe;AACxB,IAAIE,MAAM,GAAG,aAAe,YAAY;EACpC,SAASA,MAAM,GAAG;IACd,IAAI,CAACC,EAAE,GAAGlD,QAAQ,CAAC,IAAI,CAAC;IACxB,IAAI,CAACmD,KAAK,GAAG,IAAIxD,KAAK,CAAC;MAAEyD,IAAI,EAAE,QAAQ;MAAEC,KAAK,EAAE,IAAI;MAAEC,MAAM,EAAEvC,MAAM,CAACwC;IAAc,CAAC,CAAC;IACrF,IAAI,CAACC,aAAa,GAAG5D,SAAS,CAAC6D,MAAM,CAAC,IAAI,CAACN,KAAK,CAAC,CAACO,SAAS,EAAE;IAC7D,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IACrB,IAAI,CAACC,IAAI,GAAG,IAAIpB,UAAU,EAAE;IAC5B,IAAI,CAACqB,SAAS,GAAG,IAAId,eAAe,EAAE;IACtC,IAAI,CAACe,cAAc,GAAG,IAAIC,GAAG,EAAE;IAC/B,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,WAAW,GAAGlD,iBAAiB,CAACmD,QAAQ;IAC7C,IAAI,CAACC,SAAS,GAAGnD,cAAc,CAACoD,KAAK;IACrC;IACA,IAAI,CAACC,YAAY,GAAGlD,SAAS;IAC7B;AACR;AACA;IACQ,IAAI,CAACmD,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,eAAe,GAAG,IAAIC,GAAG,EAAE;IAChC,IAAI,CAAC5C,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;IAClB,IAAI,CAAC+B,IAAI,CAACnB,MAAM,CAACL,MAAM,GAAG,IAAI;EAClC;EACAnE,MAAM,CAACM,cAAc,CAAC0E,MAAM,CAACtB,SAAS,EAAE,MAAM,EAAE;IAC5CM,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAAC+B,KAAK;IACrB,CAAC;IACD9B,GAAG,EAAE,UAAU9C,KAAK,EAAE;MAClB,IAAI,CAAC4E,KAAK,GAAG5E,KAAK;MAClB,IAAI,CAAC+D,KAAK,CAACuB,OAAO,GAAGtF,KAAK,CAACrB,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC4G,OAAO;IACzD,CAAC;IACDrC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFtE,MAAM,CAACM,cAAc,CAAC0E,MAAM,CAACtB,SAAS,EAAE,SAAS,EAAE;IAC/CM,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAACgC,QAAQ;IACxB,CAAC;IACD/B,GAAG,EAAE,UAAU9C,KAAK,EAAE;MAClB,IAAI,CAAC6E,QAAQ,GAAG7E,KAAK;MACrB,IAAI,CAAC+D,KAAK,CAACuB,OAAO,GAAGtF,KAAK,IAAI,IAAI,CAACwF,IAAI,CAAC7G,MAAM,GAAG,CAAC;IACtD,CAAC;IACDuE,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFtE,MAAM,CAACM,cAAc,CAAC0E,MAAM,CAACtB,SAAS,EAAE,UAAU,EAAE;IAChDM,GAAG,EAAE,YAAY;MACb,OAAO,IAAI,CAACmC,SAAS;IACzB,CAAC;IACDlC,GAAG,EAAE,UAAU9C,KAAK,EAAE;MAClB,IAAI,CAACgF,SAAS,GAAGhF,KAAK;MACtB,QAAQA,KAAK;QACT,KAAK,OAAO;QACZ,KAAK,MAAM;UACP,IAAI,CAAC8E,WAAW,GAAGlD,iBAAiB,CAACmD,QAAQ;UAC7C;QACJ,KAAK,QAAQ;QACb,KAAK,KAAK;UACN,IAAI,CAACD,WAAW,GAAGlD,iBAAiB,CAAC6D,UAAU;UAC/C;MAAM;IAElB,CAAC;IACDvC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFU,MAAM,CAACtB,SAAS,CAACU,mBAAmB,GAAG,YAAY;IAC/C,IAAI,CAACmB,aAAa,GAAG,IAAI,CAACA,aAAa,CAACsB,OAAO,CAAC,EAAE,CAAC;IACnD,IAAI,CAACtB,aAAa,CAACuB,IAAI,CAACC,MAAM,EAAE;IAChC,IAAI,CAAC7B,KAAK,CAAC8B,SAAS,CAAC,IAAI,CAAC9B,KAAK,EAAElD,UAAU,CAACiF,KAAK,CAAC;EACtD,CAAC;EACDjC,MAAM,CAACtB,SAAS,CAACwD,kBAAkB,GAAG,UAAUC,IAAI,EAAE;IAClD,IAAIZ,eAAe,GAAG,IAAI,CAACA,eAAe;IAC1C,IAAIA,eAAe,CAACa,GAAG,CAACD,IAAI,CAAC,EAAE;MAC3B,OAAOZ,eAAe,CAACvC,GAAG,CAACmD,IAAI,CAAC;IACpC;IACA,IAAIE,EAAE,GAAG;MACL,KAAK,EAAEpF,UAAU,CAACqF,WAAW,CAAC,KAAK,EAAEH,IAAI,CAAC,CAACI;IAC/C,CAAC;IACDhB,eAAe,CAACtC,GAAG,CAACkD,IAAI,EAAEE,EAAE,CAAC;IAC7B,OAAOA,EAAE;EACb,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIrC,MAAM,CAACtB,SAAS,CAAC8D,aAAa,GAAG,UAAUD,KAAK,EAAEE,MAAM,EAAE;IACtD,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIxD,EAAE,GAAG,IAAI,CAACyB,IAAI;MAAEhB,QAAQ,GAAGT,EAAE,CAACS,QAAQ;MAAEC,QAAQ,GAAGV,EAAE,CAACU,QAAQ;MAAEH,KAAK,GAAGP,EAAE,CAACO,KAAK;MAAEC,QAAQ,GAAGR,EAAE,CAACQ,QAAQ;MAAEiD,EAAE,GAAGzD,EAAE,CAACM,MAAM;MAAEoD,UAAU,GAAGD,EAAE,CAAC/D,IAAI;MAAEiE,aAAa,GAAGF,EAAE,CAAC7D,OAAO;MAAEgE,WAAW,GAAGH,EAAE,CAACI,KAAK;MAAEC,EAAE,GAAG9D,EAAE,CAACO,KAAK;MAAEwD,EAAE,GAAGD,EAAE,CAAC9E,SAAS;MAAEA,SAAS,GAAG+E,EAAE,KAAK,KAAK,CAAC,GAAGC,QAAQ,GAAGD,EAAE;MAAE5E,SAAS,GAAG2E,EAAE,CAAC3E,SAAS;MAAEC,UAAU,GAAG0E,EAAE,CAAC1E,UAAU;MAAEC,QAAQ,GAAGyE,EAAE,CAACzE,QAAQ;MAAEC,UAAU,GAAGwE,EAAE,CAACxE,UAAU;IAC7X,IAAImD,IAAI,GAAGtF,QAAQ,CAAC,IAAI,CAACsF,IAAI,CAAC;IAC9B,IAAI,IAAI,CAACN,YAAY,EAAE;MACnBM,IAAI,CAACwB,OAAO,EAAE;IAClB;IACA,IAAIC,eAAe,GAAG,IAAI,CAAC7C,aAAa,CAACsB,OAAO,CAACF,IAAI,EAAE,UAAU0B,CAAC,EAAEC,KAAK,EAAE;MACvE,IAAIC,MAAM,GAAGzG,SAAS,CAACgG,WAAW,IAAIQ,KAAK,CAAC9D,MAAM,CAACuD,KAAK,CAAC;MACzD,OAAOO,KAAK,CAACrD,EAAE,GAAG,GAAG,GAAGqD,KAAK,CAACE,MAAM,GAAG,GAAG,GAAGD,MAAM,CAACpD,IAAI;IAC5D,CAAC,CAAC;IACFiD,eAAe,CAACtB,IAAI,CAACC,MAAM,EAAE;IAC7B,IAAI0B,cAAc,GAAGL,eAAe,CAACM,KAAK,CAACC,MAAM,CAAC/G,WAAW,CAAC,CAACgH,IAAI,CAAC,UAAUC,IAAI,EAAEP,KAAK,EAAE;MACvF,IAAIC,MAAM,GAAGzG,SAAS,CAACgG,WAAW,IAAIQ,KAAK,CAAC9D,MAAM,CAACuD,KAAK,CAAC;MACzDc,IAAI,CAACrE,MAAM,GAAG,IAAI+D,MAAM,EAAE;IAC9B,CAAC,CAAC;IACF,IAAIhD,aAAa,GAAI,IAAI,CAACA,aAAa,GAAG6C,eAAe,CAACU,KAAK,CAACL,cAAc,CAAE;IAChF,IAAIM,SAAS,GAAGxD,aAAa,CAAC3B,IAAI;IAClC;IACA,IAAIoF,MAAM,GAAG,EAAE;IACf,IAAI7B,IAAI,GAAG1C,KAAK,CAAC5C,OAAO,EAAE;IAC1B,IAAIoH,QAAQ,GAAG,KAAK;IACpB,IAAIC,sBAAsB,GAAG,GAAG;IAChC,IAAIC,YAAY,GAAIzE,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAGA,QAAQ,GAAG6C,KAAK,GAAG2B,sBAAuB;IACzG3D,aAAa,CAACqD,IAAI,CAAC,UAAUQ,WAAW,EAAEd,KAAK,EAAE;MAC7C,IAAIe,GAAG,EAAEnF,EAAE;MACX,IAAIyD,EAAE;MACN,IAAI2B,IAAI,IAAI3B,EAAE,GAAGW,KAAK,CAAC7D,KAAK,CAAC6E,IAAI,EAAG3B,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,WAAY,CAAC;MACrFyB,WAAW,CAACxB,UAAU,GAAGA,UAAU;MACnCwB,WAAW,CAAC9C,OAAO,GAAGuB,aAAa;MACnCuB,WAAW,CAAC/F,SAAS,GAAGA,SAAS;MACjC+F,WAAW,CAAC9F,UAAU,GAAGA,UAAU;MACnC8F,WAAW,CAAC7F,QAAQ,GAAGA,QAAQ;MAC/B6F,WAAW,CAAC5F,UAAU,GAAGA,UAAU;MACnC,IAAI+F,SAAS,GAAGD,IAAI,CAACE,KAAK,CAAC,EAAE,CAAC;MAC9B,IAAIC,WAAW,GAAG,KAAK;MACvB,IAAIH,IAAI,CAACxJ,MAAM,GAAGoD,SAAS,EAAE;QACzBoG,IAAI,GAAG,EAAE,GAAGA,IAAI,CAACI,SAAS,CAAC,CAAC,EAAExG,SAAS,CAAC;QACxCuG,WAAW,GAAG,IAAI;MACtB;MACA,IAAIE,UAAU,GAAG/B,UAAU,GAAGC,aAAa,GAAG5F,UAAU,CAACqF,WAAW,CAACgC,IAAI,EAAEnC,IAAI,CAAC,CAACI,KAAK;MACtF,IAAIoC,UAAU,GAAGR,YAAY,EAAE;QAC3B,IAAIS,aAAa,GAAG,EAAE;QACtB,IAAIrD,eAAe,GAAGmB,KAAK,CAACR,kBAAkB,CAACC,IAAI,CAAC;QACpD,IAAI0C,WAAW,GAAGtD,eAAe,CAAC0C,QAAQ,CAAC;QAC3C,IAAI;UACA,KAAK,IAAIa,WAAW,GAAGvI,QAAQ,CAACgI,SAAS,CAAC,EAAEQ,aAAa,GAAGD,WAAW,CAAC9I,IAAI,EAAE,EAAE,CAAC+I,aAAa,CAAC9I,IAAI,EAAE8I,aAAa,GAAGD,WAAW,CAAC9I,IAAI,EAAE,EAAE;YACrI,IAAIgJ,IAAI,GAAGD,aAAa,CAAC5I,KAAK;YAC9B,IAAI,CAACoF,eAAe,CAACyD,IAAI,CAAC,EAAE;cACxBzD,eAAe,CAACyD,IAAI,CAAC,GAAG/H,UAAU,CAACqF,WAAW,CAAC0C,IAAI,EAAE7C,IAAI,CAAC,CAACI,KAAK;YACpE;YACAsC,WAAW,IAAItD,eAAe,CAACyD,IAAI,CAAC;YACpC,IAAIH,WAAW,GAAGV,YAAY,EAAE;cAC5B;YACJ;YACAS,aAAa,IAAII,IAAI;UACzB;QACJ,CAAC,CACD,OAAOC,KAAK,EAAE;UAAEZ,GAAG,GAAG;YAAEjI,KAAK,EAAE6I;UAAM,CAAC;QAAE,CAAC,SACjC;UACJ,IAAI;YACA,IAAIF,aAAa,IAAI,CAACA,aAAa,CAAC9I,IAAI,KAAKiD,EAAE,GAAG4F,WAAW,CAACI,MAAM,CAAC,EAAEhG,EAAE,CAACrD,IAAI,CAACiJ,WAAW,CAAC;UAC/F,CAAC,SACO;YAAE,IAAIT,GAAG,EAAE,MAAMA,GAAG,CAACjI,KAAK;UAAE;QACxC;QACAkI,IAAI,GAAGM,aAAa;QACpBH,WAAW,GAAG,IAAI;MACtB;MACA,IAAIxE,EAAE,GAAGqD,KAAK,CAACE,MAAM,IAAIF,KAAK,CAACrD,EAAE;MACjC,IAAIwE,WAAW,EAAE;QACbH,IAAI,IAAIL,QAAQ;QAChBvB,KAAK,CAAC7B,cAAc,CAACsE,GAAG,CAAClF,EAAE,CAAC;MAChC,CAAC,MACI;QACDyC,KAAK,CAAC7B,cAAc,CAACuE,MAAM,CAACnF,EAAE,CAAC;MACnC;MACAmE,WAAW,CAACE,IAAI,GAAGA,IAAI;MACvBN,MAAM,CAAC9H,IAAI,CAACkI,WAAW,CAACiB,WAAW,EAAE,CAAC;IAC1C,CAAC,CAAC;IACF,IAAIC,UAAU,GAAGtB,MAAM,CAAClJ,MAAM,IAAIkJ,MAAM,CAAC,CAAC,CAAC,CAACvB,MAAM;IAClD,IAAI8C,QAAQ,GAAG,CAAC;IAChB,IAAIC,WAAW,GAAG,CAAC;IACnB,IAAIC,gBAAgB,GAAG,CAAC;IACxB,IAAIC,iBAAiB,GAAG,CAAC;IACzBnD,KAAK,GAAGoD,IAAI,CAACC,GAAG,CAAC,CAAC,EAAErD,KAAK,CAAC;IAC1BE,MAAM,GAAGkD,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEnD,MAAM,CAAC;IAC5B,QAAQ,IAAI,CAACxB,WAAW;MACpB,KAAKlD,iBAAiB,CAAC6D,UAAU;QAC7B,IAAI,EAAEiE,QAAQ,CAACtD,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,CAAC,EAAE;UACjC,OAAO,KAAK;QAChB;QACAgD,QAAQ,GAAG,CAAC;QACZ,IAAIO,WAAW,GAAG,CAAC;QACnB;QACA,GAAG;UACC,IAAIC,UAAU,GAAG,CAAC;UAClBD,WAAW,GAAG,CAAC;UACfN,WAAW,GAAG,CAAC;UACfD,QAAQ,EAAE;UACV,IAAIlK,CAAC,GAAG,CAAC;UACT,OAAOA,CAAC,GAAG0I,SAAS,EAAE;YAClB,IAAIiC,IAAI,GAAGhC,MAAM,CAAC3I,CAAC,CAAC;YACpB,IAAI2K,IAAI,CAACzD,KAAK,GAAGiD,WAAW,EAAE;cAC1BA,WAAW,GAAGQ,IAAI,CAACzD,KAAK;YAC5B;YACAlH,CAAC,EAAE;YACH,IAAIA,CAAC,GAAGkK,QAAQ,KAAK,CAAC,EAAE;cACpBQ,UAAU,IAAIP,WAAW;cACzBA,WAAW,GAAG,CAAC;cACfM,WAAW,EAAE;YACjB;UACJ;UACA,IAAIzK,CAAC,GAAGkK,QAAQ,KAAK,CAAC,EAAE;YACpBQ,UAAU,IAAIP,WAAW;YACzBM,WAAW,EAAE;UACjB;UACAL,gBAAgB,GAAGM,UAAU,GAAG,CAACD,WAAW,GAAG,CAAC,IAAInG,QAAQ;QAChE,CAAC,QAAQ8F,gBAAgB,GAAGlD,KAAK,IAAIuD,WAAW,GAAG,CAAC;QACpDJ,iBAAiB,GAAGJ,UAAU,GAAGC,QAAQ,GAAG,CAACA,QAAQ,GAAG,CAAC,IAAI3F,QAAQ;QACrE;MACJ,KAAK7B,iBAAiB,CAACmD,QAAQ;QAC3B,IAAI,EAAE2E,QAAQ,CAACpD,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,CAAC,EAAE;UACnC,OAAO,KAAK;QAChB;QACA8C,QAAQ,GAAGxB,SAAS,GAAG,CAAC;QACxB;QACA,GAAG;UACCwB,QAAQ,GAAG,CAACA,QAAQ,IAAI,CAAC,IAAKA,QAAQ,GAAG,CAAE;UAC3CC,WAAW,GAAG,CAAC;UACf,IAAIO,UAAU,GAAG,CAAC;UAClB,IAAIE,WAAW,GAAG,CAAC;UACnB,IAAIC,aAAa,GAAG,CAAC;UACrB,IAAI7K,CAAC,GAAG,CAAC;UACT,OAAOA,CAAC,GAAG0I,SAAS,EAAE;YAClB,IAAIiC,IAAI,GAAGhC,MAAM,CAAC3I,CAAC,CAAC;YACpB,IAAI,CAAC6K,aAAa,EAAE;cAChBD,WAAW,IAAID,IAAI,CAACvD,MAAM;YAC9B;YACA,IAAIuD,IAAI,CAACzD,KAAK,GAAGiD,WAAW,EAAE;cAC1BA,WAAW,GAAGQ,IAAI,CAACzD,KAAK;YAC5B;YACAlH,CAAC,EAAE;YACH,IAAIA,CAAC,GAAGkK,QAAQ,KAAK,CAAC,EAAE;cACpBQ,UAAU,IAAIP,WAAW;cACzBA,WAAW,GAAG,CAAC;cACfU,aAAa,EAAE;YACnB;UACJ;UACA,IAAI7K,CAAC,GAAGkK,QAAQ,KAAK,CAAC,EAAE;YACpBQ,UAAU,IAAIP,WAAW;YACzBU,aAAa,EAAE;UACnB;UACAT,gBAAgB,GAAGM,UAAU,GAAG,CAACG,aAAa,GAAG,CAAC,IAAIvG,QAAQ;UAC9D+F,iBAAiB,GAAGO,WAAW,GAAG,CAACV,QAAQ,GAAG,CAAC,IAAI3F,QAAQ;QAC/D,CAAC,QAAQ8F,iBAAiB,GAAGjD,MAAM,IAAI8C,QAAQ,GAAG,CAAC;QACnD;IAAM;IAEd;IACA,IAAIY,MAAM,GAAG,CAAC5D,KAAK,GAAGkD,gBAAgB,IAAI,CAAC;IAC3C,IAAIW,MAAM,GAAG,CAAC3D,MAAM,GAAGiD,iBAAiB,IAAI,CAAC;IAC7C,IAAIW,CAAC,GAAG,CAAC;IACT,IAAIC,CAAC,GAAG,CAAC;IACTd,WAAW,GAAG,CAAC;IACf;IACAjF,aAAa,CAACqD,IAAI,CAAC,UAAUQ,WAAW,EAAEf,CAAC,EAAEhI,CAAC,EAAE;MAC5C;MACA+I,WAAW,CAACmC,YAAY,GAAGZ,IAAI,CAACa,KAAK,CAACL,MAAM,GAAGE,CAAC,CAAC;MACjDjC,WAAW,CAACqC,YAAY,GAAGd,IAAI,CAACa,KAAK,CAACJ,MAAM,GAAGE,CAAC,CAAC;MACjD,IAAIN,IAAI,GAAGhC,MAAM,CAAC3I,CAAC,CAAC;MACpB,IAAI2K,IAAI,CAACzD,KAAK,GAAGiD,WAAW,EAAE;QAC1BA,WAAW,GAAGQ,IAAI,CAACzD,KAAK;MAC5B;MACA,IAAI,CAAClH,CAAC,GAAG,CAAC,IAAIkK,QAAQ,KAAK,CAAC,EAAE;QAC1Bc,CAAC,IAAIb,WAAW,GAAG7F,QAAQ;QAC3B2G,CAAC,GAAG,CAAC;QACLd,WAAW,GAAG,CAAC;MACnB,CAAC,MACI;QACDc,CAAC,IAAIN,IAAI,CAACvD,MAAM,GAAG7C,QAAQ;MAC/B;IACJ,CAAC,CAAC;IACF;IACA,IAAI,CAAC8G,MAAM,EAAE;IACb,IAAI9H,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI8B,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B9B,IAAI,CAAC,CAAC,CAAC,GAAG6G,gBAAgB;IAC1B7G,IAAI,CAAC,CAAC,CAAC,GAAG8G,iBAAiB;IAC3B,IAAI9G,IAAI,CAAC,CAAC,CAAC,KAAK8B,OAAO,CAAC,CAAC,CAAC,IAAI9B,IAAI,CAAC,CAAC,CAAC,KAAK8B,OAAO,CAAC,CAAC,CAAC,EAAE;MAClDA,OAAO,CAAC,CAAC,CAAC,GAAG9B,IAAI,CAAC,CAAC,CAAC;MACpB8B,OAAO,CAAC,CAAC,CAAC,GAAG9B,IAAI,CAAC,CAAC,CAAC;IACxB;EACJ,CAAC;EACDoB,MAAM,CAACtB,SAAS,CAACgI,MAAM,GAAG,YAAY;IAClC,IAAIxH,EAAE,GAAG,IAAI,CAACyB,IAAI;MAAE5B,WAAW,GAAGG,EAAE,CAACM,MAAM,CAACT,WAAW;MAAEX,KAAK,GAAGc,EAAE,CAACO,KAAK,CAACrB,KAAK;IAC/E,IAAI,CAACmC,aAAa,CAACqD,IAAI,CAAC,UAAUQ,WAAW,EAAEd,KAAK,EAAE;MAClD,IAAI9D,MAAM,GAAG8D,KAAK,CAAC9D,MAAM;MACzB4E,WAAW,CAACuC,UAAU,GAAGnH,MAAM,CAACoH,IAAI;MACpCxC,WAAW,CAACyC,YAAY,GAAGrH,MAAM,CAACsH,MAAM;MACxC1C,WAAW,CAAC2C,iBAAiB,GAAGhI,WAAW;MAC3CqF,WAAW,CAAC4C,iBAAiB,GAAGxH,MAAM,CAACyH,WAAW;MAClD7C,WAAW,CAAC8C,mBAAmB,GAAG1H,MAAM,CAAC2H,aAAa;MACtD/C,WAAW,CAACgD,OAAO,GAAG9D,KAAK,CAAC5B,OAAO,GAAG,CAAC,GAAG,GAAG;MAC7C0C,WAAW,CAAChG,KAAK,GAAGA,KAAK;IAC7B,CAAC,CAAC;EACN,CAAC;EACD4B,MAAM,CAACtB,SAAS,CAAC2I,gBAAgB,GAAG,UAAUhB,CAAC,EAAEC,CAAC,EAAE;IAChD,IAAIzC,IAAI,GAAG,IAAI,CAAC3D,KAAK,CAACoH,QAAQ,CAACjB,CAAC,EAAEC,CAAC,CAAC;IACpC,IAAIzC,IAAI,IAAIA,IAAI,CAAC1E,MAAM,EAAE;MACrB,OAAO0E,IAAI,CAAC1E,MAAM,CAACmE,KAAK;IAC5B;EACJ,CAAC;EACDtD,MAAM,CAACuH,SAAS,GAAG,QAAQ;EAC3BhN,UAAU,CAAC,CACPsD,QAAQ,CAACX,OAAO,CAAC,CACpB,EAAE8C,MAAM,CAACtB,SAAS,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;EACxCnE,UAAU,CAAC,CACPsD,QAAQ,CAACH,QAAQ,CAAC,CACrB,EAAEsC,MAAM,CAACtB,SAAS,EAAE,WAAW,EAAE,KAAK,CAAC,CAAC;EACzCnE,UAAU,CAAC,CACPsD,QAAQ,CAACR,WAAW,CAAC,CACxB,EAAE2C,MAAM,CAACtB,SAAS,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;EAC5CnE,UAAU,CAAC,CACPsD,QAAQ,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC,CACtB,EAAE4C,MAAM,CAACtB,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;EACvC,OAAOsB,MAAM;AACjB,CAAC,EAAG;AACJ,SAASA,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}