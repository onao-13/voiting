{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.typed-array.find-last.js\");\nrequire(\"core-js/modules/es.typed-array.find-last-index.js\");\nexports.__esModule = true;\nvar vec2 = require(\"./vector\");\nvar BoundingRect_1 = require(\"./BoundingRect\");\nvar config_1 = require(\"../config\");\nvar bbox_1 = require(\"./bbox\");\nvar curve_1 = require(\"./curve\");\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  R: 7\n};\nvar tmpOutX = [];\nvar tmpOutY = [];\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar PI = Math.PI;\nvar PI2 = PI * 2;\nvar hasTypedArray = typeof Float32Array !== 'undefined';\nvar tmpAngles = [];\nfunction modPI2(radian) {\n  var n = Math.round(radian / PI * 1e8) / 1e8;\n  return n % 2 * PI;\n}\nfunction normalizeArcAngles(angles, anticlockwise) {\n  var newStartAngle = modPI2(angles[0]);\n  if (newStartAngle < 0) {\n    newStartAngle += PI2;\n  }\n  var delta = newStartAngle - angles[0];\n  var newEndAngle = angles[1];\n  newEndAngle += delta;\n  if (!anticlockwise && newEndAngle - newStartAngle >= PI2) {\n    newEndAngle = newStartAngle + PI2;\n  } else if (anticlockwise && newStartAngle - newEndAngle >= PI2) {\n    newEndAngle = newStartAngle - PI2;\n  } else if (!anticlockwise && newStartAngle > newEndAngle) {\n    newEndAngle = newStartAngle + (PI2 - modPI2(newStartAngle - newEndAngle));\n  } else if (anticlockwise && newStartAngle < newEndAngle) {\n    newEndAngle = newStartAngle - (PI2 - modPI2(newEndAngle - newStartAngle));\n  }\n  angles[0] = newStartAngle;\n  angles[1] = newEndAngle;\n}\nexports.normalizeArcAngles = normalizeArcAngles;\nvar PathProxy = function () {\n  function PathProxy(notSaveData) {\n    this.dpr = 1;\n    this._version = 0;\n    this._xi = 0;\n    this._yi = 0;\n    this._x0 = 0;\n    this._y0 = 0;\n    this._len = 0;\n    if (notSaveData) {\n      this._saveData = false;\n    }\n    if (this._saveData) {\n      this.data = [];\n    }\n  }\n  PathProxy.prototype.increaseVersion = function () {\n    this._version++;\n  };\n  PathProxy.prototype.getVersion = function () {\n    return this._version;\n  };\n  PathProxy.prototype.setScale = function (sx, sy, segmentIgnoreThreshold) {\n    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;\n    if (segmentIgnoreThreshold > 0) {\n      this._ux = mathAbs(segmentIgnoreThreshold / config_1.devicePixelRatio / sx) || 0;\n      this._uy = mathAbs(segmentIgnoreThreshold / config_1.devicePixelRatio / sy) || 0;\n    }\n  };\n  PathProxy.prototype.setDPR = function (dpr) {\n    this.dpr = dpr;\n  };\n  PathProxy.prototype.setContext = function (ctx) {\n    this._ctx = ctx;\n  };\n  PathProxy.prototype.getContext = function () {\n    return this._ctx;\n  };\n  PathProxy.prototype.beginPath = function () {\n    this._ctx && this._ctx.beginPath();\n    this.reset();\n    return this;\n  };\n  PathProxy.prototype.reset = function () {\n    if (this._saveData) {\n      this._len = 0;\n    }\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n    if (this._pathSegLen) {\n      this._pathSegLen = null;\n      this._pathLen = 0;\n    }\n    this._version++;\n  };\n  PathProxy.prototype.moveTo = function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y);\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  };\n  PathProxy.prototype.lineTo = function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;\n    this.addData(CMD.L, x, y);\n    if (this._ctx && exceedUnit) {\n      this._needsDash ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n    return this;\n  };\n  PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n    if (this._ctx) {\n      this._needsDash ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  };\n  PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n    if (this._ctx) {\n      this._needsDash ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  };\n  PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    tmpAngles[0] = startAngle;\n    tmpAngles[1] = endAngle;\n    normalizeArcAngles(tmpAngles, anticlockwise);\n    startAngle = tmpAngles[0];\n    endAngle = tmpAngles[1];\n    var delta = endAngle - startAngle;\n    this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cy;\n    return this;\n  };\n  PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n    return this;\n  };\n  PathProxy.prototype.rect = function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  };\n  PathProxy.prototype.closePath = function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n    if (ctx) {\n      this._needsDash && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  };\n  PathProxy.prototype.fill = function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  };\n  PathProxy.prototype.stroke = function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  };\n  PathProxy.prototype.setLineDash = function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n      this._dashSum = lineDashSum;\n      this._needsDash = true;\n    } else {\n      this._lineDash = null;\n      this._needsDash = false;\n    }\n    return this;\n  };\n  PathProxy.prototype.setLineDashOffset = function (offset) {\n    this._dashOffset = offset;\n    return this;\n  };\n  PathProxy.prototype.len = function () {\n    return this._len;\n  };\n  PathProxy.prototype.setData = function (data) {\n    var len = data.length;\n    if (!(this.data && this.data.length === len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n    this._len = len;\n  };\n  PathProxy.prototype.appendPath = function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n    this._len = offset;\n  };\n  PathProxy.prototype.addData = function (cmd, a, b, c, d, e, f, g, h) {\n    if (!this._saveData) {\n      return;\n    }\n    var data = this.data;\n    if (this._len + arguments.length > data.length) {\n      this._expandData();\n      data = this.data;\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n  };\n  PathProxy.prototype._expandData = function () {\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n      this.data = newData;\n    }\n  };\n  PathProxy.prototype._dashedLineTo = function (x1, y1) {\n    var dashSum = this._dashSum;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var offset = this._dashOffset;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var nDash = lineDash.length;\n    var dash;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n    if (offset < 0) {\n      offset = dashSum + offset;\n    }\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash;\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    }\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  };\n  PathProxy.prototype._dashedBezierTo = function (x1, y1, x2, y2, x3, y3) {\n    var ctx = this._ctx;\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var t;\n    var dx;\n    var dy;\n    var x;\n    var y;\n    var tmpLen = 0;\n    if (offset < 0) {\n      offset = dashSum + offset;\n    }\n    offset %= dashSum;\n    for (t = 0; t < 1; t += 0.1) {\n      dx = curve_1.cubicAt(x0, x1, x2, x3, t + 0.1) - curve_1.cubicAt(x0, x1, x2, x3, t);\n      dy = curve_1.cubicAt(y0, y1, y2, y3, t + 0.1) - curve_1.cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    }\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n    t = (tmpLen - offset) / bezierLen;\n    while (t <= 1) {\n      x = curve_1.cubicAt(x0, x1, x2, x3, t);\n      y = curve_1.cubicAt(y0, y1, y2, y3, t);\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    }\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  };\n  PathProxy.prototype._dashedQuadraticTo = function (x1, y1, x2, y2) {\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  };\n  PathProxy.prototype.toStatic = function () {\n    if (!this._saveData) {\n      return;\n    }\n    var data = this.data;\n    if (data instanceof Array) {\n      data.length = this._len;\n      if (hasTypedArray && this._len > 11) {\n        this.data = new Float32Array(data);\n      }\n    }\n  };\n  PathProxy.prototype.getBoundingRect = function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    var i;\n    for (i = 0; i < this._len;) {\n      var cmd = data[i++];\n      var isFirst = i === 1;\n      if (isFirst) {\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n      switch (cmd) {\n        case CMD.M:\n          xi = x0 = data[i++];\n          yi = y0 = data[i++];\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n        case CMD.L:\n          bbox_1.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n        case CMD.C:\n          bbox_1.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n        case CMD.Q:\n          bbox_1.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n        case CMD.A:\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle;\n          i += 1;\n          var anticlockwise = !data[i++];\n          if (isFirst) {\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n          bbox_1.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++];\n          bbox_1.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      }\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    }\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n    return new BoundingRect_1[\"default\"](min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  };\n  PathProxy.prototype._calculateLength = function () {\n    var data = this.data;\n    var len = this._len;\n    var ux = this._ux;\n    var uy = this._uy;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    if (!this._pathSegLen) {\n      this._pathSegLen = [];\n    }\n    var pathSegLen = this._pathSegLen;\n    var pathTotalLen = 0;\n    var segCount = 0;\n    for (var i = 0; i < len;) {\n      var cmd = data[i++];\n      var isFirst = i === 1;\n      if (isFirst) {\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n      var l = -1;\n      switch (cmd) {\n        case CMD.M:\n          xi = x0 = data[i++];\n          yi = y0 = data[i++];\n          break;\n        case CMD.L:\n          {\n            var x2 = data[i++];\n            var y2 = data[i++];\n            var dx = x2 - xi;\n            var dy = y2 - yi;\n            if (mathAbs(dx) > ux || mathAbs(dy) > uy || i === len - 1) {\n              l = Math.sqrt(dx * dx + dy * dy);\n              xi = x2;\n              yi = y2;\n            }\n            break;\n          }\n        case CMD.C:\n          {\n            var x1 = data[i++];\n            var y1 = data[i++];\n            var x2 = data[i++];\n            var y2 = data[i++];\n            var x3 = data[i++];\n            var y3 = data[i++];\n            l = curve_1.cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);\n            xi = x3;\n            yi = y3;\n            break;\n          }\n        case CMD.Q:\n          {\n            var x1 = data[i++];\n            var y1 = data[i++];\n            var x2 = data[i++];\n            var y2 = data[i++];\n            l = curve_1.quadraticLength(xi, yi, x1, y1, x2, y2, 10);\n            xi = x2;\n            yi = y2;\n            break;\n          }\n        case CMD.A:\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var delta = data[i++];\n          var endAngle = delta + startAngle;\n          i += 1;\n          var anticlockwise = !data[i++];\n          if (isFirst) {\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n          l = mathMax(rx, ry) * mathMin(PI2, Math.abs(delta));\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n        case CMD.R:\n          {\n            x0 = xi = data[i++];\n            y0 = yi = data[i++];\n            var width = data[i++];\n            var height = data[i++];\n            l = width * 2 + height * 2;\n            break;\n          }\n        case CMD.Z:\n          {\n            var dx = x0 - xi;\n            var dy = y0 - yi;\n            l = Math.sqrt(dx * dx + dy * dy);\n            xi = x0;\n            yi = y0;\n            break;\n          }\n      }\n      if (l >= 0) {\n        pathSegLen[segCount++] = l;\n        pathTotalLen += l;\n      }\n    }\n    this._pathLen = pathTotalLen;\n    return pathTotalLen;\n  };\n  PathProxy.prototype.rebuildPath = function (ctx, percent) {\n    var d = this.data;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n    var x0;\n    var y0;\n    var xi;\n    var yi;\n    var x;\n    var y;\n    var drawPart = percent < 1;\n    var pathSegLen;\n    var pathTotalLen;\n    var accumLength = 0;\n    var segCount = 0;\n    var displayedLength;\n    if (drawPart) {\n      if (!this._pathSegLen) {\n        this._calculateLength();\n      }\n      pathSegLen = this._pathSegLen;\n      pathTotalLen = this._pathLen;\n      displayedLength = percent * pathTotalLen;\n      if (!displayedLength) {\n        return;\n      }\n    }\n    lo: for (var i = 0; i < len;) {\n      var cmd = d[i++];\n      var isFirst = i === 1;\n      if (isFirst) {\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n        case CMD.L:\n          {\n            x = d[i++];\n            y = d[i++];\n            if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n              if (drawPart) {\n                var l = pathSegLen[segCount++];\n                if (accumLength + l > displayedLength) {\n                  var t = (displayedLength - accumLength) / l;\n                  ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);\n                  break lo;\n                }\n                accumLength += l;\n              }\n              ctx.lineTo(x, y);\n              xi = x;\n              yi = y;\n            }\n            break;\n          }\n        case CMD.C:\n          {\n            var x1 = d[i++];\n            var y1 = d[i++];\n            var x2 = d[i++];\n            var y2 = d[i++];\n            var x3 = d[i++];\n            var y3 = d[i++];\n            if (drawPart) {\n              var l = pathSegLen[segCount++];\n              if (accumLength + l > displayedLength) {\n                var t = (displayedLength - accumLength) / l;\n                curve_1.cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);\n                curve_1.cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);\n                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);\n                break lo;\n              }\n              accumLength += l;\n            }\n            ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            xi = x3;\n            yi = y3;\n            break;\n          }\n        case CMD.Q:\n          {\n            var x1 = d[i++];\n            var y1 = d[i++];\n            var x2 = d[i++];\n            var y2 = d[i++];\n            if (drawPart) {\n              var l = pathSegLen[segCount++];\n              if (accumLength + l > displayedLength) {\n                var t = (displayedLength - accumLength) / l;\n                curve_1.quadraticSubdivide(xi, x1, x2, t, tmpOutX);\n                curve_1.quadraticSubdivide(yi, y1, y2, t, tmpOutY);\n                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);\n                break lo;\n              }\n              accumLength += l;\n            }\n            ctx.quadraticCurveTo(x1, y1, x2, y2);\n            xi = x2;\n            yi = y2;\n            break;\n          }\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var startAngle = d[i++];\n          var delta = d[i++];\n          var psi = d[i++];\n          var anticlockwise = !d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = mathAbs(rx - ry) > 1e-3;\n          var endAngle = startAngle + delta;\n          var breakBuild = false;\n          if (drawPart) {\n            var l = pathSegLen[segCount++];\n            if (accumLength + l > displayedLength) {\n              endAngle = startAngle + delta * (displayedLength - accumLength) / l;\n              breakBuild = true;\n            }\n            accumLength += l;\n          }\n          if (isEllipse && ctx.ellipse) {\n            ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);\n          } else {\n            ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n          }\n          if (breakBuild) {\n            break lo;\n          }\n          if (isFirst) {\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          x = d[i++];\n          y = d[i++];\n          var width = d[i++];\n          var height = d[i++];\n          if (drawPart) {\n            var l = pathSegLen[segCount++];\n            if (accumLength + l > displayedLength) {\n              var d_1 = displayedLength - accumLength;\n              ctx.moveTo(x, y);\n              ctx.lineTo(x + mathMin(d_1, width), y);\n              d_1 -= width;\n              if (d_1 > 0) {\n                ctx.lineTo(x + width, y + mathMin(d_1, height));\n              }\n              d_1 -= height;\n              if (d_1 > 0) {\n                ctx.lineTo(x + mathMax(width - d_1, 0), y + height);\n              }\n              d_1 -= width;\n              if (d_1 > 0) {\n                ctx.lineTo(x, y + mathMax(height - d_1, 0));\n              }\n              break lo;\n            }\n            accumLength += l;\n          }\n          ctx.rect(x, y, width, height);\n          break;\n        case CMD.Z:\n          if (drawPart) {\n            var l = pathSegLen[segCount++];\n            if (accumLength + l > displayedLength) {\n              var t = (displayedLength - accumLength) / l;\n              ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);\n              break lo;\n            }\n            accumLength += l;\n          }\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  };\n  PathProxy.CMD = CMD;\n  PathProxy.initDefaultProps = function () {\n    var proto = PathProxy.prototype;\n    proto._saveData = true;\n    proto._needsDash = false;\n    proto._dashOffset = 0;\n    proto._dashIdx = 0;\n    proto._dashSum = 0;\n    proto._ux = 0;\n    proto._uy = 0;\n  }();\n  return PathProxy;\n}();\nexports[\"default\"] = PathProxy;","map":{"version":3,"names":["exports","__esModule","vec2","require","BoundingRect_1","config_1","bbox_1","curve_1","CMD","M","L","C","Q","A","Z","R","tmpOutX","tmpOutY","min","max","min2","max2","mathMin","Math","mathMax","mathCos","cos","mathSin","sin","mathSqrt","sqrt","mathAbs","abs","PI","PI2","hasTypedArray","Float32Array","tmpAngles","modPI2","radian","n","round","normalizeArcAngles","angles","anticlockwise","newStartAngle","delta","newEndAngle","PathProxy","notSaveData","dpr","_version","_xi","_yi","_x0","_y0","_len","_saveData","data","prototype","increaseVersion","getVersion","setScale","sx","sy","segmentIgnoreThreshold","_ux","devicePixelRatio","_uy","setDPR","setContext","ctx","_ctx","getContext","beginPath","reset","_lineDash","_dashOffset","_pathSegLen","_pathLen","moveTo","x","y","addData","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x1","y1","x2","y2","x3","y3","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","cx","cy","r","startAngle","endAngle","arcTo","radius","rect","w","h","closePath","x0","y0","fill","toStatic","stroke","setLineDash","lineDash","Array","_dashIdx","lineDashSum","i","length","_dashSum","setLineDashOffset","offset","len","setData","appendPath","path","appendSize","appendPathData","k","cmd","a","b","c","d","e","f","g","arguments","_expandData","newData","dashSum","dx","dy","dist","nDash","dash","idx","bezierLen","t","tmpLen","cubicAt","getBoundingRect","Number","MAX_VALUE","xi","yi","isFirst","fromLine","fromCubic","fromQuadratic","rx","ry","fromArc","width","height","_calculateLength","ux","uy","pathSegLen","pathTotalLen","segCount","l","cubicLength","quadraticLength","rebuildPath","percent","drawPart","accumLength","displayedLength","lo","cubicSubdivide","quadraticSubdivide","psi","scaleX","scaleY","isEllipse","breakBuild","ellipse","d_1","initDefaultProps","proto"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/zrender/lib/core/PathProxy.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar vec2 = require(\"./vector\");\nvar BoundingRect_1 = require(\"./BoundingRect\");\nvar config_1 = require(\"../config\");\nvar bbox_1 = require(\"./bbox\");\nvar curve_1 = require(\"./curve\");\nvar CMD = {\n    M: 1,\n    L: 2,\n    C: 3,\n    Q: 4,\n    A: 5,\n    Z: 6,\n    R: 7\n};\nvar tmpOutX = [];\nvar tmpOutY = [];\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar PI = Math.PI;\nvar PI2 = PI * 2;\nvar hasTypedArray = typeof Float32Array !== 'undefined';\nvar tmpAngles = [];\nfunction modPI2(radian) {\n    var n = Math.round(radian / PI * 1e8) / 1e8;\n    return (n % 2) * PI;\n}\nfunction normalizeArcAngles(angles, anticlockwise) {\n    var newStartAngle = modPI2(angles[0]);\n    if (newStartAngle < 0) {\n        newStartAngle += PI2;\n    }\n    var delta = newStartAngle - angles[0];\n    var newEndAngle = angles[1];\n    newEndAngle += delta;\n    if (!anticlockwise && newEndAngle - newStartAngle >= PI2) {\n        newEndAngle = newStartAngle + PI2;\n    }\n    else if (anticlockwise && newStartAngle - newEndAngle >= PI2) {\n        newEndAngle = newStartAngle - PI2;\n    }\n    else if (!anticlockwise && newStartAngle > newEndAngle) {\n        newEndAngle = newStartAngle +\n            (PI2 - modPI2(newStartAngle - newEndAngle));\n    }\n    else if (anticlockwise && newStartAngle < newEndAngle) {\n        newEndAngle = newStartAngle -\n            (PI2 - modPI2(newEndAngle - newStartAngle));\n    }\n    angles[0] = newStartAngle;\n    angles[1] = newEndAngle;\n}\nexports.normalizeArcAngles = normalizeArcAngles;\nvar PathProxy = (function () {\n    function PathProxy(notSaveData) {\n        this.dpr = 1;\n        this._version = 0;\n        this._xi = 0;\n        this._yi = 0;\n        this._x0 = 0;\n        this._y0 = 0;\n        this._len = 0;\n        if (notSaveData) {\n            this._saveData = false;\n        }\n        if (this._saveData) {\n            this.data = [];\n        }\n    }\n    PathProxy.prototype.increaseVersion = function () {\n        this._version++;\n    };\n    PathProxy.prototype.getVersion = function () {\n        return this._version;\n    };\n    PathProxy.prototype.setScale = function (sx, sy, segmentIgnoreThreshold) {\n        segmentIgnoreThreshold = segmentIgnoreThreshold || 0;\n        if (segmentIgnoreThreshold > 0) {\n            this._ux = mathAbs(segmentIgnoreThreshold / config_1.devicePixelRatio / sx) || 0;\n            this._uy = mathAbs(segmentIgnoreThreshold / config_1.devicePixelRatio / sy) || 0;\n        }\n    };\n    PathProxy.prototype.setDPR = function (dpr) {\n        this.dpr = dpr;\n    };\n    PathProxy.prototype.setContext = function (ctx) {\n        this._ctx = ctx;\n    };\n    PathProxy.prototype.getContext = function () {\n        return this._ctx;\n    };\n    PathProxy.prototype.beginPath = function () {\n        this._ctx && this._ctx.beginPath();\n        this.reset();\n        return this;\n    };\n    PathProxy.prototype.reset = function () {\n        if (this._saveData) {\n            this._len = 0;\n        }\n        if (this._lineDash) {\n            this._lineDash = null;\n            this._dashOffset = 0;\n        }\n        if (this._pathSegLen) {\n            this._pathSegLen = null;\n            this._pathLen = 0;\n        }\n        this._version++;\n    };\n    PathProxy.prototype.moveTo = function (x, y) {\n        this.addData(CMD.M, x, y);\n        this._ctx && this._ctx.moveTo(x, y);\n        this._x0 = x;\n        this._y0 = y;\n        this._xi = x;\n        this._yi = y;\n        return this;\n    };\n    PathProxy.prototype.lineTo = function (x, y) {\n        var exceedUnit = mathAbs(x - this._xi) > this._ux\n            || mathAbs(y - this._yi) > this._uy\n            || this._len < 5;\n        this.addData(CMD.L, x, y);\n        if (this._ctx && exceedUnit) {\n            this._needsDash ? this._dashedLineTo(x, y)\n                : this._ctx.lineTo(x, y);\n        }\n        if (exceedUnit) {\n            this._xi = x;\n            this._yi = y;\n        }\n        return this;\n    };\n    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {\n        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n        if (this._ctx) {\n            this._needsDash ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n        }\n        this._xi = x3;\n        this._yi = y3;\n        return this;\n    };\n    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {\n        this.addData(CMD.Q, x1, y1, x2, y2);\n        if (this._ctx) {\n            this._needsDash ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n        }\n        this._xi = x2;\n        this._yi = y2;\n        return this;\n    };\n    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n        tmpAngles[0] = startAngle;\n        tmpAngles[1] = endAngle;\n        normalizeArcAngles(tmpAngles, anticlockwise);\n        startAngle = tmpAngles[0];\n        endAngle = tmpAngles[1];\n        var delta = endAngle - startAngle;\n        this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);\n        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n        this._xi = mathCos(endAngle) * r + cx;\n        this._yi = mathSin(endAngle) * r + cy;\n        return this;\n    };\n    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n        if (this._ctx) {\n            this._ctx.arcTo(x1, y1, x2, y2, radius);\n        }\n        return this;\n    };\n    PathProxy.prototype.rect = function (x, y, w, h) {\n        this._ctx && this._ctx.rect(x, y, w, h);\n        this.addData(CMD.R, x, y, w, h);\n        return this;\n    };\n    PathProxy.prototype.closePath = function () {\n        this.addData(CMD.Z);\n        var ctx = this._ctx;\n        var x0 = this._x0;\n        var y0 = this._y0;\n        if (ctx) {\n            this._needsDash && this._dashedLineTo(x0, y0);\n            ctx.closePath();\n        }\n        this._xi = x0;\n        this._yi = y0;\n        return this;\n    };\n    PathProxy.prototype.fill = function (ctx) {\n        ctx && ctx.fill();\n        this.toStatic();\n    };\n    PathProxy.prototype.stroke = function (ctx) {\n        ctx && ctx.stroke();\n        this.toStatic();\n    };\n    PathProxy.prototype.setLineDash = function (lineDash) {\n        if (lineDash instanceof Array) {\n            this._lineDash = lineDash;\n            this._dashIdx = 0;\n            var lineDashSum = 0;\n            for (var i = 0; i < lineDash.length; i++) {\n                lineDashSum += lineDash[i];\n            }\n            this._dashSum = lineDashSum;\n            this._needsDash = true;\n        }\n        else {\n            this._lineDash = null;\n            this._needsDash = false;\n        }\n        return this;\n    };\n    PathProxy.prototype.setLineDashOffset = function (offset) {\n        this._dashOffset = offset;\n        return this;\n    };\n    PathProxy.prototype.len = function () {\n        return this._len;\n    };\n    PathProxy.prototype.setData = function (data) {\n        var len = data.length;\n        if (!(this.data && this.data.length === len) && hasTypedArray) {\n            this.data = new Float32Array(len);\n        }\n        for (var i = 0; i < len; i++) {\n            this.data[i] = data[i];\n        }\n        this._len = len;\n    };\n    PathProxy.prototype.appendPath = function (path) {\n        if (!(path instanceof Array)) {\n            path = [path];\n        }\n        var len = path.length;\n        var appendSize = 0;\n        var offset = this._len;\n        for (var i = 0; i < len; i++) {\n            appendSize += path[i].len();\n        }\n        if (hasTypedArray && (this.data instanceof Float32Array)) {\n            this.data = new Float32Array(offset + appendSize);\n        }\n        for (var i = 0; i < len; i++) {\n            var appendPathData = path[i].data;\n            for (var k = 0; k < appendPathData.length; k++) {\n                this.data[offset++] = appendPathData[k];\n            }\n        }\n        this._len = offset;\n    };\n    PathProxy.prototype.addData = function (cmd, a, b, c, d, e, f, g, h) {\n        if (!this._saveData) {\n            return;\n        }\n        var data = this.data;\n        if (this._len + arguments.length > data.length) {\n            this._expandData();\n            data = this.data;\n        }\n        for (var i = 0; i < arguments.length; i++) {\n            data[this._len++] = arguments[i];\n        }\n    };\n    PathProxy.prototype._expandData = function () {\n        if (!(this.data instanceof Array)) {\n            var newData = [];\n            for (var i = 0; i < this._len; i++) {\n                newData[i] = this.data[i];\n            }\n            this.data = newData;\n        }\n    };\n    PathProxy.prototype._dashedLineTo = function (x1, y1) {\n        var dashSum = this._dashSum;\n        var lineDash = this._lineDash;\n        var ctx = this._ctx;\n        var offset = this._dashOffset;\n        var x0 = this._xi;\n        var y0 = this._yi;\n        var dx = x1 - x0;\n        var dy = y1 - y0;\n        var dist = mathSqrt(dx * dx + dy * dy);\n        var x = x0;\n        var y = y0;\n        var nDash = lineDash.length;\n        var dash;\n        var idx;\n        dx /= dist;\n        dy /= dist;\n        if (offset < 0) {\n            offset = dashSum + offset;\n        }\n        offset %= dashSum;\n        x -= offset * dx;\n        y -= offset * dy;\n        while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx === 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n            idx = this._dashIdx;\n            dash = lineDash[idx];\n            x += dx * dash;\n            y += dy * dash;\n            this._dashIdx = (idx + 1) % nDash;\n            if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                continue;\n            }\n            ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n        }\n        dx = x - x1;\n        dy = y - y1;\n        this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n    };\n    PathProxy.prototype._dashedBezierTo = function (x1, y1, x2, y2, x3, y3) {\n        var ctx = this._ctx;\n        var dashSum = this._dashSum;\n        var offset = this._dashOffset;\n        var lineDash = this._lineDash;\n        var x0 = this._xi;\n        var y0 = this._yi;\n        var bezierLen = 0;\n        var idx = this._dashIdx;\n        var nDash = lineDash.length;\n        var t;\n        var dx;\n        var dy;\n        var x;\n        var y;\n        var tmpLen = 0;\n        if (offset < 0) {\n            offset = dashSum + offset;\n        }\n        offset %= dashSum;\n        for (t = 0; t < 1; t += 0.1) {\n            dx = curve_1.cubicAt(x0, x1, x2, x3, t + 0.1)\n                - curve_1.cubicAt(x0, x1, x2, x3, t);\n            dy = curve_1.cubicAt(y0, y1, y2, y3, t + 0.1)\n                - curve_1.cubicAt(y0, y1, y2, y3, t);\n            bezierLen += mathSqrt(dx * dx + dy * dy);\n        }\n        for (; idx < nDash; idx++) {\n            tmpLen += lineDash[idx];\n            if (tmpLen > offset) {\n                break;\n            }\n        }\n        t = (tmpLen - offset) / bezierLen;\n        while (t <= 1) {\n            x = curve_1.cubicAt(x0, x1, x2, x3, t);\n            y = curve_1.cubicAt(y0, y1, y2, y3, t);\n            idx % 2 ? ctx.moveTo(x, y)\n                : ctx.lineTo(x, y);\n            t += lineDash[idx] / bezierLen;\n            idx = (idx + 1) % nDash;\n        }\n        (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n        dx = x3 - x;\n        dy = y3 - y;\n        this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n    };\n    PathProxy.prototype._dashedQuadraticTo = function (x1, y1, x2, y2) {\n        var x3 = x2;\n        var y3 = y2;\n        x2 = (x2 + 2 * x1) / 3;\n        y2 = (y2 + 2 * y1) / 3;\n        x1 = (this._xi + 2 * x1) / 3;\n        y1 = (this._yi + 2 * y1) / 3;\n        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n    };\n    PathProxy.prototype.toStatic = function () {\n        if (!this._saveData) {\n            return;\n        }\n        var data = this.data;\n        if (data instanceof Array) {\n            data.length = this._len;\n            if (hasTypedArray && this._len > 11) {\n                this.data = new Float32Array(data);\n            }\n        }\n    };\n    PathProxy.prototype.getBoundingRect = function () {\n        min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n        max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n        var data = this.data;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        var i;\n        for (i = 0; i < this._len;) {\n            var cmd = data[i++];\n            var isFirst = i === 1;\n            if (isFirst) {\n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n                case CMD.M:\n                    xi = x0 = data[i++];\n                    yi = y0 = data[i++];\n                    min2[0] = x0;\n                    min2[1] = y0;\n                    max2[0] = x0;\n                    max2[1] = y0;\n                    break;\n                case CMD.L:\n                    bbox_1.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    bbox_1.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    bbox_1.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var endAngle = data[i++] + startAngle;\n                    i += 1;\n                    var anticlockwise = !data[i++];\n                    if (isFirst) {\n                        x0 = mathCos(startAngle) * rx + cx;\n                        y0 = mathSin(startAngle) * ry + cy;\n                    }\n                    bbox_1.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    bbox_1.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                    break;\n                case CMD.Z:\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n            vec2.min(min, min, min2);\n            vec2.max(max, max, max2);\n        }\n        if (i === 0) {\n            min[0] = min[1] = max[0] = max[1] = 0;\n        }\n        return new BoundingRect_1[\"default\"](min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    };\n    PathProxy.prototype._calculateLength = function () {\n        var data = this.data;\n        var len = this._len;\n        var ux = this._ux;\n        var uy = this._uy;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        if (!this._pathSegLen) {\n            this._pathSegLen = [];\n        }\n        var pathSegLen = this._pathSegLen;\n        var pathTotalLen = 0;\n        var segCount = 0;\n        for (var i = 0; i < len;) {\n            var cmd = data[i++];\n            var isFirst = i === 1;\n            if (isFirst) {\n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            var l = -1;\n            switch (cmd) {\n                case CMD.M:\n                    xi = x0 = data[i++];\n                    yi = y0 = data[i++];\n                    break;\n                case CMD.L: {\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var dx = x2 - xi;\n                    var dy = y2 - yi;\n                    if (mathAbs(dx) > ux || mathAbs(dy) > uy || i === len - 1) {\n                        l = Math.sqrt(dx * dx + dy * dy);\n                        xi = x2;\n                        yi = y2;\n                    }\n                    break;\n                }\n                case CMD.C: {\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3 = data[i++];\n                    var y3 = data[i++];\n                    l = curve_1.cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);\n                    xi = x3;\n                    yi = y3;\n                    break;\n                }\n                case CMD.Q: {\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    l = curve_1.quadraticLength(xi, yi, x1, y1, x2, y2, 10);\n                    xi = x2;\n                    yi = y2;\n                    break;\n                }\n                case CMD.A:\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var delta = data[i++];\n                    var endAngle = delta + startAngle;\n                    i += 1;\n                    var anticlockwise = !data[i++];\n                    if (isFirst) {\n                        x0 = mathCos(startAngle) * rx + cx;\n                        y0 = mathSin(startAngle) * ry + cy;\n                    }\n                    l = mathMax(rx, ry) * mathMin(PI2, Math.abs(delta));\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R: {\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    l = width * 2 + height * 2;\n                    break;\n                }\n                case CMD.Z: {\n                    var dx = x0 - xi;\n                    var dy = y0 - yi;\n                    l = Math.sqrt(dx * dx + dy * dy);\n                    xi = x0;\n                    yi = y0;\n                    break;\n                }\n            }\n            if (l >= 0) {\n                pathSegLen[segCount++] = l;\n                pathTotalLen += l;\n            }\n        }\n        this._pathLen = pathTotalLen;\n        return pathTotalLen;\n    };\n    PathProxy.prototype.rebuildPath = function (ctx, percent) {\n        var d = this.data;\n        var ux = this._ux;\n        var uy = this._uy;\n        var len = this._len;\n        var x0;\n        var y0;\n        var xi;\n        var yi;\n        var x;\n        var y;\n        var drawPart = percent < 1;\n        var pathSegLen;\n        var pathTotalLen;\n        var accumLength = 0;\n        var segCount = 0;\n        var displayedLength;\n        if (drawPart) {\n            if (!this._pathSegLen) {\n                this._calculateLength();\n            }\n            pathSegLen = this._pathSegLen;\n            pathTotalLen = this._pathLen;\n            displayedLength = percent * pathTotalLen;\n            if (!displayedLength) {\n                return;\n            }\n        }\n        lo: for (var i = 0; i < len;) {\n            var cmd = d[i++];\n            var isFirst = i === 1;\n            if (isFirst) {\n                xi = d[i];\n                yi = d[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n                case CMD.M:\n                    x0 = xi = d[i++];\n                    y0 = yi = d[i++];\n                    ctx.moveTo(xi, yi);\n                    break;\n                case CMD.L: {\n                    x = d[i++];\n                    y = d[i++];\n                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                        if (drawPart) {\n                            var l = pathSegLen[segCount++];\n                            if (accumLength + l > displayedLength) {\n                                var t = (displayedLength - accumLength) / l;\n                                ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);\n                                break lo;\n                            }\n                            accumLength += l;\n                        }\n                        ctx.lineTo(x, y);\n                        xi = x;\n                        yi = y;\n                    }\n                    break;\n                }\n                case CMD.C: {\n                    var x1 = d[i++];\n                    var y1 = d[i++];\n                    var x2 = d[i++];\n                    var y2 = d[i++];\n                    var x3 = d[i++];\n                    var y3 = d[i++];\n                    if (drawPart) {\n                        var l = pathSegLen[segCount++];\n                        if (accumLength + l > displayedLength) {\n                            var t = (displayedLength - accumLength) / l;\n                            curve_1.cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);\n                            curve_1.cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);\n                            ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);\n                            break lo;\n                        }\n                        accumLength += l;\n                    }\n                    ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                    xi = x3;\n                    yi = y3;\n                    break;\n                }\n                case CMD.Q: {\n                    var x1 = d[i++];\n                    var y1 = d[i++];\n                    var x2 = d[i++];\n                    var y2 = d[i++];\n                    if (drawPart) {\n                        var l = pathSegLen[segCount++];\n                        if (accumLength + l > displayedLength) {\n                            var t = (displayedLength - accumLength) / l;\n                            curve_1.quadraticSubdivide(xi, x1, x2, t, tmpOutX);\n                            curve_1.quadraticSubdivide(yi, y1, y2, t, tmpOutY);\n                            ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);\n                            break lo;\n                        }\n                        accumLength += l;\n                    }\n                    ctx.quadraticCurveTo(x1, y1, x2, y2);\n                    xi = x2;\n                    yi = y2;\n                    break;\n                }\n                case CMD.A:\n                    var cx = d[i++];\n                    var cy = d[i++];\n                    var rx = d[i++];\n                    var ry = d[i++];\n                    var startAngle = d[i++];\n                    var delta = d[i++];\n                    var psi = d[i++];\n                    var anticlockwise = !d[i++];\n                    var r = (rx > ry) ? rx : ry;\n                    var scaleX = (rx > ry) ? 1 : rx / ry;\n                    var scaleY = (rx > ry) ? ry / rx : 1;\n                    var isEllipse = mathAbs(rx - ry) > 1e-3;\n                    var endAngle = startAngle + delta;\n                    var breakBuild = false;\n                    if (drawPart) {\n                        var l = pathSegLen[segCount++];\n                        if (accumLength + l > displayedLength) {\n                            endAngle = startAngle + delta * (displayedLength - accumLength) / l;\n                            breakBuild = true;\n                        }\n                        accumLength += l;\n                    }\n                    if (isEllipse && ctx.ellipse) {\n                        ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);\n                    }\n                    else {\n                        ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n                    }\n                    if (breakBuild) {\n                        break lo;\n                    }\n                    if (isFirst) {\n                        x0 = mathCos(startAngle) * rx + cx;\n                        y0 = mathSin(startAngle) * ry + cy;\n                    }\n                    xi = mathCos(endAngle) * rx + cx;\n                    yi = mathSin(endAngle) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = d[i];\n                    y0 = yi = d[i + 1];\n                    x = d[i++];\n                    y = d[i++];\n                    var width = d[i++];\n                    var height = d[i++];\n                    if (drawPart) {\n                        var l = pathSegLen[segCount++];\n                        if (accumLength + l > displayedLength) {\n                            var d_1 = displayedLength - accumLength;\n                            ctx.moveTo(x, y);\n                            ctx.lineTo(x + mathMin(d_1, width), y);\n                            d_1 -= width;\n                            if (d_1 > 0) {\n                                ctx.lineTo(x + width, y + mathMin(d_1, height));\n                            }\n                            d_1 -= height;\n                            if (d_1 > 0) {\n                                ctx.lineTo(x + mathMax(width - d_1, 0), y + height);\n                            }\n                            d_1 -= width;\n                            if (d_1 > 0) {\n                                ctx.lineTo(x, y + mathMax(height - d_1, 0));\n                            }\n                            break lo;\n                        }\n                        accumLength += l;\n                    }\n                    ctx.rect(x, y, width, height);\n                    break;\n                case CMD.Z:\n                    if (drawPart) {\n                        var l = pathSegLen[segCount++];\n                        if (accumLength + l > displayedLength) {\n                            var t = (displayedLength - accumLength) / l;\n                            ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);\n                            break lo;\n                        }\n                        accumLength += l;\n                    }\n                    ctx.closePath();\n                    xi = x0;\n                    yi = y0;\n            }\n        }\n    };\n    PathProxy.CMD = CMD;\n    PathProxy.initDefaultProps = (function () {\n        var proto = PathProxy.prototype;\n        proto._saveData = true;\n        proto._needsDash = false;\n        proto._dashOffset = 0;\n        proto._dashIdx = 0;\n        proto._dashSum = 0;\n        proto._ux = 0;\n        proto._uy = 0;\n    })();\n    return PathProxy;\n}());\nexports[\"default\"] = PathProxy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}