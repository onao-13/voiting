{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nfunction circleRectOverlap(c, x, y, w, h) {\n  // Find closest horizontal and vertical edges.\n  var edgeX = c.x < x ? x : c.x > x + w ? x + w : c.x;\n  var edgeY = c.y < y ? y : c.y > y + h ? y + h : c.y;\n  // Find distance to closest edges.\n  var dx = c.x - edgeX;\n  var dy = c.y - edgeY;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  var xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  var yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nexport function isPointLabelDatum(x) {\n  return x != null && typeof x.point === 'object' && typeof x.label === 'object';\n}\n/**\n * @param data Points and labels for one or more series. The order of series determines label placement precedence.\n * @param bounds Bounds to fit the labels into. If a label can't be fully contained, it doesn't fit.\n * @returns Placed labels for the given series (in the given order).\n */\nexport function placeLabels(data, bounds, padding) {\n  if (padding === void 0) {\n    padding = 5;\n  }\n  var result = [];\n  data = data.map(function (d) {\n    return d.slice().sort(function (a, b) {\n      return b.point.size - a.point.size;\n    });\n  });\n  for (var j = 0; j < data.length; j++) {\n    var labels = result[j] = [];\n    var datum = data[j];\n    if (!(datum && datum.length && datum[0].label)) {\n      continue;\n    }\n    var _loop_1 = function (i, ln) {\n      var d = datum[i];\n      var l = d.label;\n      var r = d.point.size * 0.5;\n      var x = d.point.x - l.width * 0.5;\n      var y = d.point.y - r - l.height - padding;\n      var width = l.width,\n        height = l.height;\n      var withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\n      if (!withinBounds) {\n        return \"continue\";\n      }\n      var overlapPoints = data.some(function (datum) {\n        return datum.some(function (d) {\n          return circleRectOverlap(d.point, x, y, width, height);\n        });\n      });\n      if (overlapPoints) {\n        return \"continue\";\n      }\n      var overlapLabels = result.some(function (labels) {\n        return labels.some(function (l) {\n          return rectRectOverlap(l, x, y, width, height);\n        });\n      });\n      if (overlapLabels) {\n        return \"continue\";\n      }\n      labels.push({\n        index: i,\n        text: l.text,\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        datum: d\n      });\n    };\n    for (var i = 0, ln = datum.length; i < ln; i++) {\n      _loop_1(i, ln);\n    }\n  }\n  return result;\n}\nexport function axisLabelsOverlap(data, padding) {\n  var result = [];\n  var _loop_2 = function (i) {\n    var datum = data[i];\n    var _a = datum.point,\n      x = _a.x,\n      y = _a.y,\n      _b = datum.label,\n      width = _b.width,\n      height = _b.height,\n      text = _b.text;\n    width += padding !== null && padding !== void 0 ? padding : 0;\n    height += padding !== null && padding !== void 0 ? padding : 0;\n    var overlapLabels = result.some(function (l) {\n      var overlap = rectRectOverlap(l, x, y, width, height);\n      return overlap;\n    });\n    if (overlapLabels) {\n      return {\n        value: true\n      };\n    }\n    result.push({\n      index: i,\n      text: text,\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      datum: datum\n    });\n  };\n  for (var i = 0; i < data.length; i++) {\n    var state_1 = _loop_2(i);\n    if (typeof state_1 === \"object\") return state_1.value;\n  }\n  return false;\n}","map":{"version":3,"names":["circleRectOverlap","c","x","y","w","h","edgeX","edgeY","dx","dy","d","Math","sqrt","size","rectRectOverlap","r1","x2","y2","w2","h2","xOverlap","width","yOverlap","height","rectContainsRect","r2x","r2y","r2w","r2h","isPointLabelDatum","point","label","placeLabels","data","bounds","padding","result","map","slice","sort","a","b","j","length","labels","datum","_loop_1","i","ln","l","r","withinBounds","overlapPoints","some","overlapLabels","push","index","text","axisLabelsOverlap","_loop_2","_a","_b","overlap","value","state_1"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/util/labelPlacement.js"],"sourcesContent":["function circleRectOverlap(c, x, y, w, h) {\n    // Find closest horizontal and vertical edges.\n    var edgeX = c.x < x ? x : c.x > x + w ? x + w : c.x;\n    var edgeY = c.y < y ? y : c.y > y + h ? y + h : c.y;\n    // Find distance to closest edges.\n    var dx = c.x - edgeX;\n    var dy = c.y - edgeY;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n    var xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n    var yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n    return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n    return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nexport function isPointLabelDatum(x) {\n    return x != null && typeof x.point === 'object' && typeof x.label === 'object';\n}\n/**\n * @param data Points and labels for one or more series. The order of series determines label placement precedence.\n * @param bounds Bounds to fit the labels into. If a label can't be fully contained, it doesn't fit.\n * @returns Placed labels for the given series (in the given order).\n */\nexport function placeLabels(data, bounds, padding) {\n    if (padding === void 0) { padding = 5; }\n    var result = [];\n    data = data.map(function (d) { return d.slice().sort(function (a, b) { return b.point.size - a.point.size; }); });\n    for (var j = 0; j < data.length; j++) {\n        var labels = (result[j] = []);\n        var datum = data[j];\n        if (!(datum && datum.length && datum[0].label)) {\n            continue;\n        }\n        var _loop_1 = function (i, ln) {\n            var d = datum[i];\n            var l = d.label;\n            var r = d.point.size * 0.5;\n            var x = d.point.x - l.width * 0.5;\n            var y = d.point.y - r - l.height - padding;\n            var width = l.width, height = l.height;\n            var withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\n            if (!withinBounds) {\n                return \"continue\";\n            }\n            var overlapPoints = data.some(function (datum) {\n                return datum.some(function (d) { return circleRectOverlap(d.point, x, y, width, height); });\n            });\n            if (overlapPoints) {\n                return \"continue\";\n            }\n            var overlapLabels = result.some(function (labels) { return labels.some(function (l) { return rectRectOverlap(l, x, y, width, height); }); });\n            if (overlapLabels) {\n                return \"continue\";\n            }\n            labels.push({\n                index: i,\n                text: l.text,\n                x: x,\n                y: y,\n                width: width,\n                height: height,\n                datum: d,\n            });\n        };\n        for (var i = 0, ln = datum.length; i < ln; i++) {\n            _loop_1(i, ln);\n        }\n    }\n    return result;\n}\nexport function axisLabelsOverlap(data, padding) {\n    var result = [];\n    var _loop_2 = function (i) {\n        var datum = data[i];\n        var _a = datum.point, x = _a.x, y = _a.y, _b = datum.label, width = _b.width, height = _b.height, text = _b.text;\n        width += (padding !== null && padding !== void 0 ? padding : 0);\n        height += (padding !== null && padding !== void 0 ? padding : 0);\n        var overlapLabels = result.some(function (l) {\n            var overlap = rectRectOverlap(l, x, y, width, height);\n            return overlap;\n        });\n        if (overlapLabels) {\n            return { value: true };\n        }\n        result.push({\n            index: i,\n            text: text,\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            datum: datum,\n        });\n    };\n    for (var i = 0; i < data.length; i++) {\n        var state_1 = _loop_2(i);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}