{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Node, RedrawType, SceneChangeDetection } from '../node';\nimport { chainObjects } from '../../util/object';\nvar Shape = /** @class */function (_super) {\n  __extends(Shape, _super);\n  function Shape() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.lastInstanceId = 0;\n    _this.fillOpacity = 1;\n    _this.strokeOpacity = 1;\n    _this.fill = Shape.defaultStyles.fill;\n    /**\n     * Note that `strokeStyle = null` means invisible stroke,\n     * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\n     * For example, a rect shape with an invisible stroke may not align to the pixel grid\n     * properly because the stroke affects the rules of alignment, and arc shapes forming\n     * a pie chart will have a gap between them if they have an invisible stroke, whereas\n     * there would be not gap if there was no stroke at all.\n     * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\n     * unless specific looks that is achieved by having an invisible stroke is desired.\n     */\n    _this.stroke = Shape.defaultStyles.stroke;\n    _this.strokeWidth = Shape.defaultStyles.strokeWidth;\n    _this.lineDash = Shape.defaultStyles.lineDash;\n    _this.lineDashOffset = Shape.defaultStyles.lineDashOffset;\n    _this.lineCap = Shape.defaultStyles.lineCap;\n    _this.lineJoin = Shape.defaultStyles.lineJoin;\n    _this.opacity = Shape.defaultStyles.opacity;\n    _this.fillShadow = Shape.defaultStyles.fillShadow;\n    return _this;\n  }\n  /**\n   * Creates a light-weight instance of the given shape (that serves as a template).\n   * The created instance only stores the properites set on the instance itself\n   * and the rest of the properties come via the prototype chain from the template.\n   * This can greatly reduce memory usage in cases where one has many simular shapes,\n   * for example, circles of different size, position and color. The exact memory usage\n   * reduction will depend on the size of the template and the number of own properties\n   * set on its lightweight instances, but will typically be around an order of magnitude\n   * or more.\n   *\n   * Note: template shapes are not supposed to be part of the scene graph (they should not\n   * have a parent).\n   *\n   * @param template\n   */\n  Shape.createInstance = function (template) {\n    var shape = Object.create(template);\n    shape._setParent(undefined);\n    shape.id = template.id + '-Instance-' + String(++template.lastInstanceId);\n    return shape;\n  };\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  Shape.prototype.restoreOwnStyles = function () {\n    var styles = this.constructor.defaultStyles;\n    var keys = Object.getOwnPropertyNames(styles);\n    // getOwnPropertyNames is about 2.5 times faster than\n    // for..in with the hasOwnProperty check and in this\n    // case, where most properties are inherited, can be\n    // more then an order of magnitude faster.\n    for (var i = 0, n = keys.length; i < n; i++) {\n      var key = keys[i];\n      this[key] = styles[key];\n    }\n  };\n  Shape.prototype.restoreAllStyles = function () {\n    var styles = this.constructor.defaultStyles;\n    for (var property in styles) {\n      this[property] = styles[property];\n    }\n  };\n  /**\n   * Restores the base class default styles that have been overridden by this subclass.\n   */\n  Shape.prototype.restoreOverriddenStyles = function () {\n    var styles = this.constructor.defaultStyles;\n    var protoStyles = Object.getPrototypeOf(styles);\n    for (var property in styles) {\n      if (styles.hasOwnProperty(property) && protoStyles.hasOwnProperty(property)) {\n        this[property] = styles[property];\n      }\n    }\n  };\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  Shape.prototype.align = function (start, length) {\n    var _a, _b, _c;\n    var pixelRatio = (_c = (_b = (_a = this.scene) === null || _a === void 0 ? void 0 : _a.canvas) === null || _b === void 0 ? void 0 : _b.pixelRatio, _c !== null && _c !== void 0 ? _c : 1);\n    var alignedStart = Math.round(start * pixelRatio) / pixelRatio;\n    if (length == undefined) {\n      return alignedStart;\n    }\n    if (length === 0) {\n      return 0;\n    }\n    if (length < 1) {\n      // Avoid hiding crisp shapes\n      return Math.ceil(length * pixelRatio) / pixelRatio;\n    }\n    // Account for the rounding of alignedStart by increasing length to compensate before\n    // alignment.\n    return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;\n  };\n  Shape.prototype.fillStroke = function (ctx) {\n    if (!this.scene) {\n      return;\n    }\n    var pixelRatio = this.scene.canvas.pixelRatio || 1;\n    var globalAlpha = ctx.globalAlpha;\n    if (this.fill) {\n      ctx.fillStyle = this.fill;\n      ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\n      // The canvas context scaling (depends on the device's pixel ratio)\n      // has no effect on shadows, so we have to account for the pixel ratio\n      // manually here.\n      var fillShadow = this.fillShadow;\n      if (fillShadow && fillShadow.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      ctx.fill();\n    }\n    ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n    if (this.stroke && this.strokeWidth) {\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      ctx.stroke();\n    }\n  };\n  Shape.prototype.containsPoint = function (x, y) {\n    return this.isPointInPath(x, y);\n  };\n  /**\n   * Defaults for style properties. Note that properties that affect the position\n   * and shape of the node are not considered style properties, for example:\n   * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n   * Can be used to reset to the original styling after some custom styling\n   * has been applied (using the `restoreOwnStyles` and `restoreAllStyles` methods).\n   * These static defaults are meant to be inherited by subclasses.\n   */\n  Shape.defaultStyles = chainObjects({}, {\n    fill: 'black',\n    stroke: undefined,\n    strokeWidth: 0,\n    lineDash: undefined,\n    lineDashOffset: 0,\n    lineCap: undefined,\n    lineJoin: undefined,\n    opacity: 1,\n    fillShadow: undefined\n  });\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"fillOpacity\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"strokeOpacity\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"fill\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"stroke\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"strokeWidth\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"lineDash\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"lineDashOffset\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"lineCap\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR\n  })], Shape.prototype, \"lineJoin\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR,\n    convertor: function (v) {\n      return Math.min(1, Math.max(0, v));\n    }\n  })], Shape.prototype, \"opacity\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MINOR,\n    checkDirtyOnAssignment: true\n  })], Shape.prototype, \"fillShadow\", void 0);\n  return Shape;\n}(Node);\nexport { Shape };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Node","RedrawType","SceneChangeDetection","chainObjects","Shape","_super","_this","apply","lastInstanceId","fillOpacity","strokeOpacity","fill","defaultStyles","stroke","strokeWidth","lineDash","lineDashOffset","lineCap","lineJoin","opacity","fillShadow","createInstance","template","shape","_setParent","undefined","id","String","restoreOwnStyles","styles","keys","getOwnPropertyNames","n","restoreAllStyles","property","restoreOverriddenStyles","protoStyles","getPrototypeOf","align","start","_a","_b","_c","pixelRatio","scene","canvas","alignedStart","Math","round","ceil","fillStroke","ctx","globalAlpha","fillStyle","enabled","shadowColor","color","shadowOffsetX","xOffset","shadowOffsetY","yOffset","shadowBlur","blur","strokeStyle","lineWidth","setLineDash","containsPoint","x","y","isPointInPath","redraw","MINOR","convertor","v","min","max","checkDirtyOnAssignment"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/scene/shape/shape.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Node, RedrawType, SceneChangeDetection } from '../node';\nimport { chainObjects } from '../../util/object';\nvar Shape = /** @class */ (function (_super) {\n    __extends(Shape, _super);\n    function Shape() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.lastInstanceId = 0;\n        _this.fillOpacity = 1;\n        _this.strokeOpacity = 1;\n        _this.fill = Shape.defaultStyles.fill;\n        /**\n         * Note that `strokeStyle = null` means invisible stroke,\n         * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\n         * For example, a rect shape with an invisible stroke may not align to the pixel grid\n         * properly because the stroke affects the rules of alignment, and arc shapes forming\n         * a pie chart will have a gap between them if they have an invisible stroke, whereas\n         * there would be not gap if there was no stroke at all.\n         * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\n         * unless specific looks that is achieved by having an invisible stroke is desired.\n         */\n        _this.stroke = Shape.defaultStyles.stroke;\n        _this.strokeWidth = Shape.defaultStyles.strokeWidth;\n        _this.lineDash = Shape.defaultStyles.lineDash;\n        _this.lineDashOffset = Shape.defaultStyles.lineDashOffset;\n        _this.lineCap = Shape.defaultStyles.lineCap;\n        _this.lineJoin = Shape.defaultStyles.lineJoin;\n        _this.opacity = Shape.defaultStyles.opacity;\n        _this.fillShadow = Shape.defaultStyles.fillShadow;\n        return _this;\n    }\n    /**\n     * Creates a light-weight instance of the given shape (that serves as a template).\n     * The created instance only stores the properites set on the instance itself\n     * and the rest of the properties come via the prototype chain from the template.\n     * This can greatly reduce memory usage in cases where one has many simular shapes,\n     * for example, circles of different size, position and color. The exact memory usage\n     * reduction will depend on the size of the template and the number of own properties\n     * set on its lightweight instances, but will typically be around an order of magnitude\n     * or more.\n     *\n     * Note: template shapes are not supposed to be part of the scene graph (they should not\n     * have a parent).\n     *\n     * @param template\n     */\n    Shape.createInstance = function (template) {\n        var shape = Object.create(template);\n        shape._setParent(undefined);\n        shape.id = template.id + '-Instance-' + String(++template.lastInstanceId);\n        return shape;\n    };\n    /**\n     * Restores the default styles introduced by this subclass.\n     */\n    Shape.prototype.restoreOwnStyles = function () {\n        var styles = this.constructor.defaultStyles;\n        var keys = Object.getOwnPropertyNames(styles);\n        // getOwnPropertyNames is about 2.5 times faster than\n        // for..in with the hasOwnProperty check and in this\n        // case, where most properties are inherited, can be\n        // more then an order of magnitude faster.\n        for (var i = 0, n = keys.length; i < n; i++) {\n            var key = keys[i];\n            this[key] = styles[key];\n        }\n    };\n    Shape.prototype.restoreAllStyles = function () {\n        var styles = this.constructor.defaultStyles;\n        for (var property in styles) {\n            this[property] = styles[property];\n        }\n    };\n    /**\n     * Restores the base class default styles that have been overridden by this subclass.\n     */\n    Shape.prototype.restoreOverriddenStyles = function () {\n        var styles = this.constructor.defaultStyles;\n        var protoStyles = Object.getPrototypeOf(styles);\n        for (var property in styles) {\n            if (styles.hasOwnProperty(property) && protoStyles.hasOwnProperty(property)) {\n                this[property] = styles[property];\n            }\n        }\n    };\n    /**\n     * Returns a device-pixel aligned coordinate (or length if length is supplied).\n     *\n     * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n     * of a device pixel.\n     */\n    Shape.prototype.align = function (start, length) {\n        var _a, _b, _c;\n        var pixelRatio = (_c = (_b = (_a = this.scene) === null || _a === void 0 ? void 0 : _a.canvas) === null || _b === void 0 ? void 0 : _b.pixelRatio, (_c !== null && _c !== void 0 ? _c : 1));\n        var alignedStart = Math.round(start * pixelRatio) / pixelRatio;\n        if (length == undefined) {\n            return alignedStart;\n        }\n        if (length === 0) {\n            return 0;\n        }\n        if (length < 1) {\n            // Avoid hiding crisp shapes\n            return Math.ceil(length * pixelRatio) / pixelRatio;\n        }\n        // Account for the rounding of alignedStart by increasing length to compensate before\n        // alignment.\n        return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;\n    };\n    Shape.prototype.fillStroke = function (ctx) {\n        if (!this.scene) {\n            return;\n        }\n        var pixelRatio = this.scene.canvas.pixelRatio || 1;\n        var globalAlpha = ctx.globalAlpha;\n        if (this.fill) {\n            ctx.fillStyle = this.fill;\n            ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\n            // The canvas context scaling (depends on the device's pixel ratio)\n            // has no effect on shadows, so we have to account for the pixel ratio\n            // manually here.\n            var fillShadow = this.fillShadow;\n            if (fillShadow && fillShadow.enabled) {\n                ctx.shadowColor = fillShadow.color;\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\n            }\n            ctx.fill();\n        }\n        ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n        if (this.stroke && this.strokeWidth) {\n            ctx.strokeStyle = this.stroke;\n            ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\n            ctx.lineWidth = this.strokeWidth;\n            if (this.lineDash) {\n                ctx.setLineDash(this.lineDash);\n            }\n            if (this.lineDashOffset) {\n                ctx.lineDashOffset = this.lineDashOffset;\n            }\n            if (this.lineCap) {\n                ctx.lineCap = this.lineCap;\n            }\n            if (this.lineJoin) {\n                ctx.lineJoin = this.lineJoin;\n            }\n            ctx.stroke();\n        }\n    };\n    Shape.prototype.containsPoint = function (x, y) {\n        return this.isPointInPath(x, y);\n    };\n    /**\n     * Defaults for style properties. Note that properties that affect the position\n     * and shape of the node are not considered style properties, for example:\n     * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n     * Can be used to reset to the original styling after some custom styling\n     * has been applied (using the `restoreOwnStyles` and `restoreAllStyles` methods).\n     * These static defaults are meant to be inherited by subclasses.\n     */\n    Shape.defaultStyles = chainObjects({}, {\n        fill: 'black',\n        stroke: undefined,\n        strokeWidth: 0,\n        lineDash: undefined,\n        lineDashOffset: 0,\n        lineCap: undefined,\n        lineJoin: undefined,\n        opacity: 1,\n        fillShadow: undefined,\n    });\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"fillOpacity\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"strokeOpacity\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"fill\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"stroke\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"strokeWidth\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"lineDash\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"lineDashOffset\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"lineCap\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR })\n    ], Shape.prototype, \"lineJoin\", void 0);\n    __decorate([\n        SceneChangeDetection({\n            redraw: RedrawType.MINOR,\n            convertor: function (v) { return Math.min(1, Math.max(0, v)); },\n        })\n    ], Shape.prototype, \"opacity\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MINOR, checkDirtyOnAssignment: true })\n    ], Shape.prototype, \"fillShadow\", void 0);\n    return Shape;\n}(Node));\nexport { Shape };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}