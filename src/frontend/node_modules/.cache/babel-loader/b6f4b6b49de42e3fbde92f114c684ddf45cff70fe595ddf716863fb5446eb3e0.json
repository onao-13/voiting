{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nexports.__esModule = true;\nvar imageHelper = require(\"../helper/image\");\nvar util_1 = require(\"../../core/util\");\nvar text_1 = require(\"../../contain/text\");\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n  return textLines.join('\\n');\n}\nexports.truncateText = truncateText;\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = options || {};\n  var preparedOpts = util_1.extend({}, options);\n  preparedOpts.font = font;\n  ellipsis = util_1.retrieve2(ellipsis, '...');\n  preparedOpts.maxIterations = util_1.retrieve2(options.maxIterations, 2);\n  var minChar = preparedOpts.minChar = util_1.retrieve2(options.minChar, 0);\n  preparedOpts.cnCharWidth = text_1.getWidth('国', font);\n  var ascCharWidth = preparedOpts.ascCharWidth = text_1.getWidth('a', font);\n  preparedOpts.placeholder = util_1.retrieve2(options.placeholder, '');\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n  var ellipsisWidth = text_1.getWidth(ellipsis, font);\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n  contentWidth = containerWidth - ellipsisWidth;\n  preparedOpts.ellipsis = ellipsis;\n  preparedOpts.ellipsisWidth = ellipsisWidth;\n  preparedOpts.contentWidth = contentWidth;\n  preparedOpts.containerWidth = containerWidth;\n  return preparedOpts;\n}\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n  if (!containerWidth) {\n    return '';\n  }\n  var lineWidth = text_1.getWidth(textLine, font);\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = text_1.getWidth(textLine, font);\n  }\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n  return textLine;\n}\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n  return i;\n}\nfunction parsePlainText(text, style) {\n  text != null && (text += '');\n  var overflow = style.overflow;\n  var padding = style.padding;\n  var font = style.font;\n  var truncate = overflow === 'truncate';\n  var calculatedLineHeight = text_1.getLineHeight(font);\n  var lineHeight = util_1.retrieve2(style.lineHeight, calculatedLineHeight);\n  var truncateLineOverflow = style.lineOverflow === 'truncate';\n  var width = style.width;\n  var lines;\n  if (width != null && overflow === 'break' || overflow === 'breakAll') {\n    lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];\n  } else {\n    lines = text ? text.split('\\n') : [];\n  }\n  var contentHeight = lines.length * lineHeight;\n  var height = util_1.retrieve2(style.height, contentHeight);\n  if (contentHeight > height && truncateLineOverflow) {\n    var lineCount = Math.floor(height / lineHeight);\n    lines = lines.slice(0, lineCount);\n  }\n  var outerHeight = height;\n  var outerWidth = width;\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n    if (outerWidth != null) {\n      outerWidth += padding[1] + padding[3];\n    }\n  }\n  if (text && truncate && outerWidth != null) {\n    var options = prepareTruncateOptions(width, font, style.ellipsis, {\n      minChar: style.truncateMinChar,\n      placeholder: style.placeholder\n    });\n    for (var i = 0; i < lines.length; i++) {\n      lines[i] = truncateSingleLine(lines[i], options);\n    }\n  }\n  if (width == null) {\n    var maxWidth = 0;\n    for (var i = 0; i < lines.length; i++) {\n      maxWidth = Math.max(text_1.getWidth(lines[i], font), maxWidth);\n    }\n    width = maxWidth;\n  }\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    calculatedLineHeight: calculatedLineHeight,\n    contentHeight: contentHeight,\n    width: width\n  };\n}\nexports.parsePlainText = parsePlainText;\nvar RichTextToken = function () {\n  function RichTextToken() {}\n  return RichTextToken;\n}();\nvar RichTextLine = function () {\n  function RichTextLine(tokens) {\n    this.tokens = [];\n    if (tokens) {\n      this.tokens = tokens;\n    }\n  }\n  return RichTextLine;\n}();\nvar RichTextContentBlock = function () {\n  function RichTextContentBlock() {\n    this.width = 0;\n    this.height = 0;\n    this.contentWidth = 0;\n    this.contentHeight = 0;\n    this.outerWidth = 0;\n    this.outerHeight = 0;\n    this.lines = [];\n  }\n  return RichTextContentBlock;\n}();\nexports.RichTextContentBlock = RichTextContentBlock;\nfunction parseRichText(text, style) {\n  var contentBlock = new RichTextContentBlock();\n  text != null && (text += '');\n  if (!text) {\n    return contentBlock;\n  }\n  var topWidth = style.width;\n  var topHeight = style.height;\n  var overflow = style.overflow;\n  var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null ? {\n    width: topWidth,\n    accumWidth: 0,\n    breakAll: overflow === 'breakAll'\n  } : null;\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);\n    }\n    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);\n  }\n  var pendingList = [];\n  var calculatedHeight = 0;\n  var calculatedWidth = 0;\n  var stlPadding = style.padding;\n  var truncate = overflow === 'truncate';\n  var truncateLine = style.lineOverflow === 'truncate';\n  var prevToken;\n  function finishLine(line, lineWidth, lineHeight) {\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    calculatedHeight += lineHeight;\n    calculatedWidth = Math.max(calculatedWidth, lineWidth);\n  }\n  outer: for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n      var textPadding = token.textPadding = tokenStyle.padding;\n      var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;\n      var font = token.font = tokenStyle.font || style.font;\n      token.contentHeight = text_1.getLineHeight(font);\n      var tokenHeight = util_1.retrieve2(tokenStyle.height, token.contentHeight);\n      token.innerHeight = tokenHeight;\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = util_1.retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);\n      token.align = tokenStyle && tokenStyle.align || style.align;\n      token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';\n      if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {\n        if (j > 0) {\n          line.tokens = line.tokens.slice(0, j);\n          finishLine(line, lineWidth, lineHeight);\n          contentBlock.lines = contentBlock.lines.slice(0, i + 1);\n        } else {\n          contentBlock.lines = contentBlock.lines.slice(0, i);\n        }\n        break outer;\n      }\n      var styleTokenWidth = tokenStyle.width;\n      var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';\n      if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {\n        token.percentWidth = styleTokenWidth;\n        pendingList.push(token);\n        token.contentWidth = text_1.getWidth(token.text, font);\n      } else {\n        if (tokenWidthNotSpecified) {\n          var textBackgroundColor = tokenStyle.backgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image;\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n            if (imageHelper.isImageReady(bgImg)) {\n              token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n        var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;\n        if (remainTruncWidth != null && remainTruncWidth < token.width) {\n          if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {\n            token.text = '';\n            token.width = token.contentWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, {\n              minChar: style.truncateMinChar\n            });\n            token.width = token.contentWidth = text_1.getWidth(token.text, font);\n          }\n        } else {\n          token.contentWidth = text_1.getWidth(token.text, font);\n        }\n      }\n      token.width += paddingH;\n      lineWidth += token.width;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n      prevToken = token;\n    }\n    finishLine(line, lineWidth, lineHeight);\n  }\n  contentBlock.outerWidth = contentBlock.width = util_1.retrieve2(topWidth, calculatedWidth);\n  contentBlock.outerHeight = contentBlock.height = util_1.retrieve2(topHeight, calculatedHeight);\n  contentBlock.contentHeight = calculatedHeight;\n  contentBlock.contentWidth = calculatedWidth;\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth;\n    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;\n  }\n  return contentBlock;\n}\nexports.parseRichText = parseRichText;\nfunction pushTokens(block, str, style, wrapInfo, styleName) {\n  var isEmptyStr = str === '';\n  var tokenStyle = styleName && style.rich[styleName] || {};\n  var lines = block.lines;\n  var font = tokenStyle.font || style.font;\n  var newLine = false;\n  var strLines;\n  var linesWidths;\n  if (wrapInfo) {\n    var tokenPadding = tokenStyle.padding;\n    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;\n    if (tokenStyle.width != null && tokenStyle.width !== 'auto') {\n      var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;\n      if (lines.length > 0) {\n        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {\n          strLines = str.split('\\n');\n          newLine = true;\n        }\n      }\n      wrapInfo.accumWidth = outerWidth_1;\n    } else {\n      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);\n      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;\n      linesWidths = res.linesWidths;\n      strLines = res.lines;\n    }\n  } else {\n    strLines = str.split('\\n');\n  }\n  for (var i = 0; i < strLines.length; i++) {\n    var text = strLines[i];\n    var token = new RichTextToken();\n    token.styleName = styleName;\n    token.text = text;\n    token.isLineHolder = !text && !isEmptyStr;\n    if (typeof tokenStyle.width === 'number') {\n      token.width = tokenStyle.width;\n    } else {\n      token.width = linesWidths ? linesWidths[i] : text_1.getWidth(text, font);\n    }\n    if (!i && !newLine) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } else {\n      lines.push(new RichTextLine([token]));\n    }\n  }\n}\nfunction isLatin(ch) {\n  var code = ch.charCodeAt(0);\n  return code >= 0x21 && code <= 0xFF;\n}\nvar breakCharMap = util_1.reduce(',&?/;] '.split(''), function (obj, ch) {\n  obj[ch] = true;\n  return obj;\n}, {});\nfunction isWordBreakChar(ch) {\n  if (isLatin(ch)) {\n    if (breakCharMap[ch]) {\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\nfunction wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {\n  var lines = [];\n  var linesWidths = [];\n  var line = '';\n  var currentWord = '';\n  var currentWordWidth = 0;\n  var accumWidth = 0;\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch === '\\n') {\n      if (currentWord) {\n        line += currentWord;\n        accumWidth += currentWordWidth;\n      }\n      lines.push(line);\n      linesWidths.push(accumWidth);\n      line = '';\n      currentWord = '';\n      currentWordWidth = 0;\n      accumWidth = 0;\n      continue;\n    }\n    var chWidth = text_1.getWidth(ch, font);\n    var inWord = isBreakAll ? false : !isWordBreakChar(ch);\n    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {\n      if (!accumWidth) {\n        if (inWord) {\n          lines.push(currentWord);\n          linesWidths.push(currentWordWidth);\n          currentWord = ch;\n          currentWordWidth = chWidth;\n        } else {\n          lines.push(ch);\n          linesWidths.push(chWidth);\n        }\n      } else if (line || currentWord) {\n        if (inWord) {\n          if (!line) {\n            line = currentWord;\n            currentWord = '';\n            currentWordWidth = 0;\n            accumWidth = currentWordWidth;\n          }\n          lines.push(line);\n          linesWidths.push(accumWidth - currentWordWidth);\n          currentWord += ch;\n          currentWordWidth += chWidth;\n          line = '';\n          accumWidth = currentWordWidth;\n        } else {\n          if (currentWord) {\n            line += currentWord;\n            accumWidth += currentWordWidth;\n            currentWord = '';\n            currentWordWidth = 0;\n          }\n          lines.push(line);\n          linesWidths.push(accumWidth);\n          line = ch;\n          accumWidth = chWidth;\n        }\n      }\n      continue;\n    }\n    accumWidth += chWidth;\n    if (inWord) {\n      currentWord += ch;\n      currentWordWidth += chWidth;\n    } else {\n      if (currentWord) {\n        line += currentWord;\n        currentWord = '';\n        currentWordWidth = 0;\n      }\n      line += ch;\n    }\n  }\n  if (!lines.length && !line) {\n    line = text;\n    currentWord = '';\n    currentWordWidth = 0;\n  }\n  if (currentWord) {\n    line += currentWord;\n  }\n  if (line) {\n    lines.push(line);\n    linesWidths.push(accumWidth);\n  }\n  if (lines.length === 1) {\n    accumWidth += lastAccumWidth;\n  }\n  return {\n    accumWidth: accumWidth,\n    lines: lines,\n    linesWidths: linesWidths\n  };\n}\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n    return parseFloat(value);\n  }\n  return value;\n}","map":{"version":3,"names":["exports","__esModule","imageHelper","require","util_1","text_1","STYLE_REG","truncateText","text","containerWidth","font","ellipsis","options","textLines","split","prepareTruncateOptions","i","len","length","truncateSingleLine","join","preparedOpts","extend","retrieve2","maxIterations","minChar","cnCharWidth","getWidth","ascCharWidth","placeholder","contentWidth","Math","max","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","width","charCode","charCodeAt","parsePlainText","style","overflow","padding","truncate","calculatedLineHeight","getLineHeight","lineHeight","truncateLineOverflow","lineOverflow","lines","wrapText","contentHeight","height","lineCount","slice","outerHeight","outerWidth","truncateMinChar","maxWidth","RichTextToken","RichTextLine","tokens","RichTextContentBlock","parseRichText","contentBlock","topWidth","topHeight","wrapInfo","accumWidth","breakAll","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","pendingList","calculatedHeight","calculatedWidth","stlPadding","truncateLine","prevToken","finishLine","line","outer","token","tokenStyle","styleName","rich","textPadding","paddingH","tokenHeight","innerHeight","retrieve3","align","verticalAlign","styleTokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","backgroundColor","bgImg","image","findExistImage","isImageReady","remainTruncWidth","parseInt","block","str","isEmptyStr","newLine","strLines","linesWidths","tokenPadding","tokenPaddingH","outerWidth_1","parsePercent","res","isLineHolder","tokensLen","isLatin","ch","code","breakCharMap","reduce","obj","isWordBreakChar","isBreakAll","lastAccumWidth","currentWord","currentWordWidth","chWidth","inWord","value","maxValue","lastIndexOf","parseFloat"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/zrender/lib/graphic/helper/parseText.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar imageHelper = require(\"../helper/image\");\nvar util_1 = require(\"../../core/util\");\nvar text_1 = require(\"../../contain/text\");\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n    if (!containerWidth) {\n        return '';\n    }\n    var textLines = (text + '').split('\\n');\n    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n    for (var i = 0, len = textLines.length; i < len; i++) {\n        textLines[i] = truncateSingleLine(textLines[i], options);\n    }\n    return textLines.join('\\n');\n}\nexports.truncateText = truncateText;\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n    options = options || {};\n    var preparedOpts = util_1.extend({}, options);\n    preparedOpts.font = font;\n    ellipsis = util_1.retrieve2(ellipsis, '...');\n    preparedOpts.maxIterations = util_1.retrieve2(options.maxIterations, 2);\n    var minChar = preparedOpts.minChar = util_1.retrieve2(options.minChar, 0);\n    preparedOpts.cnCharWidth = text_1.getWidth('国', font);\n    var ascCharWidth = preparedOpts.ascCharWidth = text_1.getWidth('a', font);\n    preparedOpts.placeholder = util_1.retrieve2(options.placeholder, '');\n    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n        contentWidth -= ascCharWidth;\n    }\n    var ellipsisWidth = text_1.getWidth(ellipsis, font);\n    if (ellipsisWidth > contentWidth) {\n        ellipsis = '';\n        ellipsisWidth = 0;\n    }\n    contentWidth = containerWidth - ellipsisWidth;\n    preparedOpts.ellipsis = ellipsis;\n    preparedOpts.ellipsisWidth = ellipsisWidth;\n    preparedOpts.contentWidth = contentWidth;\n    preparedOpts.containerWidth = containerWidth;\n    return preparedOpts;\n}\nfunction truncateSingleLine(textLine, options) {\n    var containerWidth = options.containerWidth;\n    var font = options.font;\n    var contentWidth = options.contentWidth;\n    if (!containerWidth) {\n        return '';\n    }\n    var lineWidth = text_1.getWidth(textLine, font);\n    if (lineWidth <= containerWidth) {\n        return textLine;\n    }\n    for (var j = 0;; j++) {\n        if (lineWidth <= contentWidth || j >= options.maxIterations) {\n            textLine += options.ellipsis;\n            break;\n        }\n        var subLength = j === 0\n            ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n            : lineWidth > 0\n                ? Math.floor(textLine.length * contentWidth / lineWidth)\n                : 0;\n        textLine = textLine.substr(0, subLength);\n        lineWidth = text_1.getWidth(textLine, font);\n    }\n    if (textLine === '') {\n        textLine = options.placeholder;\n    }\n    return textLine;\n}\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n    var width = 0;\n    var i = 0;\n    for (var len = text.length; i < len && width < contentWidth; i++) {\n        var charCode = text.charCodeAt(i);\n        width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n    }\n    return i;\n}\nfunction parsePlainText(text, style) {\n    text != null && (text += '');\n    var overflow = style.overflow;\n    var padding = style.padding;\n    var font = style.font;\n    var truncate = overflow === 'truncate';\n    var calculatedLineHeight = text_1.getLineHeight(font);\n    var lineHeight = util_1.retrieve2(style.lineHeight, calculatedLineHeight);\n    var truncateLineOverflow = style.lineOverflow === 'truncate';\n    var width = style.width;\n    var lines;\n    if (width != null && overflow === 'break' || overflow === 'breakAll') {\n        lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];\n    }\n    else {\n        lines = text ? text.split('\\n') : [];\n    }\n    var contentHeight = lines.length * lineHeight;\n    var height = util_1.retrieve2(style.height, contentHeight);\n    if (contentHeight > height && truncateLineOverflow) {\n        var lineCount = Math.floor(height / lineHeight);\n        lines = lines.slice(0, lineCount);\n    }\n    var outerHeight = height;\n    var outerWidth = width;\n    if (padding) {\n        outerHeight += padding[0] + padding[2];\n        if (outerWidth != null) {\n            outerWidth += padding[1] + padding[3];\n        }\n    }\n    if (text && truncate && outerWidth != null) {\n        var options = prepareTruncateOptions(width, font, style.ellipsis, {\n            minChar: style.truncateMinChar,\n            placeholder: style.placeholder\n        });\n        for (var i = 0; i < lines.length; i++) {\n            lines[i] = truncateSingleLine(lines[i], options);\n        }\n    }\n    if (width == null) {\n        var maxWidth = 0;\n        for (var i = 0; i < lines.length; i++) {\n            maxWidth = Math.max(text_1.getWidth(lines[i], font), maxWidth);\n        }\n        width = maxWidth;\n    }\n    return {\n        lines: lines,\n        height: height,\n        outerHeight: outerHeight,\n        lineHeight: lineHeight,\n        calculatedLineHeight: calculatedLineHeight,\n        contentHeight: contentHeight,\n        width: width\n    };\n}\nexports.parsePlainText = parsePlainText;\nvar RichTextToken = (function () {\n    function RichTextToken() {\n    }\n    return RichTextToken;\n}());\nvar RichTextLine = (function () {\n    function RichTextLine(tokens) {\n        this.tokens = [];\n        if (tokens) {\n            this.tokens = tokens;\n        }\n    }\n    return RichTextLine;\n}());\nvar RichTextContentBlock = (function () {\n    function RichTextContentBlock() {\n        this.width = 0;\n        this.height = 0;\n        this.contentWidth = 0;\n        this.contentHeight = 0;\n        this.outerWidth = 0;\n        this.outerHeight = 0;\n        this.lines = [];\n    }\n    return RichTextContentBlock;\n}());\nexports.RichTextContentBlock = RichTextContentBlock;\nfunction parseRichText(text, style) {\n    var contentBlock = new RichTextContentBlock();\n    text != null && (text += '');\n    if (!text) {\n        return contentBlock;\n    }\n    var topWidth = style.width;\n    var topHeight = style.height;\n    var overflow = style.overflow;\n    var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null\n        ? { width: topWidth, accumWidth: 0, breakAll: overflow === 'breakAll' }\n        : null;\n    var lastIndex = STYLE_REG.lastIndex = 0;\n    var result;\n    while ((result = STYLE_REG.exec(text)) != null) {\n        var matchedIndex = result.index;\n        if (matchedIndex > lastIndex) {\n            pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);\n        }\n        pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);\n        lastIndex = STYLE_REG.lastIndex;\n    }\n    if (lastIndex < text.length) {\n        pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);\n    }\n    var pendingList = [];\n    var calculatedHeight = 0;\n    var calculatedWidth = 0;\n    var stlPadding = style.padding;\n    var truncate = overflow === 'truncate';\n    var truncateLine = style.lineOverflow === 'truncate';\n    var prevToken;\n    function finishLine(line, lineWidth, lineHeight) {\n        line.width = lineWidth;\n        line.lineHeight = lineHeight;\n        calculatedHeight += lineHeight;\n        calculatedWidth = Math.max(calculatedWidth, lineWidth);\n    }\n    outer: for (var i = 0; i < contentBlock.lines.length; i++) {\n        var line = contentBlock.lines[i];\n        var lineHeight = 0;\n        var lineWidth = 0;\n        for (var j = 0; j < line.tokens.length; j++) {\n            var token = line.tokens[j];\n            var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n            var textPadding = token.textPadding = tokenStyle.padding;\n            var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;\n            var font = token.font = tokenStyle.font || style.font;\n            token.contentHeight = text_1.getLineHeight(font);\n            var tokenHeight = util_1.retrieve2(tokenStyle.height, token.contentHeight);\n            token.innerHeight = tokenHeight;\n            textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n            token.height = tokenHeight;\n            token.lineHeight = util_1.retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);\n            token.align = tokenStyle && tokenStyle.align || style.align;\n            token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';\n            if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {\n                if (j > 0) {\n                    line.tokens = line.tokens.slice(0, j);\n                    finishLine(line, lineWidth, lineHeight);\n                    contentBlock.lines = contentBlock.lines.slice(0, i + 1);\n                }\n                else {\n                    contentBlock.lines = contentBlock.lines.slice(0, i);\n                }\n                break outer;\n            }\n            var styleTokenWidth = tokenStyle.width;\n            var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';\n            if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {\n                token.percentWidth = styleTokenWidth;\n                pendingList.push(token);\n                token.contentWidth = text_1.getWidth(token.text, font);\n            }\n            else {\n                if (tokenWidthNotSpecified) {\n                    var textBackgroundColor = tokenStyle.backgroundColor;\n                    var bgImg = textBackgroundColor && textBackgroundColor.image;\n                    if (bgImg) {\n                        bgImg = imageHelper.findExistImage(bgImg);\n                        if (imageHelper.isImageReady(bgImg)) {\n                            token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);\n                        }\n                    }\n                }\n                var remainTruncWidth = truncate && topWidth != null\n                    ? topWidth - lineWidth : null;\n                if (remainTruncWidth != null && remainTruncWidth < token.width) {\n                    if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {\n                        token.text = '';\n                        token.width = token.contentWidth = 0;\n                    }\n                    else {\n                        token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });\n                        token.width = token.contentWidth = text_1.getWidth(token.text, font);\n                    }\n                }\n                else {\n                    token.contentWidth = text_1.getWidth(token.text, font);\n                }\n            }\n            token.width += paddingH;\n            lineWidth += token.width;\n            tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n            prevToken = token;\n        }\n        finishLine(line, lineWidth, lineHeight);\n    }\n    contentBlock.outerWidth = contentBlock.width = util_1.retrieve2(topWidth, calculatedWidth);\n    contentBlock.outerHeight = contentBlock.height = util_1.retrieve2(topHeight, calculatedHeight);\n    contentBlock.contentHeight = calculatedHeight;\n    contentBlock.contentWidth = calculatedWidth;\n    if (stlPadding) {\n        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n    }\n    for (var i = 0; i < pendingList.length; i++) {\n        var token = pendingList[i];\n        var percentWidth = token.percentWidth;\n        token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;\n    }\n    return contentBlock;\n}\nexports.parseRichText = parseRichText;\nfunction pushTokens(block, str, style, wrapInfo, styleName) {\n    var isEmptyStr = str === '';\n    var tokenStyle = styleName && style.rich[styleName] || {};\n    var lines = block.lines;\n    var font = tokenStyle.font || style.font;\n    var newLine = false;\n    var strLines;\n    var linesWidths;\n    if (wrapInfo) {\n        var tokenPadding = tokenStyle.padding;\n        var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;\n        if (tokenStyle.width != null && tokenStyle.width !== 'auto') {\n            var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;\n            if (lines.length > 0) {\n                if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {\n                    strLines = str.split('\\n');\n                    newLine = true;\n                }\n            }\n            wrapInfo.accumWidth = outerWidth_1;\n        }\n        else {\n            var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);\n            wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;\n            linesWidths = res.linesWidths;\n            strLines = res.lines;\n        }\n    }\n    else {\n        strLines = str.split('\\n');\n    }\n    for (var i = 0; i < strLines.length; i++) {\n        var text = strLines[i];\n        var token = new RichTextToken();\n        token.styleName = styleName;\n        token.text = text;\n        token.isLineHolder = !text && !isEmptyStr;\n        if (typeof tokenStyle.width === 'number') {\n            token.width = tokenStyle.width;\n        }\n        else {\n            token.width = linesWidths\n                ? linesWidths[i]\n                : text_1.getWidth(text, font);\n        }\n        if (!i && !newLine) {\n            var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;\n            var tokensLen = tokens.length;\n            (tokensLen === 1 && tokens[0].isLineHolder)\n                ? (tokens[0] = token)\n                : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n        }\n        else {\n            lines.push(new RichTextLine([token]));\n        }\n    }\n}\nfunction isLatin(ch) {\n    var code = ch.charCodeAt(0);\n    return code >= 0x21 && code <= 0xFF;\n}\nvar breakCharMap = util_1.reduce(',&?/;] '.split(''), function (obj, ch) {\n    obj[ch] = true;\n    return obj;\n}, {});\nfunction isWordBreakChar(ch) {\n    if (isLatin(ch)) {\n        if (breakCharMap[ch]) {\n            return true;\n        }\n        return false;\n    }\n    return true;\n}\nfunction wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {\n    var lines = [];\n    var linesWidths = [];\n    var line = '';\n    var currentWord = '';\n    var currentWordWidth = 0;\n    var accumWidth = 0;\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\n') {\n            if (currentWord) {\n                line += currentWord;\n                accumWidth += currentWordWidth;\n            }\n            lines.push(line);\n            linesWidths.push(accumWidth);\n            line = '';\n            currentWord = '';\n            currentWordWidth = 0;\n            accumWidth = 0;\n            continue;\n        }\n        var chWidth = text_1.getWidth(ch, font);\n        var inWord = isBreakAll ? false : !isWordBreakChar(ch);\n        if (!lines.length\n            ? lastAccumWidth + accumWidth + chWidth > lineWidth\n            : accumWidth + chWidth > lineWidth) {\n            if (!accumWidth) {\n                if (inWord) {\n                    lines.push(currentWord);\n                    linesWidths.push(currentWordWidth);\n                    currentWord = ch;\n                    currentWordWidth = chWidth;\n                }\n                else {\n                    lines.push(ch);\n                    linesWidths.push(chWidth);\n                }\n            }\n            else if (line || currentWord) {\n                if (inWord) {\n                    if (!line) {\n                        line = currentWord;\n                        currentWord = '';\n                        currentWordWidth = 0;\n                        accumWidth = currentWordWidth;\n                    }\n                    lines.push(line);\n                    linesWidths.push(accumWidth - currentWordWidth);\n                    currentWord += ch;\n                    currentWordWidth += chWidth;\n                    line = '';\n                    accumWidth = currentWordWidth;\n                }\n                else {\n                    if (currentWord) {\n                        line += currentWord;\n                        accumWidth += currentWordWidth;\n                        currentWord = '';\n                        currentWordWidth = 0;\n                    }\n                    lines.push(line);\n                    linesWidths.push(accumWidth);\n                    line = ch;\n                    accumWidth = chWidth;\n                }\n            }\n            continue;\n        }\n        accumWidth += chWidth;\n        if (inWord) {\n            currentWord += ch;\n            currentWordWidth += chWidth;\n        }\n        else {\n            if (currentWord) {\n                line += currentWord;\n                currentWord = '';\n                currentWordWidth = 0;\n            }\n            line += ch;\n        }\n    }\n    if (!lines.length && !line) {\n        line = text;\n        currentWord = '';\n        currentWordWidth = 0;\n    }\n    if (currentWord) {\n        line += currentWord;\n    }\n    if (line) {\n        lines.push(line);\n        linesWidths.push(accumWidth);\n    }\n    if (lines.length === 1) {\n        accumWidth += lastAccumWidth;\n    }\n    return {\n        accumWidth: accumWidth,\n        lines: lines,\n        linesWidths: linesWidths\n    };\n}\nfunction parsePercent(value, maxValue) {\n    if (typeof value === 'string') {\n        if (value.lastIndexOf('%') >= 0) {\n            return parseFloat(value) / 100 * maxValue;\n        }\n        return parseFloat(value);\n    }\n    return value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}