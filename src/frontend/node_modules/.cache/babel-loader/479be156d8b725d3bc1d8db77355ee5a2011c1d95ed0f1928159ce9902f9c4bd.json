{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    var value = arr[i];\n    if (predicate(value, i, arr)) {\n      return value;\n    }\n  }\n}\nexport function findIndex(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    if (predicate(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction identity(value) {\n  return value;\n}\nexport function extent(values, predicate, map) {\n  var transform = map || identity;\n  var n = values.length;\n  var i = -1;\n  var value;\n  var min;\n  var max;\n  while (++i < n) {\n    // Find the first value.\n    value = values[i];\n    if (predicate(value)) {\n      min = max = value;\n      while (++i < n) {\n        // Compare the remaining values.\n        value = values[i];\n        if (predicate(value)) {\n          if (min > value) {\n            min = value;\n          }\n          if (max < value) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n  return min === undefined || max === undefined ? undefined : [transform(min), transform(max)];\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nexport function findMinMax(values) {\n  var e_1, _a;\n  var min = undefined;\n  var max = undefined;\n  try {\n    for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n      var value = values_1_1.value;\n      if (value < 0) {\n        min = (min !== null && min !== void 0 ? min : 0) + value;\n      } else if (value >= 0) {\n        max = (max !== null && max !== void 0 ? max : 0) + value;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport function copy(array, start, count) {\n  if (start === void 0) {\n    start = 0;\n  }\n  if (count === void 0) {\n    count = array.length;\n  }\n  var result = [];\n  var n = array.length;\n  if (n) {\n    for (var i = 0; i < count; i++) {\n      result.push(array[(start + i) % n]);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","find","arr","predicate","findIndex","identity","extent","values","map","transform","n","min","max","undefined","findMinMax","e_1","_a","values_1","values_1_1","e_1_1","error","return","copy","array","start","count","result","push"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/util/array.js"],"sourcesContent":["var __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        var value = arr[i];\n        if (predicate(value, i, arr)) {\n            return value;\n        }\n    }\n}\nexport function findIndex(arr, predicate) {\n    for (var i = 0; i < arr.length; i++) {\n        if (predicate(arr[i], i, arr)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction identity(value) {\n    return value;\n}\nexport function extent(values, predicate, map) {\n    var transform = map || identity;\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) {\n        // Find the first value.\n        value = values[i];\n        if (predicate(value)) {\n            min = max = value;\n            while (++i < n) {\n                // Compare the remaining values.\n                value = values[i];\n                if (predicate(value)) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return min === undefined || max === undefined ? undefined : [transform(min), transform(max)];\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nexport function findMinMax(values) {\n    var e_1, _a;\n    var min = undefined;\n    var max = undefined;\n    try {\n        for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n            var value = values_1_1.value;\n            if (value < 0) {\n                min = ((min !== null && min !== void 0 ? min : 0)) + value;\n            }\n            else if (value >= 0) {\n                max = ((max !== null && max !== void 0 ? max : 0)) + value;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return { min: min, max: max };\n}\nexport function copy(array, start, count) {\n    if (start === void 0) { start = 0; }\n    if (count === void 0) { count = array.length; }\n    var result = [];\n    var n = array.length;\n    if (n) {\n        for (var i = 0; i < count; i++) {\n            result.push(array[(start + i) % n]);\n        }\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}