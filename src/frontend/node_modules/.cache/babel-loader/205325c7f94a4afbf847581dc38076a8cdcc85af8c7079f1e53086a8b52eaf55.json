{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Shape } from './shape';\nimport { chainObjects } from '../../util/object';\nimport { BBox } from '../bbox';\nimport { HdpiCanvas } from '../../canvas/hdpiCanvas';\nimport { RedrawType, SceneChangeDetection } from '../node';\nexport function SceneFontChangeDetection(opts) {\n  var _a = opts || {},\n    _b = _a.redraw,\n    redraw = _b === void 0 ? RedrawType.MAJOR : _b,\n    changeCb = _a.changeCb;\n  return SceneChangeDetection({\n    redraw: redraw,\n    type: 'font',\n    changeCb: changeCb\n  });\n}\nvar Text = /** @class */function (_super) {\n  __extends(Text, _super);\n  function Text() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.x = 0;\n    _this.y = 0;\n    _this.lines = [];\n    _this.text = '';\n    _this._dirtyFont = true;\n    _this.fontSize = 10;\n    _this.fontFamily = 'sans-serif';\n    _this.textAlign = Text.defaultStyles.textAlign;\n    _this.textBaseline = Text.defaultStyles.textBaseline;\n    // Multi-line text is complicated because:\n    // - Canvas does not support it natively, so we have to implement it manually\n    // - need to know the height of each line -> need to parse the font shorthand ->\n    //   generally impossible to do because font size may not be in pixels\n    // - so, need to measure the text instead, each line individually -> expensive\n    // - or make the user provide the line height manually for multi-line text\n    // - computeBBox should use the lineHeight for multi-line text but ignore it otherwise\n    // - textBaseline kind of loses its meaning for multi-line text\n    _this.lineHeight = 14;\n    return _this;\n  }\n  Text.prototype._splitText = function () {\n    this.lines = typeof this.text === 'string' ? this.text.split(/\\r?\\n/g) : [];\n  };\n  Object.defineProperty(Text.prototype, \"font\", {\n    get: function () {\n      if (this._dirtyFont) {\n        this._dirtyFont = false;\n        this._font = getFont(this.fontSize, this.fontFamily, this.fontStyle, this.fontWeight);\n      }\n      return this._font;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Text.prototype.computeBBox = function () {\n    return HdpiCanvas.has.textMetrics ? this.getPreciseBBox() : this.getApproximateBBox();\n  };\n  Text.prototype.getPreciseBBox = function () {\n    var metrics = HdpiCanvas.measureText(this.text, this.font, this.textBaseline, this.textAlign);\n    return new BBox(this.x - metrics.actualBoundingBoxLeft, this.y - metrics.actualBoundingBoxAscent, metrics.width, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);\n  };\n  Text.prototype.getApproximateBBox = function () {\n    var size = HdpiCanvas.getTextSize(this.text, this.font);\n    var _a = this,\n      x = _a.x,\n      y = _a.y;\n    switch (this.textAlign) {\n      case 'end':\n      case 'right':\n        x -= size.width;\n        break;\n      case 'center':\n        x -= size.width / 2;\n    }\n    switch (this.textBaseline) {\n      case 'alphabetic':\n        y -= size.height * 0.7;\n        break;\n      case 'middle':\n        y -= size.height * 0.45;\n        break;\n      case 'ideographic':\n        y -= size.height;\n        break;\n      case 'hanging':\n        y -= size.height * 0.2;\n        break;\n      case 'bottom':\n        y -= size.height;\n        break;\n    }\n    return new BBox(x, y, size.width, size.height);\n  };\n  Text.prototype.isPointInPath = function (x, y) {\n    var point = this.transformPoint(x, y);\n    var bbox = this.computeBBox();\n    return bbox ? bbox.containsPoint(point.x, point.y) : false;\n  };\n  Text.prototype.render = function (renderCtx) {\n    var ctx = renderCtx.ctx,\n      forceRender = renderCtx.forceRender,\n      stats = renderCtx.stats;\n    if (this.dirty === RedrawType.NONE && !forceRender) {\n      if (stats) stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    if (!this.lines.length || !this.scene) {\n      if (stats) stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    var _a = this,\n      fill = _a.fill,\n      stroke = _a.stroke,\n      strokeWidth = _a.strokeWidth;\n    ctx.font = this.font;\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    var pixelRatio = this.scene.canvas.pixelRatio || 1;\n    var globalAlpha = ctx.globalAlpha;\n    if (fill) {\n      ctx.fillStyle = fill;\n      ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\n      var _b = this,\n        fillShadow = _b.fillShadow,\n        text = _b.text,\n        x = _b.x,\n        y = _b.y;\n      if (fillShadow && fillShadow.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      ctx.fillText(text, x, y);\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\n      var _c = this,\n        lineDash = _c.lineDash,\n        lineDashOffset = _c.lineDashOffset,\n        lineCap = _c.lineCap,\n        lineJoin = _c.lineJoin,\n        text = _c.text,\n        x = _c.x,\n        y = _c.y;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.strokeText(text, x, y);\n    }\n    _super.prototype.render.call(this, renderCtx);\n  };\n  Text.className = 'Text';\n  Text.defaultStyles = chainObjects(Shape.defaultStyles, {\n    textAlign: 'start',\n    fontStyle: undefined,\n    fontWeight: undefined,\n    fontSize: 10,\n    fontFamily: 'sans-serif',\n    textBaseline: 'alphabetic'\n  });\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MAJOR\n  })], Text.prototype, \"x\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MAJOR\n  })], Text.prototype, \"y\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MAJOR,\n    changeCb: function (o) {\n      return o._splitText();\n    }\n  })], Text.prototype, \"text\", void 0);\n  __decorate([SceneFontChangeDetection()], Text.prototype, \"fontStyle\", void 0);\n  __decorate([SceneFontChangeDetection()], Text.prototype, \"fontWeight\", void 0);\n  __decorate([SceneFontChangeDetection()], Text.prototype, \"fontSize\", void 0);\n  __decorate([SceneFontChangeDetection()], Text.prototype, \"fontFamily\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MAJOR\n  })], Text.prototype, \"textAlign\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MAJOR\n  })], Text.prototype, \"textBaseline\", void 0);\n  __decorate([SceneChangeDetection({\n    redraw: RedrawType.MAJOR\n  })], Text.prototype, \"lineHeight\", void 0);\n  return Text;\n}(Shape);\nexport { Text };\nexport function getFont(fontSize, fontFamily, fontStyle, fontWeight) {\n  return [fontStyle || '', fontWeight || '', fontSize + 'px', fontFamily].join(' ').trim();\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Shape","chainObjects","BBox","HdpiCanvas","RedrawType","SceneChangeDetection","SceneFontChangeDetection","opts","_a","_b","redraw","MAJOR","changeCb","type","Text","_super","_this","apply","x","y","lines","text","_dirtyFont","fontSize","fontFamily","textAlign","defaultStyles","textBaseline","lineHeight","_splitText","split","get","_font","getFont","fontStyle","fontWeight","enumerable","configurable","computeBBox","has","textMetrics","getPreciseBBox","getApproximateBBox","metrics","measureText","font","actualBoundingBoxLeft","actualBoundingBoxAscent","width","actualBoundingBoxDescent","size","getTextSize","height","isPointInPath","point","transformPoint","bbox","containsPoint","render","renderCtx","ctx","forceRender","stats","dirty","NONE","nodesSkipped","nodeCount","count","scene","computeTransformMatrix","matrix","toContext","fill","stroke","strokeWidth","pixelRatio","canvas","globalAlpha","fillStyle","opacity","fillOpacity","fillShadow","enabled","shadowColor","color","shadowOffsetX","xOffset","shadowOffsetY","yOffset","shadowBlur","blur","fillText","strokeStyle","lineWidth","strokeOpacity","_c","lineDash","lineDashOffset","lineCap","lineJoin","setLineDash","strokeText","call","className","undefined","o","join","trim"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/ag-charts-community/dist/esm/es5/scene/shape/text.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Shape } from './shape';\nimport { chainObjects } from '../../util/object';\nimport { BBox } from '../bbox';\nimport { HdpiCanvas } from '../../canvas/hdpiCanvas';\nimport { RedrawType, SceneChangeDetection } from '../node';\nexport function SceneFontChangeDetection(opts) {\n    var _a = opts || {}, _b = _a.redraw, redraw = _b === void 0 ? RedrawType.MAJOR : _b, changeCb = _a.changeCb;\n    return SceneChangeDetection({ redraw: redraw, type: 'font', changeCb: changeCb });\n}\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    function Text() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.x = 0;\n        _this.y = 0;\n        _this.lines = [];\n        _this.text = '';\n        _this._dirtyFont = true;\n        _this.fontSize = 10;\n        _this.fontFamily = 'sans-serif';\n        _this.textAlign = Text.defaultStyles.textAlign;\n        _this.textBaseline = Text.defaultStyles.textBaseline;\n        // Multi-line text is complicated because:\n        // - Canvas does not support it natively, so we have to implement it manually\n        // - need to know the height of each line -> need to parse the font shorthand ->\n        //   generally impossible to do because font size may not be in pixels\n        // - so, need to measure the text instead, each line individually -> expensive\n        // - or make the user provide the line height manually for multi-line text\n        // - computeBBox should use the lineHeight for multi-line text but ignore it otherwise\n        // - textBaseline kind of loses its meaning for multi-line text\n        _this.lineHeight = 14;\n        return _this;\n    }\n    Text.prototype._splitText = function () {\n        this.lines = typeof this.text === 'string' ? this.text.split(/\\r?\\n/g) : [];\n    };\n    Object.defineProperty(Text.prototype, \"font\", {\n        get: function () {\n            if (this._dirtyFont) {\n                this._dirtyFont = false;\n                this._font = getFont(this.fontSize, this.fontFamily, this.fontStyle, this.fontWeight);\n            }\n            return this._font;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Text.prototype.computeBBox = function () {\n        return HdpiCanvas.has.textMetrics ? this.getPreciseBBox() : this.getApproximateBBox();\n    };\n    Text.prototype.getPreciseBBox = function () {\n        var metrics = HdpiCanvas.measureText(this.text, this.font, this.textBaseline, this.textAlign);\n        return new BBox(this.x - metrics.actualBoundingBoxLeft, this.y - metrics.actualBoundingBoxAscent, metrics.width, metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);\n    };\n    Text.prototype.getApproximateBBox = function () {\n        var size = HdpiCanvas.getTextSize(this.text, this.font);\n        var _a = this, x = _a.x, y = _a.y;\n        switch (this.textAlign) {\n            case 'end':\n            case 'right':\n                x -= size.width;\n                break;\n            case 'center':\n                x -= size.width / 2;\n        }\n        switch (this.textBaseline) {\n            case 'alphabetic':\n                y -= size.height * 0.7;\n                break;\n            case 'middle':\n                y -= size.height * 0.45;\n                break;\n            case 'ideographic':\n                y -= size.height;\n                break;\n            case 'hanging':\n                y -= size.height * 0.2;\n                break;\n            case 'bottom':\n                y -= size.height;\n                break;\n        }\n        return new BBox(x, y, size.width, size.height);\n    };\n    Text.prototype.isPointInPath = function (x, y) {\n        var point = this.transformPoint(x, y);\n        var bbox = this.computeBBox();\n        return bbox ? bbox.containsPoint(point.x, point.y) : false;\n    };\n    Text.prototype.render = function (renderCtx) {\n        var ctx = renderCtx.ctx, forceRender = renderCtx.forceRender, stats = renderCtx.stats;\n        if (this.dirty === RedrawType.NONE && !forceRender) {\n            if (stats)\n                stats.nodesSkipped += this.nodeCount.count;\n            return;\n        }\n        if (!this.lines.length || !this.scene) {\n            if (stats)\n                stats.nodesSkipped += this.nodeCount.count;\n            return;\n        }\n        this.computeTransformMatrix();\n        this.matrix.toContext(ctx);\n        var _a = this, fill = _a.fill, stroke = _a.stroke, strokeWidth = _a.strokeWidth;\n        ctx.font = this.font;\n        ctx.textAlign = this.textAlign;\n        ctx.textBaseline = this.textBaseline;\n        var pixelRatio = this.scene.canvas.pixelRatio || 1;\n        var globalAlpha = ctx.globalAlpha;\n        if (fill) {\n            ctx.fillStyle = fill;\n            ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\n            var _b = this, fillShadow = _b.fillShadow, text = _b.text, x = _b.x, y = _b.y;\n            if (fillShadow && fillShadow.enabled) {\n                ctx.shadowColor = fillShadow.color;\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\n            }\n            ctx.fillText(text, x, y);\n        }\n        if (stroke && strokeWidth) {\n            ctx.strokeStyle = stroke;\n            ctx.lineWidth = strokeWidth;\n            ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\n            var _c = this, lineDash = _c.lineDash, lineDashOffset = _c.lineDashOffset, lineCap = _c.lineCap, lineJoin = _c.lineJoin, text = _c.text, x = _c.x, y = _c.y;\n            if (lineDash) {\n                ctx.setLineDash(lineDash);\n            }\n            if (lineDashOffset) {\n                ctx.lineDashOffset = lineDashOffset;\n            }\n            if (lineCap) {\n                ctx.lineCap = lineCap;\n            }\n            if (lineJoin) {\n                ctx.lineJoin = lineJoin;\n            }\n            ctx.strokeText(text, x, y);\n        }\n        _super.prototype.render.call(this, renderCtx);\n    };\n    Text.className = 'Text';\n    Text.defaultStyles = chainObjects(Shape.defaultStyles, {\n        textAlign: 'start',\n        fontStyle: undefined,\n        fontWeight: undefined,\n        fontSize: 10,\n        fontFamily: 'sans-serif',\n        textBaseline: 'alphabetic',\n    });\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MAJOR })\n    ], Text.prototype, \"x\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MAJOR })\n    ], Text.prototype, \"y\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MAJOR, changeCb: function (o) { return o._splitText(); } })\n    ], Text.prototype, \"text\", void 0);\n    __decorate([\n        SceneFontChangeDetection()\n    ], Text.prototype, \"fontStyle\", void 0);\n    __decorate([\n        SceneFontChangeDetection()\n    ], Text.prototype, \"fontWeight\", void 0);\n    __decorate([\n        SceneFontChangeDetection()\n    ], Text.prototype, \"fontSize\", void 0);\n    __decorate([\n        SceneFontChangeDetection()\n    ], Text.prototype, \"fontFamily\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MAJOR })\n    ], Text.prototype, \"textAlign\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MAJOR })\n    ], Text.prototype, \"textBaseline\", void 0);\n    __decorate([\n        SceneChangeDetection({ redraw: RedrawType.MAJOR })\n    ], Text.prototype, \"lineHeight\", void 0);\n    return Text;\n}(Shape));\nexport { Text };\nexport function getFont(fontSize, fontFamily, fontStyle, fontWeight) {\n    return [fontStyle || '', fontWeight || '', fontSize + 'px', fontFamily].join(' ').trim();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}