{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nexports.__esModule = true;\nvar PathProxy_1 = require(\"../core/PathProxy\");\nvar curve_1 = require(\"../core/curve\");\nvar util_1 = require(\"../core/util\");\nvar vector_1 = require(\"../core/vector\");\nvar Rect_1 = require(\"../graphic/shape/Rect\");\nvar Sector_1 = require(\"../graphic/shape/Sector\");\nvar CMD = PathProxy_1[\"default\"].CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\nfunction aroundEqual(a, b) {\n  return Math.abs(a - b) < 1e-5;\n}\nfunction pathToBezierCurves(path) {\n  var data = path.data;\n  var len = path.len();\n  var bezierArray = [];\n  var currentSubpath;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  function createNewSubpath(x, y) {\n    if (currentSubpath && currentSubpath.length > 2) {\n      bezierArray.push(currentSubpath);\n    }\n    currentSubpath = [x, y];\n  }\n  function addLine(x0, y0, x1, y1) {\n    if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n      currentSubpath.push(x0, y0, x1, y1, x1, y1);\n    }\n  }\n  function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n    var delta = Math.abs(endAngle - startAngle);\n    var len = Math.tan(delta / 4) * 4 / 3;\n    var dir = endAngle < startAngle ? -1 : 1;\n    var c1 = Math.cos(startAngle);\n    var s1 = Math.sin(startAngle);\n    var c2 = Math.cos(endAngle);\n    var s2 = Math.sin(endAngle);\n    var x1 = c1 * rx + cx;\n    var y1 = s1 * ry + cy;\n    var x4 = c2 * rx + cx;\n    var y4 = s2 * ry + cy;\n    var hx = rx * len * dir;\n    var hy = ry * len * dir;\n    currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n  }\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n  for (var i = 0; i < len;) {\n    var cmd = data[i++];\n    var isFirst = i === 1;\n    if (isFirst) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n        currentSubpath = [x0, y0];\n      }\n    }\n    switch (cmd) {\n      case CMD.M:\n        xi = x0 = data[i++];\n        yi = y0 = data[i++];\n        createNewSubpath(x0, y0);\n        break;\n      case CMD.L:\n        x1 = data[i++];\n        y1 = data[i++];\n        addLine(xi, yi, x1, y1);\n        xi = x1;\n        yi = y1;\n        break;\n      case CMD.C:\n        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n        break;\n      case CMD.Q:\n        x1 = data[i++];\n        y1 = data[i++];\n        x2 = data[i++];\n        y2 = data[i++];\n        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n        xi = x2;\n        yi = y2;\n        break;\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var startAngle = data[i++];\n        var endAngle = data[i++] + startAngle;\n        i += 1;\n        var anticlockwise = !data[i++];\n        x1 = Math.cos(startAngle) * rx + cx;\n        y1 = Math.sin(startAngle) * ry + cy;\n        if (isFirst) {\n          x0 = x1;\n          y0 = y1;\n          createNewSubpath(x0, y0);\n        } else {\n          addLine(xi, yi, x1, y1);\n        }\n        xi = Math.cos(endAngle) * rx + cx;\n        yi = Math.sin(endAngle) * ry + cy;\n        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n          addArc(angle, nextAngle, cx, cy, rx, ry);\n        }\n        break;\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        x1 = x0 + data[i++];\n        y1 = y0 + data[i++];\n        createNewSubpath(x1, y0);\n        addLine(x1, y0, x1, y1);\n        addLine(x1, y1, x0, y1);\n        addLine(x0, y1, x0, y0);\n        addLine(x0, y0, x1, y0);\n        break;\n      case CMD.Z:\n        currentSubpath && addLine(xi, yi, x0, y0);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n  if (currentSubpath && currentSubpath.length > 2) {\n    bezierArray.push(currentSubpath);\n  }\n  return bezierArray;\n}\nexports.pathToBezierCurves = pathToBezierCurves;\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n  var tmpSegX = [];\n  var tmpSegY = [];\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      curve_1.cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      curve_1.cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n    remained -= actualSubDivCount - 1;\n  }\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n  return newSubpath;\n}\nfunction alignBezierCurves(array1, array2) {\n  var _a;\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n  return [newArray1, newArray2];\n}\nexports.alignBezierCurves = alignBezierCurves;\nfunction centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nexports.centroid = centroid;\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n  return bestOffset;\n}\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n  return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr_1 = [];\n    var len = fromSubpathBezier.length;\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr_1[k] = newX1;\n          tmpArr_1[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n          for (var m = 0; m < tmpArr_1.length; m++) {\n            newToSubpathBezier[m] = tmpArr_1[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n  return result;\n}\nfunction morphPath(fromPath, toPath, animationOpts) {\n  var fromPathProxy;\n  var toPathProxy;\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n  !fromPath.path && fromPath.createPathProxy();\n  fromPathProxy = fromPath.path;\n  fromPathProxy.beginPath();\n  fromPath.buildPath(fromPathProxy, fromPath.shape);\n  !toPath.path && toPath.createPathProxy();\n  toPathProxy = toPath.path;\n  toPathProxy === fromPathProxy && (toPathProxy = new PathProxy_1[\"default\"](false));\n  toPathProxy.beginPath();\n  if (isIndividualMorphingPath(toPath)) {\n    toPath.__oldBuildPath(toPathProxy, toPath.shape);\n  } else {\n    toPath.buildPath(toPathProxy, toPath.shape);\n  }\n  var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)),\n    fromBezierCurves = _a[0],\n    toBezierCurves = _a[1];\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  becomeIndividualMorphingPath(toPath, morphingData, 0);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  toPath.animateTo({\n    __morphT: 1\n  }, util_1.defaults({\n    during: function (p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      restoreIndividualMorphingPath(toPath);\n      toPath.createPathProxy();\n      toPath.dirtyShape();\n      oldDone && oldDone();\n    },\n    aborted: function () {\n      oldAborted && oldAborted();\n    }\n  }, animationOpts));\n  return toPath;\n}\nexports.morphPath = morphPath;\nfunction morphingPathBuildPath(path) {\n  var morphingData = this.__morphingData;\n  var t = this.__morphT;\n  var onet = 1 - t;\n  var newCp = [];\n  for (var i = 0; i < morphingData.length; i++) {\n    var item = morphingData[i];\n    var from = item.from;\n    var to = item.to;\n    var angle = item.rotation * t;\n    var fromCp = item.fromCp;\n    var toCp = item.toCp;\n    var sa = Math.sin(angle);\n    var ca = Math.cos(angle);\n    vector_1.lerp(newCp, fromCp, toCp, t);\n    for (var m = 0; m < from.length; m += 2) {\n      var x0 = from[m];\n      var y0 = from[m + 1];\n      var x1 = to[m];\n      var y1 = to[m + 1];\n      var x = x0 * onet + x1 * t;\n      var y = y0 * onet + y1 * t;\n      tmpArr[m] = x * ca - y * sa + newCp[0];\n      tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n    }\n    for (var m = 0; m < from.length;) {\n      if (m === 0) {\n        path.moveTo(tmpArr[m++], tmpArr[m++]);\n      }\n      path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n    }\n  }\n}\n;\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n  if (isIndividualMorphingPath(path)) {\n    updateIndividualMorphingPath(path, morphingData, morphT);\n    return;\n  }\n  var morphingPath = path;\n  morphingPath.__oldBuildPath = morphingPath.buildPath;\n  morphingPath.buildPath = morphingPathBuildPath;\n  updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n  morphingPath.__morphingData = morphingData;\n  morphingPath.__morphT = morphT;\n}\nfunction restoreIndividualMorphingPath(path) {\n  if (isIndividualMorphingPath(path)) {\n    path.buildPath = path.__oldBuildPath;\n    path.__oldBuildPath = path.__morphingData = null;\n  }\n}\nfunction isIndividualMorphingPath(path) {\n  return path.__oldBuildPath != null;\n}\nfunction isCombiningPath(path) {\n  return !!path.__combiningSubList;\n}\nexports.isCombiningPath = isCombiningPath;\nfunction isInAnyMorphing(path) {\n  return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexports.isInAnyMorphing = isInAnyMorphing;\nfunction combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n  var fromIndividuals = [];\n  var separateCount = 0;\n  for (var i = 0; i < fromPathList.length; i++) {\n    var fromPath = fromPathList[i];\n    if (isCombiningPath(fromPath)) {\n      var fromCombiningSubList = fromPath.__combiningSubList;\n      for (var j = 0; j < fromCombiningSubList.length; j++) {\n        fromIndividuals.push(fromCombiningSubList[j]);\n      }\n      separateCount += fromCombiningSubList.length;\n    } else {\n      fromIndividuals.push(fromPath);\n      separateCount++;\n    }\n  }\n  if (!separateCount) {\n    return;\n  }\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n  util_1.assert(toPathSplittedList.length === separateCount);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  var doneCount = 0;\n  var abortedCalled = false;\n  var morphAnimationOpts = util_1.defaults({\n    during: function (p) {\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      doneCount++;\n      if (doneCount === toPathSplittedList.length) {\n        restoreCombiningPath(toPath);\n        oldDone && oldDone();\n      }\n    },\n    aborted: function () {\n      if (!abortedCalled) {\n        abortedCalled = true;\n        oldAborted && oldAborted();\n      }\n    }\n  }, animationOpts);\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromIndividuals[i];\n    var to = toPathSplittedList[i];\n    copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n    morphPath(from, to, morphAnimationOpts);\n  }\n  becomeCombiningPath(toPath, toPathSplittedList);\n  return {\n    fromIndividuals: fromIndividuals,\n    toIndividuals: toPathSplittedList,\n    count: separateCount\n  };\n}\nexports.combine = combine;\nfunction becomeCombiningPath(path, combiningSubList) {\n  if (isCombiningPath(path)) {\n    updateCombiningPathSubList(path, combiningSubList);\n    return;\n  }\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, combiningSubList);\n  combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n  combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n  combiningPath.addSelfToZr = combiningAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n  combiningPath.__oldBuildPath = combiningPath.buildPath;\n  combiningPath.buildPath = util_1.noop;\n  combiningPath.childrenRef = combiningChildrenRef;\n}\nfunction restoreCombiningPath(path) {\n  if (!isCombiningPath(path)) {\n    return;\n  }\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, null);\n  combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n  combiningPath.buildPath = combiningPath.__oldBuildPath;\n  combiningPath.childrenRef = combiningPath.__combiningSubList = combiningPath.__oldAddSelfToZr = combiningPath.__oldRemoveSelfFromZr = combiningPath.__oldBuildPath = null;\n}\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n  if (combiningPath.__combiningSubList !== combiningSubList) {\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n    combiningPath.__combiningSubList = combiningSubList;\n    if (combiningSubList) {\n      for (var i = 0; i < combiningSubList.length; i++) {\n        combiningSubList[i].parent = combiningPath;\n      }\n    }\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n  }\n}\nfunction combiningAddSelfToZr(zr) {\n  this.__oldAddSelfToZr(zr);\n  combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n  var combiningSubList = path.__combiningSubList;\n  var zr = path.__zr;\n  if (combiningSubList && zr) {\n    for (var i = 0; i < combiningSubList.length; i++) {\n      var child = combiningSubList[i];\n      child[method](zr);\n    }\n  }\n}\nfunction combiningRemoveSelfFromZr(zr) {\n  this.__oldRemoveSelfFromZr(zr);\n  var combiningSubList = this.__combiningSubList;\n  for (var i = 0; i < combiningSubList.length; i++) {\n    var child = combiningSubList[i];\n    child.removeSelfFromZr(zr);\n  }\n}\nfunction combiningChildrenRef() {\n  return this.__combiningSubList;\n}\nfunction separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n  var toPathListLen = toPathList.length;\n  var fromPathList;\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var copyProps = false;\n  if (isCombiningPath(fromPath)) {\n    var fromCombiningSubList = fromPath.__combiningSubList;\n    if (fromCombiningSubList.length === toPathListLen) {\n      fromPathList = fromCombiningSubList;\n    } else {\n      fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n      copyProps = true;\n    }\n  } else {\n    fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n    copyProps = true;\n  }\n  util_1.assert(fromPathList.length === toPathListLen);\n  for (var i = 0; i < toPathListLen; i++) {\n    if (copyProps && copyPropsIfDivided) {\n      copyPropsIfDivided(fromPath, fromPathList[i], false);\n    }\n    morphPath(fromPathList[i], toPathList[i], animationOpts);\n  }\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathListLen\n  };\n}\nexports.separate = separate;\nfunction divideShape(path, separateCount, dividingMethod) {\n  return dividingMethod === 'duplicate' ? duplicateShape(path, separateCount) : splitShape(path, separateCount);\n}\nfunction splitShape(path, separateCount) {\n  var resultPaths = [];\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n  if (separateCount === 1) {\n    return duplicateShape(path, separateCount);\n  }\n  if (path instanceof Rect_1[\"default\"]) {\n    var toPathShape = path.shape;\n    var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n    var propWH = PROP_WH[splitPropIdx];\n    var propXY = PROP_XY[splitPropIdx];\n    var subWH = toPathShape[propWH] / separateCount;\n    var xyCurr = toPathShape[propXY];\n    for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n      var subShape = {\n        x: toPathShape.x,\n        y: toPathShape.y,\n        width: toPathShape.width,\n        height: toPathShape.height\n      };\n      subShape[propXY] = xyCurr;\n      subShape[propWH] = i < separateCount - 1 ? subWH : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n      var splitted = new Rect_1[\"default\"]({\n        shape: subShape\n      });\n      resultPaths.push(splitted);\n    }\n  } else if (path instanceof Sector_1[\"default\"]) {\n    var toPathShape = path.shape;\n    var clockwise = toPathShape.clockwise;\n    var startAngle = toPathShape.startAngle;\n    var endAngle = toPathShape.endAngle;\n    var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n    var step = (endAngleNormalized - startAngle) / separateCount;\n    var angleCurr = startAngle;\n    for (var i = 0; i < separateCount; i++, angleCurr += step) {\n      var splitted = new Sector_1[\"default\"]({\n        shape: {\n          cx: toPathShape.cx,\n          cy: toPathShape.cy,\n          r: toPathShape.r,\n          r0: toPathShape.r0,\n          clockwise: clockwise,\n          startAngle: angleCurr,\n          endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n        }\n      });\n      resultPaths.push(splitted);\n    }\n  } else {\n    return duplicateShape(path, separateCount);\n  }\n  return resultPaths;\n}\nfunction duplicateShape(path, separateCount) {\n  var resultPaths = [];\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n  var ctor = path.constructor;\n  for (var i = 0; i < separateCount; i++) {\n    var sub = new ctor({\n      shape: util_1.clone(path.shape)\n    });\n    resultPaths.push(sub);\n  }\n  return resultPaths;\n}\nfunction normalizeRadian(start, end, clockwise) {\n  return end + PI2 * Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2);\n}","map":{"version":3,"names":["exports","__esModule","PathProxy_1","require","curve_1","util_1","vector_1","Rect_1","Sector_1","CMD","PI2","Math","PI","PROP_XY","PROP_WH","tmpArr","aroundEqual","a","b","abs","pathToBezierCurves","path","data","len","bezierArray","currentSubpath","xi","yi","x0","y0","createNewSubpath","x","y","length","push","addLine","x1","y1","addArc","startAngle","endAngle","cx","cy","rx","ry","delta","tan","dir","c1","cos","s1","sin","c2","s2","x4","y4","hx","hy","x2","y2","i","cmd","isFirst","L","C","Q","M","A","anticlockwise","step","angle","nextAngle","max","min","R","Z","alignSubpath","subpath1","subpath2","len1","len2","shorterPath","shorterLen","diff","shorterBezierCount","eachCurveSubDivCount","ceil","newSubpath","remained","tmpSegX","tmpSegY","x3","y3","actualSubDivCount","k","p","cubicSubdivide","createSubpath","lastSubpathSubpath","otherSubpath","lastX","lastY","alignBezierCurves","array1","array2","_a","lastSubpath1","lastSubpath2","newArray1","newArray2","newSubpath1","newSubpath2","centroid","array","signedArea","j","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","idx","dx","dy","reverse","newArr","findBestMorphingRotation","fromArr","toArr","searchAngleIteration","searchAngleRange","result","fromNeedsReverse","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr_1","sa","ca","newX1","newY1","m","i_1","from","to","rotation","morphPath","fromPath","toPath","animationOpts","fromPathProxy","toPathProxy","createPathProxy","beginPath","buildPath","shape","isIndividualMorphingPath","__oldBuildPath","fromBezierCurves","toBezierCurves","morphingData","becomeIndividualMorphingPath","oldDone","done","oldAborted","aborted","oldDuring","during","animateTo","__morphT","defaults","dirtyShape","restoreIndividualMorphingPath","morphingPathBuildPath","__morphingData","t","onet","newCp","item","lerp","moveTo","bezierCurveTo","morphT","updateIndividualMorphingPath","morphingPath","isCombiningPath","__combiningSubList","isInAnyMorphing","combine","fromPathList","copyPropsIfDivided","fromIndividuals","separateCount","fromCombiningSubList","dividingMethod","toPathSplittedList","divideShape","assert","doneCount","abortedCalled","morphAnimationOpts","restoreCombiningPath","becomeCombiningPath","toIndividuals","count","combiningSubList","updateCombiningPathSubList","combiningPath","__oldAddSelfToZr","addSelfToZr","__oldRemoveSelfFromZr","removeSelfFromZr","combiningAddSelfToZr","combiningRemoveSelfFromZr","noop","childrenRef","combiningChildrenRef","combiningPathSubListAddRemoveWithZr","parent","zr","method","__zr","child","separate","toPathList","toPathListLen","copyProps","duplicateShape","splitShape","resultPaths","toPathShape","splitPropIdx","height","width","propWH","propXY","subWH","xyCurr","subShape","splitted","clockwise","endAngleNormalized","normalizeRadian","angleCurr","r","r0","ctor","constructor","sub","clone","start","end"],"sources":["C:/Users/guzny/OneDrive/Рабочий стол/frontend/node_modules/zrender/lib/tool/morphPath.js"],"sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar PathProxy_1 = require(\"../core/PathProxy\");\nvar curve_1 = require(\"../core/curve\");\nvar util_1 = require(\"../core/util\");\nvar vector_1 = require(\"../core/vector\");\nvar Rect_1 = require(\"../graphic/shape/Rect\");\nvar Sector_1 = require(\"../graphic/shape/Sector\");\nvar CMD = PathProxy_1[\"default\"].CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nfunction pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArray = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArray.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArray.push(currentSubpath);\n    }\n    return bezierArray;\n}\nexports.pathToBezierCurves = pathToBezierCurves;\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    var tmpSegX = [];\n    var tmpSegY = [];\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            curve_1.cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            curve_1.cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nfunction alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexports.alignBezierCurves = alignBezierCurves;\nfunction centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nexports.centroid = centroid;\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr_1 = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr_1[k] = newX1;\n                    tmpArr_1[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr_1.length; m++) {\n                        newToSubpathBezier[m] = tmpArr_1[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nfunction morphPath(fromPath, toPath, animationOpts) {\n    var fromPathProxy;\n    var toPathProxy;\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    !fromPath.path && fromPath.createPathProxy();\n    fromPathProxy = fromPath.path;\n    fromPathProxy.beginPath();\n    fromPath.buildPath(fromPathProxy, fromPath.shape);\n    !toPath.path && toPath.createPathProxy();\n    toPathProxy = toPath.path;\n    toPathProxy === fromPathProxy && (toPathProxy = new PathProxy_1[\"default\"](false));\n    toPathProxy.beginPath();\n    if (isIndividualMorphingPath(toPath)) {\n        toPath.__oldBuildPath(toPathProxy, toPath.shape);\n    }\n    else {\n        toPath.buildPath(toPathProxy, toPath.shape);\n    }\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    becomeIndividualMorphingPath(toPath, morphingData, 0);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    toPath.animateTo({\n        __morphT: 1\n    }, util_1.defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreIndividualMorphingPath(toPath);\n            toPath.createPathProxy();\n            toPath.dirtyShape();\n            oldDone && oldDone();\n        },\n        aborted: function () {\n            oldAborted && oldAborted();\n        }\n    }, animationOpts));\n    return toPath;\n}\nexports.morphPath = morphPath;\nfunction morphingPathBuildPath(path) {\n    var morphingData = this.__morphingData;\n    var t = this.__morphT;\n    var onet = 1 - t;\n    var newCp = [];\n    for (var i = 0; i < morphingData.length; i++) {\n        var item = morphingData[i];\n        var from = item.from;\n        var to = item.to;\n        var angle = item.rotation * t;\n        var fromCp = item.fromCp;\n        var toCp = item.toCp;\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        vector_1.lerp(newCp, fromCp, toCp, t);\n        for (var m = 0; m < from.length; m += 2) {\n            var x0 = from[m];\n            var y0 = from[m + 1];\n            var x1 = to[m];\n            var y1 = to[m + 1];\n            var x = x0 * onet + x1 * t;\n            var y = y0 * onet + y1 * t;\n            tmpArr[m] = (x * ca - y * sa) + newCp[0];\n            tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n        }\n        for (var m = 0; m < from.length;) {\n            if (m === 0) {\n                path.moveTo(tmpArr[m++], tmpArr[m++]);\n            }\n            path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n        }\n    }\n}\n;\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n    if (isIndividualMorphingPath(path)) {\n        updateIndividualMorphingPath(path, morphingData, morphT);\n        return;\n    }\n    var morphingPath = path;\n    morphingPath.__oldBuildPath = morphingPath.buildPath;\n    morphingPath.buildPath = morphingPathBuildPath;\n    updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n    morphingPath.__morphingData = morphingData;\n    morphingPath.__morphT = morphT;\n}\nfunction restoreIndividualMorphingPath(path) {\n    if (isIndividualMorphingPath(path)) {\n        path.buildPath = path.__oldBuildPath;\n        path.__oldBuildPath = path.__morphingData = null;\n    }\n}\nfunction isIndividualMorphingPath(path) {\n    return path.__oldBuildPath != null;\n}\nfunction isCombiningPath(path) {\n    return !!path.__combiningSubList;\n}\nexports.isCombiningPath = isCombiningPath;\nfunction isInAnyMorphing(path) {\n    return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexports.isInAnyMorphing = isInAnyMorphing;\nfunction combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n    var fromIndividuals = [];\n    var separateCount = 0;\n    for (var i = 0; i < fromPathList.length; i++) {\n        var fromPath = fromPathList[i];\n        if (isCombiningPath(fromPath)) {\n            var fromCombiningSubList = fromPath.__combiningSubList;\n            for (var j = 0; j < fromCombiningSubList.length; j++) {\n                fromIndividuals.push(fromCombiningSubList[j]);\n            }\n            separateCount += fromCombiningSubList.length;\n        }\n        else {\n            fromIndividuals.push(fromPath);\n            separateCount++;\n        }\n    }\n    if (!separateCount) {\n        return;\n    }\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n    util_1.assert(toPathSplittedList.length === separateCount);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    var doneCount = 0;\n    var abortedCalled = false;\n    var morphAnimationOpts = util_1.defaults({\n        during: function (p) {\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            doneCount++;\n            if (doneCount === toPathSplittedList.length) {\n                restoreCombiningPath(toPath);\n                oldDone && oldDone();\n            }\n        },\n        aborted: function () {\n            if (!abortedCalled) {\n                abortedCalled = true;\n                oldAborted && oldAborted();\n            }\n        }\n    }, animationOpts);\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromIndividuals[i];\n        var to = toPathSplittedList[i];\n        copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n        morphPath(from, to, morphAnimationOpts);\n    }\n    becomeCombiningPath(toPath, toPathSplittedList);\n    return {\n        fromIndividuals: fromIndividuals,\n        toIndividuals: toPathSplittedList,\n        count: separateCount\n    };\n}\nexports.combine = combine;\nfunction becomeCombiningPath(path, combiningSubList) {\n    if (isCombiningPath(path)) {\n        updateCombiningPathSubList(path, combiningSubList);\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, combiningSubList);\n    combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n    combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n    combiningPath.addSelfToZr = combiningAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n    combiningPath.__oldBuildPath = combiningPath.buildPath;\n    combiningPath.buildPath = util_1.noop;\n    combiningPath.childrenRef = combiningChildrenRef;\n}\nfunction restoreCombiningPath(path) {\n    if (!isCombiningPath(path)) {\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, null);\n    combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n    combiningPath.buildPath = combiningPath.__oldBuildPath;\n    combiningPath.childrenRef =\n        combiningPath.__combiningSubList =\n            combiningPath.__oldAddSelfToZr =\n                combiningPath.__oldRemoveSelfFromZr =\n                    combiningPath.__oldBuildPath = null;\n}\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n    if (combiningPath.__combiningSubList !== combiningSubList) {\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n        combiningPath.__combiningSubList = combiningSubList;\n        if (combiningSubList) {\n            for (var i = 0; i < combiningSubList.length; i++) {\n                combiningSubList[i].parent = combiningPath;\n            }\n        }\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n    }\n}\nfunction combiningAddSelfToZr(zr) {\n    this.__oldAddSelfToZr(zr);\n    combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n    var combiningSubList = path.__combiningSubList;\n    var zr = path.__zr;\n    if (combiningSubList && zr) {\n        for (var i = 0; i < combiningSubList.length; i++) {\n            var child = combiningSubList[i];\n            child[method](zr);\n        }\n    }\n}\nfunction combiningRemoveSelfFromZr(zr) {\n    this.__oldRemoveSelfFromZr(zr);\n    var combiningSubList = this.__combiningSubList;\n    for (var i = 0; i < combiningSubList.length; i++) {\n        var child = combiningSubList[i];\n        child.removeSelfFromZr(zr);\n    }\n}\nfunction combiningChildrenRef() {\n    return this.__combiningSubList;\n}\nfunction separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n    var toPathListLen = toPathList.length;\n    var fromPathList;\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var copyProps = false;\n    if (isCombiningPath(fromPath)) {\n        var fromCombiningSubList = fromPath.__combiningSubList;\n        if (fromCombiningSubList.length === toPathListLen) {\n            fromPathList = fromCombiningSubList;\n        }\n        else {\n            fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n            copyProps = true;\n        }\n    }\n    else {\n        fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n        copyProps = true;\n    }\n    util_1.assert(fromPathList.length === toPathListLen);\n    for (var i = 0; i < toPathListLen; i++) {\n        if (copyProps && copyPropsIfDivided) {\n            copyPropsIfDivided(fromPath, fromPathList[i], false);\n        }\n        morphPath(fromPathList[i], toPathList[i], animationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathListLen\n    };\n}\nexports.separate = separate;\nfunction divideShape(path, separateCount, dividingMethod) {\n    return dividingMethod === 'duplicate'\n        ? duplicateShape(path, separateCount)\n        : splitShape(path, separateCount);\n}\nfunction splitShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    if (separateCount === 1) {\n        return duplicateShape(path, separateCount);\n    }\n    if (path instanceof Rect_1[\"default\"]) {\n        var toPathShape = path.shape;\n        var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n        var propWH = PROP_WH[splitPropIdx];\n        var propXY = PROP_XY[splitPropIdx];\n        var subWH = toPathShape[propWH] / separateCount;\n        var xyCurr = toPathShape[propXY];\n        for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n            var subShape = {\n                x: toPathShape.x,\n                y: toPathShape.y,\n                width: toPathShape.width,\n                height: toPathShape.height\n            };\n            subShape[propXY] = xyCurr;\n            subShape[propWH] = i < separateCount - 1\n                ? subWH\n                : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n            var splitted = new Rect_1[\"default\"]({ shape: subShape });\n            resultPaths.push(splitted);\n        }\n    }\n    else if (path instanceof Sector_1[\"default\"]) {\n        var toPathShape = path.shape;\n        var clockwise = toPathShape.clockwise;\n        var startAngle = toPathShape.startAngle;\n        var endAngle = toPathShape.endAngle;\n        var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n        var step = (endAngleNormalized - startAngle) / separateCount;\n        var angleCurr = startAngle;\n        for (var i = 0; i < separateCount; i++, angleCurr += step) {\n            var splitted = new Sector_1[\"default\"]({\n                shape: {\n                    cx: toPathShape.cx,\n                    cy: toPathShape.cy,\n                    r: toPathShape.r,\n                    r0: toPathShape.r0,\n                    clockwise: clockwise,\n                    startAngle: angleCurr,\n                    endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n                }\n            });\n            resultPaths.push(splitted);\n        }\n    }\n    else {\n        return duplicateShape(path, separateCount);\n    }\n    return resultPaths;\n}\nfunction duplicateShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    var ctor = path.constructor;\n    for (var i = 0; i < separateCount; i++) {\n        var sub = new ctor({\n            shape: util_1.clone(path.shape)\n        });\n        resultPaths.push(sub);\n    }\n    return resultPaths;\n}\nfunction normalizeRadian(start, end, clockwise) {\n    return end + PI2 * (Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}